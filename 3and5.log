2024-09-20 15:57:11.167 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:57:11.168 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:57:18.649 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:57:18.649 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:57:27.460 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:57:27.461 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:57:37.626 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-20 15:57:37.626 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-20 15:57:50.941 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:57:50.941 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:57:52.771 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 15:57:52.771 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 15:58:05.477 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 15:58:05.478 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 15:58:05.630 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 15:58:05.631 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 15:58:07.435 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 15:58:07.435 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 15:58:09.522 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 15:58:09.523 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 15:58:09.908 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 15:58:09.908 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 15:58:23.101 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 15:58:23.101 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 15:58:23.257 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 15:58:23.258 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 15:58:23.354 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-20 15:58:23.355 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-20 15:58:24.122 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 15:58:24.122 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 15:58:24.425 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-20 15:58:24.425 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-20 15:59:19.602 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:59:19.602 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:59:21.689 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:59:21.689 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:59:23.874 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:59:23.875 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:59:41.940 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 89bf7b5e3a226525e8580bae21ef543604f99b21)
2024-09-20 15:59:41.940 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 89bf7b5e3a226525e8580bae21ef543604f99b21)
2024-09-20 15:59:45.862 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:59:45.863 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:59:47.593 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 15:59:47.593 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 16:00:09.084 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 16:00:09.084 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 16:00:09.237 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 16:00:09.237 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 16:00:10.948 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 16:00:10.949 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 16:00:12.972 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 16:00:12.972 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 16:00:13.623 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 16:00:13.623 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 16:00:14.006 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 16:00:14.006 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 16:00:14.162 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 16:00:14.162 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 16:00:14.962 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 16:00:14.962 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 16:00:15.288 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-20 16:00:15.288 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
================================================================================

Proved sorry theorems only in first database: 2

Theorem: SciLean.ite_pull_ennreal_toReal
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_ennreal_toReal (c : Prop) [Decidable c] (x y : ENNReal)  :
    (if c then x else y).toReal
    =
    (if c then x.toReal else y.toReal) :=
Proof:
  split_ifs <;> rfl


Theorem: SciLean.re_float
File path: SciLean/Core/FloatAsReal.lean
Theorem statement: theorem re_float  (a : Float)
  : RCLike.re a = a :=
Proof:
  exact RCLike.re_eq_self_of_le le_rfl


Proved sorry theorems only in second database: 4

Theorem: SciLean.parametric_inverse_bijection
File path: SciLean/Core/Integral/ParametricInverse.lean
Theorem statement: theorem parametric_inverse_bijection [Nonempty X] (f : X ‚Üí Y) (hf : f.Bijective) (y : Y) :
    ParametricInverseAt f y
      (I := Unit) (X‚ÇÅ := fun _ => Unit)
      (p := fun _ _ x => x)
      (g := fun _ _ => f.invFun y)
      (dom := fun _ => Set.univ) :=
Proof:
  dsimp [ParametricInverseAt]
  intros
  apply Function.invFun_eq
  simpa using hf.2 y


Theorem: Function.Bijective.Equiv.invFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.invFun.arg_a0.Bijective_rule (f : Y ‚âÉ Z) (g : X ‚Üí Z) (hf : Bijective g)
  : Bijective (fun x => f.invFun (g x)) :=
Proof:
  convert hf
  simp [hf]
  exact f.symm.bijective.comp hf


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple'
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple'
  : Bijective (fun xy : X√óY => (xy.2, xy.1))
  :=
Proof:
  constructor <;> intro h
  all_goals aesop


Theorem: SciLean.CDifferentiable.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.id_rule
  : CDifferentiable K (fun x : X => x)
  :=
Proof:
  intro i
  rw [CDifferentiableAt]
  tauto


Common Proved sorry theorems: 20

Theorem: IsLinearMap.isLinearMap_const_zero
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_const_zero
  : IsLinearMap R (fun _ : X => (0 : Y))
  :=

Proof:
  constructor
  all_goals aesop
Proofs are identical in both databases.


Theorem: SciLean.scalar_min_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_zero_one  : min (0 : R) (1 : R) = 0 :=

Proof:
  rw [min_comm]
  simp
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffMap.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap.zero_apply : (0 : X ‚üø[K,n] Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.Measure.prod_volume
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_volume {X Y} [MeasureSpace X] [MeasureSpace Y]  :
    (Measure.prod (volume : Measure X) (volume : Measure Y)) = volume :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.scalar_max_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_zero_one  : max (0 : R) (1 : R) = 1 :=

Proof:
  rw [max_comm]
  simp
Proofs are identical in both databases.


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple
  : Bijective (fun xy : X√óY => (xy.1, xy.2))
  :=

Proof:
  simp
  exact Function.bijective_id
Proofs differ:
Proof in second database:
  constructor <;> intro h
  all_goals aesop


Theorem: SciLean.CDifferentiableAt.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.id_rule (x : X)
  : CDifferentiableAt K (fun x : X => x) x
  :=

Proof:
  unfold SciLean.CDifferentiableAt
  tauto
Proofs differ:
Proof in second database:
  rw [CDifferentiableAt]
  intro c hc hcx
  simpa using hcx


Theorem: SciLean.norm‚ÇÇ_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_scalar {R} [RealScalar R] (x : R) :
  ‚Äñx‚Äñ‚ÇÇ[R] = Scalar.abs x :=

Proof:
  rw [SciLean.scalar_norm]
Proofs differ:
Proof in second database:
  simp


Theorem: SciLean.Distribution.action_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.action_iteD (A : Set X) (t e : ùíü'(X,Y)) (œÜ : ùíü X) :
   iteD A t e œÜ =
        t.extAction (fun x => if x ‚àà A then œÜ x else 0) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) +
        e.extAction (fun x => if x ‚àâ A then œÜ x else 0) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) :=

Proof:
  aesop
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffAt.id_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.id_rule (x : X) :
    ContCDiffAt K n (fun x : X => x) x :=

Proof:
  unfold SciLean.ContCDiffAt
  tauto
Proofs differ:
Proof in second database:
  rw [ContCDiffAt]
  tauto


Theorem: Function.invFun.id_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem id_rule
  : invFun (fun (x : X) => x)
    =
    fun x => x :=

Proof:
  apply Function.invFun_comp
  exact Function.injective_id
Proofs differ:
Proof in second database:
  ext x
  apply Function.leftInverse_invFun
  exact Function.injective_id


Theorem: SciLean.scalar_div_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_div_one (x : R) : x / 1 = x :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: SciLean.CDifferentiableAt.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : CDifferentiableAt K (fun x => f (g x)) x
  :=

Proof:
  rw [CDifferentiableAt] at *
  aesop
Proofs are identical in both databases.


Theorem: SciLean.ite_pull_measureOf
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_measureOf {X} [MeasurableSpace X] (c : Prop) [Decidable c] (Œº ŒΩ : Measure X) (A : Set X) :
    (if c then Œº else ŒΩ) A
    =
    (if c then Œº A else ŒΩ A) :=

Proof:
  split_ifs <;> rfl
Proofs are identical in both databases.


Theorem: Function.Bijective.Equiv.toFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.toFun.arg_a0.Bijective_rule (f : Y ‚âÉ Z) (g : X ‚Üí Y) (hf : Bijective g)
  : Bijective (fun x => f (g x)) :=

Proof:
  inhabit Z
  exact f.bijective.comp hf
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffMapFD.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD.zero_apply : (0 : X ‚üøFD[K,n] Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.SmoothLinearMap.zero_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.zero_apply : (0 : X‚ä∏[K]Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: IsLinearMap.isLinearMap_apply
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_apply (i : Œπ) : IsLinearMap R (fun f : (i : Œπ) ‚Üí E i ‚Ü¶ f i) :=

Proof:
  constructor
  all_goals aesop
Proofs are identical in both databases.


Theorem: IsAffineMap.IsAffineMap_apply
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_apply (i : Œπ) : IsAffineMap R (fun f : (i : Œπ) ‚Üí E i ‚Ü¶ f i) :=

Proof:
  constructor
  constructor
  simp
  simp
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffAt.comp_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.comp_rule (x : X)
    (f : Y ‚Üí Z) (g : X ‚Üí Y)
    (hf : ContCDiffAt K n f (g x)) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f (g x)) x :=

Proof:
  rw [ContCDiffAt] at *
  aesop
Proofs are identical in both databases.


================================================================================
Comparing Proved sorry theorems for repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
================================================================================

Proved sorry theorems only in first database: 1

Theorem: condRho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_translate {Œ© S : Type*} [MeasureSpace Œ©] (X : Œ© ‚Üí G) (Y : Œ© ‚Üí S) (A : Finset G) (s:G) : condRho (fun œâ ‚Ü¶ X œâ + s) Y A = condRho X Y A :=
Proof:
  simp only [condRho, rho_of_translate]


Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0
Repository https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566) not found in the second database.

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
================================================================================

Proved sorry theorems only in first database: 5

Theorem: absorb2
File path: MIL/C02_Basics/S05_Proving_Facts_about_Algebraic_Structures.lean
Theorem statement: theorem absorb2 : x ‚äî x ‚äì y = x :=
Proof:
  simp


Theorem: MyRing.zero_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem zero_mul (a : R) : 0 * a = 0 :=
Proof:
  rw [MulZeroClass.zero_mul]


Theorem: MyGroup.mul_inv_rev
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_inv_rev (a b : G) : (a * b)‚Åª¬π = b‚Åª¬π * a‚Åª¬π :=
Proof:
  simp


Theorem: MyRing.eq_neg_of_add_eq_zero
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem eq_neg_of_add_eq_zero {a b : R} (h : a + b = 0) : a = -b :=
Proof:
  rwa [eq_neg_iff_add_eq_zero]


Theorem: C03S05.MyAbs.neg_le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem neg_le_abs_self (x : ‚Ñù) : -x ‚â§ |x| :=
Proof:
  simpa using C03S05.MyAbs.le_abs_self (-x)


Proved sorry theorems only in second database: 5

Theorem: MyRing.two_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem two_mul (a : R) : 2 * a = a + a :=
Proof:
  rw [‚Üê one_add_one_eq_two]
  rw [add_mul, one_mul]


Theorem: C03S04.aux
File path: MIL/C03_Logic/S04_Conjunction_and_Iff.lean
Theorem statement: None
Proof:
  nlinarith


Theorem: C03S05.MyAbs.le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem le_abs_self (x : ‚Ñù) : x ‚â§ |x| :=
Proof:
  cases x
  simp [abs]


Theorem: C03S01.my_lemma3
File path: MIL/C03_Logic/S01_Implication_and_the_Universal_Quantifier.lean
Theorem statement: theorem my_lemma3 :
    ‚àÄ {x y Œµ : ‚Ñù}, 0 < Œµ ‚Üí Œµ ‚â§ 1 ‚Üí |x| < Œµ ‚Üí |y| < Œµ ‚Üí |x * y| < Œµ :=
Proof:
  apply C03S01.my_lemma2


Theorem: MyRing.self_sub
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem self_sub (a : R) : a - a = 0 :=
Proof:
  simp


Common Proved sorry theorems: 9

Theorem: MyRing.neg_eq_of_add_eq_zero
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem neg_eq_of_add_eq_zero {a b : R} (h : a + b = 0) : -a = b :=

Proof:
  rw [add_eq_zero_iff_eq_neg] at h
  simp [h]
Proofs differ:
Proof in second database:
  exact neg_eq_iff_add_eq_zero.mpr h


Theorem: MyRing.neg_neg
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem neg_neg (a : R) : - -a = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: absorb1
File path: MIL/C02_Basics/S05_Proving_Facts_about_Algebraic_Structures.lean
Theorem statement: theorem absorb1 : x ‚äì (x ‚äî y) = x :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyRing.add_neg_cancel_right
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_neg_cancel_right (a b : R) : a + b + -b = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyGroup.mul_right_inv
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_right_inv (a : G) : a * a‚Åª¬π = 1 :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyRing.add_right_cancel
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_right_cancel {a b c : R} (h : a + b = c + b) : a = c :=

Proof:
  simpa using h
Proofs are identical in both databases.


Theorem: MyGroup.mul_one
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_one (a : G) : a * 1 = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: C03S05.MyAbs.abs_add
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem abs_add (x y : ‚Ñù) : |x + y| ‚â§ |x| + |y| :=

Proof:
  apply abs_add_le
Proofs are identical in both databases.


Theorem: MyRing.add_left_cancel
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_left_cancel {a b c : R} (h : a + b = a + c) : b = c :=

Proof:
  simpa using h
Proofs differ:
Proof in second database:
  rwa [add_right_inj] at h


================================================================================
Comparing Proved sorry theorems for repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0
Repository https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab) not found in the second database.

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
================================================================================

Unproved sorry theorems only in first database: 4

Theorem: SciLean.parametric_inverse_bijection
File path: SciLean/Core/Integral/ParametricInverse.lean
Theorem statement: theorem parametric_inverse_bijection [Nonempty X] (f : X ‚Üí Y) (hf : f.Bijective) (y : Y) :
    ParametricInverseAt f y
      (I := Unit) (X‚ÇÅ := fun _ => Unit)
      (p := fun _ _ x => x)
      (g := fun _ _ => f.invFun y)
      (dom := fun _ => Set.univ) :=


Theorem: Function.Bijective.Equiv.invFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.invFun.arg_a0.Bijective_rule (f : Y ‚âÉ Z) (g : X ‚Üí Z) (hf : Bijective g)
  : Bijective (fun x => f.invFun (g x)) :=


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple'
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple'
  : Bijective (fun xy : X√óY => (xy.2, xy.1))
  :=


Theorem: SciLean.CDifferentiable.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.id_rule
  : CDifferentiable K (fun x : X => x)
  :=


Unproved sorry theorems only in second database: 2

Theorem: SciLean.ite_pull_ennreal_toReal
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_ennreal_toReal (c : Prop) [Decidable c] (x y : ENNReal)  :
    (if c then x else y).toReal
    =
    (if c then x.toReal else y.toReal) :=


Theorem: SciLean.re_float
File path: SciLean/Core/FloatAsReal.lean
Theorem statement: theorem re_float  (a : Float)
  : RCLike.re a = a :=


Common Unproved sorry theorems: 268

Theorem: SciLean.IndexType.sum.arg_f.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.cderiv_rule_at
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : cderiv K (fun x => ‚àë i, f x i) x
    =
    fun dx => ‚àë i, cderiv K (f ¬∑ i) x dx :=



Theorem: SciLean.ContCDiffMap_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiableAt (f : W ‚Üí X ‚üø[K,‚àû] Y) (g : W ‚Üí X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=



Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiff_rule
    (f g : X ‚Üí Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x - g x) :=



Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) (hx : ‚àÄ x, g x ‚â† 0) :
    (cderiv K fun x => f x / g x)
    =
    fun x =>
      let k := f x
      let k' := g x
      fun dx =>
        ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=



Theorem: SciLean.scalar_sqrt_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_zero  : Scalar.sqrt (0 : R) = 0 :=



Theorem: SciLean.semiAdjoint.Prod.fst.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.semiAdjoint_rule
  (f : X ‚Üí Y√óZ) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).1)
    =
    (fun y => semiAdjoint K (fun x => f x) (y,0)) :=



Theorem: SciLean.cintegral.arg_f.parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem cintegral.arg_f.parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y ‚Üí Z) :
    parDistribDeriv (fun w => (fun x => ‚à´' y, f w x y).toDistribution (R:=R))
    =
    fun w dw =>
      let Tf := (fun w => (fun x => (fun y => f w x y).toDistribution (R:=R)).toDistribution (R:=R))
      parDistribDeriv Tf w dw |>.postComp (fun T ‚ä∏ T.extAction (fun _ => (1:R)) (fun z ‚ä∏ fun r ‚ä∏ r ‚Ä¢ z)) :=



Theorem: SciLean.HasSemiAdjoint.Finset.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.HasSemiAdjoint_rule {Œπ : Type _} [Fintype Œπ]
  (f : X ‚Üí Œπ ‚Üí Y) (_ : ‚àÄ i, HasSemiAdjoint K fun x : X => f x i) (A : Finset Œπ)
  : HasSemiAdjoint K fun x => ‚àë i in A, f x i :=



Theorem: SciLean.Distribution.add_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.add_extAction (T T' : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    ((T + T') : ùíü'(X,U)).extAction œÜ L = T.extAction œÜ L + T'.extAction œÜ L :=



Theorem: SciLean.semiAdjoint.comp_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => f (g x))
    =
    fun z =>
      let y := semiAdjoint K f z
      let x := semiAdjoint K g y
      x :=



Theorem: SciLean.HasSemiAdjoint.const_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem const_rule : HasSemiAdjoint K (fun _ : X => (0:Y)) :=



Theorem: LeanColls.Range.fold_def
File path: .lake/packages/leancolls/LeanColls/Data/Range.lean
Theorem statement: theorem fold_def (r : Range) (f : Œ≤ ‚Üí Nat ‚Üí Œ≤)
    : fold r f init =
      Fin.foldl (r.size) (fun acc i => f acc (r.get i)) init
  :=



Theorem: SciLean.semiAdjoint.HSub.hSub.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.semiAdjoint_rule
  (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x - g x)
    =
    fun y =>
      let x‚ÇÅ := semiAdjoint K f y
      let x‚ÇÇ := semiAdjoint K g y
      x‚ÇÅ - x‚ÇÇ :=



Theorem: SciLean.proj_zero
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem proj_zero (i : Œπ)
  : ‚Ñº i (0 : X) = 0 :=



Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiable (f : W ‚Üí X ‚üøFD[K,‚àû] Y) (g : W ‚Üí X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=



Theorem: SciLean.HasSemiAdjoint.Prod.snd.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.HasSemiAdjoint_rule
    (f : X ‚Üí Y√óZ) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).snd :=



Theorem: SciLean.toDistribution.linear_parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem toDistribution.linear_parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y) (L : Y ‚Üí Z)
    (hL : IsSmoothLinearMap R L) :
    parDistribDeriv (fun w => (fun x => L (f w x)).toDistribution)
    =
    fun w dw =>
      parDistribDeriv (fun w => (fun x => f w x).toDistribution) w dw |>.postComp (fun y ‚ä∏ L y) :=



Theorem: Function.Bijective.HAdd.hAdd.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x + y
  :=



Theorem: SciLean.semiAdjoint.SciLean.semiAdjoint.arg_y.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.semiAdjoint_rule
  (f : X ‚Üí Y) (a3 : W ‚Üí Y) (hf : HasSemiAdjoint K f) (ha3 : HasSemiAdjoint K a3)
  : semiAdjoint K (fun w => semiAdjoint K f (a3 w))
    =
    fun x =>
      let y := f x
      semiAdjoint K a3 y :=



Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ‚üøFD[K,n] Y)√óX) => fx.1 fx.2) :=



Theorem: Function.Bijective.HSub.hSub.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x - y
  :=



Theorem: SciLean.split_integral_over_set_of_ite
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem split_integral_over_set_of_ite (œÜ œà : X ‚Üí R) (f g : X ‚Üí Y) (A : Set X) :
    (‚à´' x in A, if œà x ‚â§ œÜ x then f x else g x)
    =
    (‚à´' x in {x' | 0 ‚â§ œÜ x' - œà x'} ‚à© A, f x)
    +
    (‚à´' x in {x' | 0 ‚â§ œà x' - œÜ x'} ‚à© A, g x) :=



Theorem: SciLean.Distribution.extAction_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD (A : Set X) (t e : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (iteD A t e).extAction œÜ L =
        t.extAction (fun x => if x ‚àà A then œÜ x else 0) L +
        e.extAction (fun x => if x ‚àâ A then œÜ x else 0) L :=



Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
    (c : ‚Ñï) (f : X ‚Üí Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c ‚Ä¢ f x) x :=



Theorem: SciLean.HasSemiAdjoint.HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule [ContinuousAdd Y]
    (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x + g x :=



Theorem: GetElem.getElem.arg_cont.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.revCDerivProj_rule
  {J ElemJ} [StructType Elem J ElemJ] [IndexType J] [LawfulIndexType J] [DecidableEq J]
  [‚àÄ j, SemiInnerProductSpace K (ElemJ j)] [SemiInnerProductSpaceStruct K Elem J ElemJ]
  (f : X ‚Üí Cont) (idx : Idx)
  (hf : HasAdjDiff K f)
  : revDerivProj K J (fun x => (f x)[idx])
    =
    fun x =>
      let ydf := revDerivProj K (Idx√óJ) f x
      (ydf.1[idx],
       fun j delem => ydf.2 (idx,j) delem) :=



Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule_at (x : X)
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x) :
    fwdDeriv K (fun x => ‚àë i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiff_rule
    (f g : X ‚Üí Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x + g x) :=



Theorem: SciLean.HSub.hSub.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a1.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => y - f x)
    =
    fun x dx =>
      - cderiv K f x dx :=



Theorem: Function.invFun.comp_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : Bijective f) (hg : Bijective g)
  : invFun (fun x => f (g x))
    =
    fun z =>
      let y := invFun f z
      let x := invFun g y
      x :=



Theorem: SciLean.HAdd.hAdd.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => y + f x)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: Function.Bijective.HSub.hSub.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a1.Bijective_rule
  [AddGroup Y]
   (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => y - f x
  :=



Theorem: Function.invFun.Equiv.invFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.invFun.arg_a0.invFun_rule (f : Y ‚âÉ Z) (g : X ‚Üí Z) (hf : Bijective g)
  : Function.invFun (fun x => f.invFun (g x))
    =
    fun z => Function.invFun g (f z) :=



Theorem: SciLean.scalar_max_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_one_zero  : max (1 : R) (0 : R) = 1 :=



Theorem: SciLean.Rand.pull_E_affine
File path: SciLean/Core/Rand/PushPullExpectation.lean
Theorem statement: theorem pull_E_affine (r : Rand X) (œÜ : X ‚Üí Y)
    (f : Y ‚Üí Z) (hf : IsAffineMap ‚Ñù f := by fun_prop) :
    (f (r.ùîº œÜ)) = r.ùîº (fun x => f (œÜ x)) :=



Theorem: Function.invFun.HAdd.hAdd.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x + y)
    =
    fun y' =>
      invFun f (y' - y)
  :=



Theorem: SciLean.odeSolve.arg_ft‚ÇÄtx‚ÇÄ.fwdDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_ft‚ÇÄtx‚ÇÄ.fwdDeriv_rule
  (f : W ‚Üí R ‚Üí X ‚Üí X) (t‚ÇÄ t : W ‚Üí R) (x‚ÇÄ : W ‚Üí X)
  (hf : CDifferentiable R (fun (w,t,x) => f w t x))
  (ht‚ÇÄ : CDifferentiable R t‚ÇÄ) (ht : CDifferentiable R t)
  (hx : CDifferentiable R x‚ÇÄ)
  : fwdDeriv R (fun w => odeSolve (f w) (t‚ÇÄ w) (t w) (x‚ÇÄ w))
    =
    fun w dw =>
      let t‚ÇÄdt‚ÇÄ := fwdDeriv R t‚ÇÄ w dw
      let tdt   := fwdDeriv R t‚ÇÄ w dw
      let x‚ÇÄdx‚ÇÄ := fwdDeriv R x‚ÇÄ w dw
      let Tf := fwdDeriv R (fun wkx : W√óR√óX => f wkx.1 wkx.2.1 wkx.2.2)

      let F := fun (t : R) (xdx : X√óX) =>
        let x  := xdx.1
        let dx := xdx.2
        Tf (w,t,x) (dw,t‚ÇÄdt‚ÇÄ.2,dx)

      let xdx := odeSolve F (t‚ÇÄdt‚ÇÄ.1) (tdt.1) x‚ÇÄdx‚ÇÄ

      (xdx.1, xdx.2 + tdt.2 ‚Ä¢ f w tdt.1 xdx.1) :=



Theorem: SciLean.HasSemiAdjoint.comp_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem comp_rule
    (f : Y ‚Üí Z) (g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K (fun x => f (g x)) :=



Theorem: SciLean.IsContinuousLinearMap.starRingEnd.arg_a.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem starRingEnd.arg_a.IsContinuousLinearMap_rule
  (f : X ‚Üí K) (_ : IsContinuousLinearMap K f)
  : IsContinuousLinearMap K fun x => conj (f x) :=



Theorem: Function.invFun.Neg.neg.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Neg.neg.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => - f x)
    =
    fun y =>
      invFun f (-y)
  :=



Theorem: SciLean.ArrayType.ext
File path: SciLean/Data/ArrayType/Basic.lean
Theorem statement: theorem ext (x y : Cont) : (‚àÄ i, x[i] = y[i]) ‚Üí x = y :=



Theorem: SciLean.semiAdjoint.Inner.inner.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ‚ü™f x, y‚ü´[K])
    =
    fun z => (conj z) ‚Ä¢ semiAdjoint K f y :=



Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ‚ü™f x, y‚ü´[K] :=



Theorem: SciLean.norm‚ÇÇ.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem norm‚ÇÇ.arg_x.ContCDiffAt_rule
    (f : X ‚Üí Y) (x : X)
    (hf : ContCDiffAt R n f x) (hx : f x‚â†0) :
    ContCDiffAt R n (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x :=



Theorem: SciLean.ite.arg_chte.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem ite.arg_chte.cderiv_rule
  (c : X ‚Üí Prop) [dec : ‚àÄ x, Decidable (c x)] (t e : X ‚Üí Y)
  (ht : ‚àÄ x ‚àà closure c, CDifferentiableAt K t x) (he : ‚àÄ x ‚àà (interior c)·∂ú, CDifferentiableAt K e x)
  (hc : (‚àÄ x, x ‚àà frontier c ‚Üí cderiv K t x = cderiv K e x))
  : cderiv K (fun x => ite (c x) (t x) (e x))
    =
    fun y =>
      ite (c y) (cderiv K t y) (cderiv K e y) :=



Theorem: SciLean.Diffeomorphism.comp_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : Diffeomorphism K f) (hg : Diffeomorphism K g)
  : Diffeomorphism K (fun x => f (g x))
  :=



Theorem: SciLean.Inner.inner.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Inner.inner.arg_a0a1.CDifferentiable_rule
    (f : X ‚Üí Y) (g : X ‚Üí Y)
    (hf : CDifferentiable R f) (hg : CDifferentiable R g) :
    CDifferentiable R (fun x => ‚ü™f x, g x‚ü´[R]) :=



Theorem: SciLean.cintegral.arg_f.cderiv_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.cderiv_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ y, CDifferentiable R (f ¬∑ y)) :
    (cderiv R  fun x => ‚à´' y, f x y ‚àÇŒº)
    =
    fun x dx => ‚à´' y, cderiv R (f ¬∑ y) x dx ‚àÇŒº :=



Theorem: SciLean.Distribution.iteD_same
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.iteD_same (A : Set X) (u : ùíü'(X,Y)) :
   iteD A u u = u :=



Theorem: SciLean.Rand.mean_add
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add  (x : Rand X) (x' : X) : x.mean + x' = (x  + x').mean :=



Theorem: SciLean.fderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/FDeriv.lean
Theorem statement: theorem fderiv.apply_rule (i : Œπ) :
    (fderiv K fun (x : (i : Œπ) ‚Üí E i) => x i)
    =
    fun _ => fun dx =>L[K] dx i :=



Theorem: SciLean.gaussian.arg_Œºx.cderiv_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_Œºx.cderiv_rule
    (Œº : W ‚Üí U) (œÉ : R) (x : W ‚Üí U)
    (hŒº : CDifferentiable R Œº) (hx : CDifferentiable R x) :
    fwdDeriv R (fun w => gaussian (Œº w) œÉ (x w))
    =
    fun w dw =>
      let ŒºdŒº := fwdDeriv R Œº w dw
      let xdx := fwdDeriv R x w dw
      let xdx' := œÉ‚Åª¬π ‚Ä¢ (xdx - ŒºdŒº)
      let g := gaussian ŒºdŒº.1 œÉ xdx.1
      (g, - ‚ü™xdx'.1, xdx'.2‚ü´ * g) :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.fromDual x) x :=



Theorem: SciLean.SciLean.cderiv.arg_dx.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.cderiv_rule_at
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : cderiv K (fun dx' => cderiv K f y (g dx')) dx
    =
    fun ddx =>
      let ddy := cderiv K g dx ddx
      cderiv K f y ddy :=



Theorem: SciLean.FwdFDeriv.FinType.sum.arg_f.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem FinType.sum.arg_f.fwdFDeriv_rule_at (x : X)
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, DifferentiableAt K (f ¬∑ i) x) :
    fwdFDeriv K (fun x => ‚àë i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdFDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=



Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule_at (x : X) (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) (hx : g x ‚â† 0) :
    (cderiv K fun x => f x / g x) x
    =
    let k := f x
    let k' := g x
    fun dx =>
      ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=



Theorem: SciLean.ContCDiffAt.apply_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.apply_rule
    (i : Œπ) (x) : ContCDiffAt K n (fun x : (i : Œπ) ‚Üí E i => x i) x :=



Theorem: SciLean.scalar_norm
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem scalar_norm {R} [RealScalar R] (r : R) : ‚Äñr‚Äñ‚ÇÇ[R] = Scalar.abs r :=



Theorem: SciLean.ContCDiffMap_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ‚üø[K,n] Y)√óX) => fx.1 fx.2) :=



Theorem: SciLean.cderiv.comp_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : (cderiv K fun x : X => f (g x))
    =
    fun x =>
      let y := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K f y dy
        dz :=



Theorem: SciLean.HasSemiAdjoint.Prod.fst.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.HasSemiAdjoint_rule
    (f : X ‚Üí Y√óZ) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).fst :=



Theorem: SciLean.Prod.fst.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.fst.arg_self.ContCDiffAt_rule (x : X)
    (f : X ‚Üí Y√óZ) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).1) x :=



Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (hf : Bijective f) (hf' : ‚àÄ x, f x ‚â† 0)
  : Bijective fun x => (f x)‚Åª¬π
  :=



Theorem: SciLean.DualBasis.dualProj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.cderiv.arg_f.IsSmoothLinearMap_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.arg_f.IsSmoothLinearMap_rule
    (f : X ‚Üí Y ‚Üí Z) (hf : CDifferentiable K (fun (x,y) => f x y)) (hf' : ‚àÄ y, IsLinearMap K (fun x => f x y)) :
    IsSmoothLinearMap K (fun x => cderiv K (f x ¬∑)) :=



Theorem: SciLean.DualBasis.dualProj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.Function.invFun.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_a1.cderiv_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Z)
  (hf : Diffeomorphism K f) (hg : CDifferentiable K g)
  : cderiv K (fun x => invFun f (g x))
    =
    fun x dx =>
      let z := g x
      let dz := cderiv K g x dx
      let y := invFun f z
      let dy := invFun (cderiv K f y) dz
      dy :=



Theorem: SciLean.cderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.apply_rule (i : Œπ) :
    (cderiv K fun (x : (i : Œπ) ‚Üí E i) => x i)
    =
    fun _ => fun dx => dx i :=



Theorem: LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple :
    semiAdjoint K (fun f : Idx ‚Üí Elem => Indexed.ofFn (C:=Cont) f)
    =
    fun (cont : Cont) idx => cont[idx] :=



Theorem: IsLinearMap.isLinearMap_pi
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_pi (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, IsLinearMap R (f ¬∑ i)) :
    IsLinearMap R (fun x i ‚Ü¶ f x i) :=



Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiableAt (f : W ‚Üí X ‚üøFD[K,‚àû] Y) (g : W ‚Üí X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=



Theorem: SciLean.HasSemiAdjoint.SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K fun x : X => f x i)
  : HasSemiAdjoint K fun x => ‚àë i, f x i :=



Theorem: SciLean.Prod.mk.arg_fstsnd.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.cderiv_rule_at (x : X)
    (g : X ‚Üí Y) (hg : CDifferentiableAt K g x)
    (f : X ‚Üí Z) (hf : CDifferentiableAt K f x) :
    cderiv K (fun x => (g x, f x)) x
    =
    fun dx =>
      (cderiv K g x dx, cderiv K f x dx) :=



Theorem: SciLean.Neg.neg.arg_a0.cderiv_rule'
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Neg.neg.arg_a0.cderiv_rule' (x : X) (f : X ‚Üí Y) :
    (cderiv K fun x => - f x) x
    =
    fun dx => - cderiv K f x dx :=



Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
    (c : ‚Ñï) (f : X ‚Üí Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c ‚Ä¢ f x :=



Theorem: SciLean.Rand.add_as_flip_E
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem add_as_flip_E {x y : X} (Œ∏ : R) (h : Œ∏ ‚àà Set.Ioo 0 1) :
    x + y = (flip Œ∏).ùîº (fun b => if b then Œ∏‚Åª¬π ‚Ä¢ x else (1-Œ∏)‚Åª¬π ‚Ä¢ y) :=



Theorem: SciLean.cderiv.let_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule
  (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K fun xy : X√óY => f xy.1 xy.2) (hg : CDifferentiable K g)
  : (cderiv K fun x : X =>
       let y := g x
       f x y)
    =
    fun x =>
      let y  := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K (fun xy : X√óY => f xy.1 xy.2) (x,y) (dx, dy)
        dz :=



Theorem: SciLean.Basis.proj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ‚Ñº i x) :=



Theorem: SciLean.Basis.proj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ‚Ñº i x) :=



Theorem: Function.invFun.Equiv.toFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.toFun.arg_a0.invFun_rule (f : Y ‚âÉ Z) (g : X ‚Üí Y) (hf : Bijective g)
  : Function.invFun (fun x => f (g x))
    =
    fun z => Function.invFun g (f.invFun z) :=



Theorem: SciLean.Distribution.smul_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.smul_extAction (r : R) (T : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W)  :
    (r ‚Ä¢ T).extAction œÜ L = r ‚Ä¢ T.extAction œÜ L :=



Theorem: SciLean.HasSemiAdjoint.SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (a0 : W ‚Üí Y) (ha0 : HasSemiAdjoint K a0)
  : HasSemiAdjoint K (fun w => semiAdjoint K f (a0 w)) :=



Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.HasAdjDiffAt_rule (x : X)
    (f : X ‚Üí Y) (hf : HasAdjDiffAt R f x) (hfz : f x ‚â† 0) :
    HasAdjDiffAt R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x :=



Theorem: SciLean.decompose_has_unique_solution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decompose_has_unique_solution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys ‚Üí Zs ‚Üí Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs ‚Üí Prop)       (Q‚ÇÅ : Ys ‚Üí Zs ‚Üí Prop) (Q‚ÇÇ : Ys ‚Üí Zs ‚Üí Prop) (equiv : ‚àÄ ys zs, (Q‚ÇÅ ys zs ‚àß Q‚ÇÇ ys zs) ‚Üî P (f ys zs))
  (unique : ‚àÄ ys, HasUniqueSolution (Q‚ÇÅ ys))
  : HasUniqueSolution P
    ‚Üî
    HasUniqueSolution fun ys => Q‚ÇÇ ys (solve zs, Q‚ÇÅ ys zs)
  :=



Theorem: SciLean.scalar_abs_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_one : Scalar.abs (1 : R) = 1 :=



Theorem: SciLean.Function.toDistribution_zero
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Function.toDistribution_zero  :
    Function.toDistribution (fun (_ : X) => 0) = (0 : ùíü'(X,Y)) :=



Theorem: SciLean.Distribution.fintype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.fintype_sum_extAction {I} [Fintype I] (T : I ‚Üí ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (‚àë i, T i).extAction œÜ L = ‚àë i, (T i).extAction œÜ L :=



Theorem: LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple (idx : Idx) :
    IsLinearMap R (fun ((cont,elem) : Cont√óElem) => Indexed.set cont idx elem) :=



Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí K) (y : Y) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x ‚Ä¢ y :=



Theorem: SciLean.HasSemiAdjoint.apply_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem apply_rule (i : Œπ) :
    HasSemiAdjoint K (fun x : (i : Œπ) ‚Üí E i => x i) :=



Theorem: Function.Bijective.Neg.neg.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Neg.neg.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => - f x
  :=



Theorem: SciLean.HSub.hSub.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a0.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => f x - y)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: SciLean.gaussian.arg_ŒºœÉx.CDifferentiableAt_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_ŒºœÉx.CDifferentiableAt_rule (w : W)
    (Œº : W ‚Üí U) (œÉ : W ‚Üí R) (x : W ‚Üí U)
    (hŒº : CDifferentiableAt R Œº w) (hœÉ : CDifferentiableAt R œÉ w) (hx : CDifferentiableAt R x w)
    (hœÉ' : œÉ w ‚â† 0) :
    CDifferentiableAt R (fun w => gaussian (Œº w) (œÉ w) (x w)) w :=



Theorem: SciLean.semiAdjoint.Inner.inner.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ‚ü™y, f x‚ü´[K])
    =
    fun z => z ‚Ä¢ semiAdjoint K f y :=



Theorem: SciLean.HasSemiAdjoint.Neg.neg.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.HasSemiAdjoint_rule
    (f : X ‚Üí Y) : HasSemiAdjoint K fun x => - f x :=



Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.HasSemiAdjoint_rule
  (y' : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => y' * f x :=



Theorem: SciLean.IsContinuousLinearMap.isContinuousLinearMap_differentiable
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem isContinuousLinearMap_differentiable (f : X ‚Üí Y) (hf : IsContinuousLinearMap K f) :
    Differentiable K f :=



Theorem: SciLean.HasSemiAdjoint.HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
    (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x - g x :=



Theorem: SciLean.IndexType.sum.arg_f.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiableAt_rule
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (fun x => f x i) x)
  : CDifferentiableAt K (fun x => ‚àë i, f x i) x :=



Theorem: SciLean.ContCDiffAt.const_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.const_rule (y : Y) (x : X) :
    ContCDiffAt K n (fun _ : X => y) x :=



Theorem: SciLean.Rand.bind_E
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_E (r : Rand X) (f : X ‚Üí Rand Y) (œÜ : Y ‚Üí Z) :
    (r >>= f).ùîº œÜ = r.ùîº (fun x' => (f x').ùîº œÜ) :=



Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective (fun x => f x * y)
  :=



Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.semiAdjoint_rule
  (c : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x * c)
    =
    fun y => conj c ‚Ä¢ semiAdjoint K (fun x => f x) y :=



Theorem: SciLean.Prod.mk.arg_fstsnd.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.ContCDiffAt_rule (x : X)
  (g : X ‚Üí Y) (hg : ContCDiffAt K n g x)
  (f : X ‚Üí Z) (hf : ContCDiffAt K n f x)
  : ContCDiffAt K n (fun x => (g x, f x)) x
  :=



Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_group
  [Group Y]
  (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => y * f x)
  :=



Theorem: SciLean.semiAdjoint.HDiv.hDiv.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.semiAdjoint_rule
  (f : X ‚Üí K) (c : K)
  (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x / c)
    =
    fun y => (conj c)‚Åª¬π ‚Ä¢ semiAdjoint K f y :=



Theorem: SciLean.Rand.flip.integral
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.integral (Œ∏ : R) (f : Bool ‚Üí X) :
    ‚à´' x, f x ‚àÇ(flip Œ∏).‚Ñô = Œ∏ ‚Ä¢ f true + (1-Œ∏) ‚Ä¢ f false :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.toDual x) x :=



Theorem: SciLean.cintegral.arg_f.IsLinearMap_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.IsLinearMap_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ y, IsLinearMap R (f ¬∑ y)) :
    IsLinearMap R (fun x => ‚à´' y, f x y ‚àÇŒº) :=



Theorem: SciLean.Neg.neg.arg_a0.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiff_rule
    (f : X ‚Üí Y) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => - f x) :=



Theorem: Set.HAdd.hAdd.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x + x') (Ioo a b)
    =
    Ioo (a - x') (b - x') :=



Theorem: SciLean.HAdd.hAdd.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => f x + y)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: SciLean.norm2_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm2_scalar {R} [RealScalar R] (x : R) :
  ‚Äñx‚Äñ‚ÇÇ¬≤[R] = x^2 :=



Theorem: IndexType.sum.arg_f.revDerivProj_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProj_rule [DecidableEq Œπ]
    (f : X ‚Üí Œπ ‚Üí Y') (hf : ‚àÄ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProj K Yi (fun x => ‚àë i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Œπ√óYi) f x
      (‚àë i, ydf.1 i,
       fun j dy =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => ydf.2 (i,j) dy dx) 0) :=



Theorem: SciLean.parDistribDeriv.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem parDistribDeriv.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    parDistribDeriv (fun x => f (g x))
    =
    fun x dx =>
      let ydy := fwdDeriv R g x dx
      parDistribDeriv f ydy.1 ydy.2 :=



Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.semiAdjoint.starRingEnd.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a0.semiAdjoint_rule
  (f : X ‚Üí K)
  : semiAdjoint K (fun x => conj (f x))
    =
    fun z => semiAdjoint K f z :=



Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ‚üøFD[K,‚àû] Y)√óX) => fx.1 fx.2) :=



Theorem: SciLean.cderiv.id_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.id_rule :
    (cderiv K fun x : X => x) = fun _ => fun dx => dx :=



Theorem: SciLean.ContCDiffMapFD_eta
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eta (f : X ‚üøFD[K,n] Y) : (fun x ‚üøFD[K,n] f x) = f :=



Theorem: SciLean.revDerivUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X ‚Üí (i : I) ‚Üí EI i) (hf : ‚àÄ i, HasAdjDiff K (f ¬∑ i)) :
    (revDerivUpdate K fun (x : X) (i : I) => f x i)
    =
    fun x =>
      let xdf := fun i => revDerivUpdate K (f ¬∑ i) x
      (fun i => (xdf i).1,
       fun dy dx =>
         Fold.fold (IndexType.univ I) (fun dx i => (xdf i).2 (dy i) dx) dx) :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.CDifferentiable_rule
  (f g : X ‚Üí Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x + g x)  :=



Theorem: Function.invFun.let_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem let_rule
  (f : X‚ÇÇ ‚Üí Y ‚Üí Z) (g : X‚ÇÅ ‚Üí Y) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective (fun xy : X‚ÇÇ√óY => f xy.1 xy.2)) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : invFun (fun x => let y := g (p‚ÇÅ x); f (p‚ÇÇ x) y)
    =
    fun z =>
      let x‚ÇÇy := invFun (fun xy : X‚ÇÇ√óY => f xy.1 xy.2) z
      let x‚ÇÅ := invFun g x‚ÇÇy.2
      let x := invFun (fun x => (p‚ÇÅ x, p‚ÇÇ x)) (x‚ÇÅ,x‚ÇÇy.1)
      x :=



Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a1.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a1.IsContinuousLinearMap_rule
  (f : X ‚Üí Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ y (f x) :=



Theorem: Set.HAdd.hAdd.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' + x) (Ioo a b)
    =
    Ioo (a - x') (b - x') :=



Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_group
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_group
  [Group Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => (f x)‚Åª¬π)
    =
    fun y =>
      invFun f (y‚Åª¬π)
  :=



Theorem: SciLean.scalar_min_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_one_zero  : min (1 : R) (0 : R) = 0 :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.fromDual x) :=



Theorem: IsAffineMap.IsAffineMap_comp
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_comp {f : Y ‚Üí Z} {g : X ‚Üí Y}
    (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R (fun x ‚Ü¶ f (g x)) :=



Theorem: SciLean.Distribution.extAction_iteD'
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD' (A B : Set X) (t e : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    ((iteD A t e).restrict B).extAction œÜ L =
        (t.restrict B).extAction (fun x => if x ‚àà A then œÜ x else 0) L +
        (e.restrict B).extAction (fun x => if x ‚àâ A then œÜ x else 0) L :=



Theorem: SciLean.HMul.hMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HMul.hMul.arg_a0a1.cderiv_rule_at (x : X) (f g : X ‚Üí K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x * g x) x
    =
    let fx := f x
    let gx := g x
    fun dx =>
      (cderiv K g x dx) * fx + (cderiv K f x dx) * gx :=



Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule
  (f : X‚ÇÅ ‚Üí Y) (g : X‚ÇÇ ‚Üí Z) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : Bijective (fun x : X => (f (p‚ÇÅ x), g (p‚ÇÇ x)))
  :=



Theorem: SciLean.scalar_sqrt_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_one  : Scalar.sqrt (1 : R) = 1 :=



Theorem: SciLean.Basis.proj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ‚Ñº i x) x :=



Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ‚Ñº' i x) x :=



Theorem: SciLean.cintegral.arg_f.CDifferentiable_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.CDifferentiable_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) :
    CDifferentiable R (fun x => ‚à´' y, f x y ‚àÇŒº) :=



Theorem: Function.invFun.Prod.mk.arg_fstsnd.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.invFun_rule
  (f : X‚ÇÅ ‚Üí Y) (g : X‚ÇÇ ‚Üí Z) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : invFun (fun x : X => (f (p‚ÇÅ x), g (p‚ÇÇ x)))
    =
    fun yz =>
      let x‚ÇÅ := invFun f yz.1
      let x‚ÇÇ := invFun g yz.2
      let x  := invFun (fun x => (p‚ÇÅ x, p‚ÇÇ x)) (x‚ÇÅ,x‚ÇÇ)
      x :=



Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.CDifferentiable_rule
  (f : X ‚Üí Y) (hf : CDifferentiable R f) (hx : f x‚â†0)
  : CDifferentiable R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) :=



Theorem: SciLean.Rand.flip.pdf
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf (x : R) :
    (flip x).pdf R .count
    =
    fun b =>
      let x := (x ‚äî 0) ‚äì 1
      if b then x else (1-x) :=



Theorem: IsLinearMap.sum_push
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_push
  {f : X ‚Üí Y} (hf : IsLinearMap K f)
  (Œπ : Type) [IndexType.{_,u} Œπ] [IndexType.{_,v} Œπ] (x : Œπ ‚Üí X)
  : (‚àë i, f (x i)) = f (‚àë i, x i) :=



Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_int
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_int
    (c : ‚Ñ§) (f : X ‚Üí Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c ‚Ä¢ f x :=



Theorem: SciLean.parametric_inverse_affine
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine {n} (f : X ‚Üí R) (c : R) (hf : IsAffineMap R f)
    (hn : n + 1 = card Œπ := by first | assumption | infer_var) :
    let u  := ‚àá f 0
    let dec := planeDecomposition (R:=R) u hn
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‚Äñu‚Äñ‚ÇÇ)
      (dom := fun _ => ‚ä§) :=



Theorem: SciLean.HSub.hSub.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.CDifferentiable_rule
  (f g : X ‚Üí Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x - g x)  :=



Theorem: SciLean.norm‚ÇÇ_squared
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_squared {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‚Äñx‚Äñ‚ÇÇ[K] ^ (2:K) = ‚Äñx‚Äñ‚ÇÇ¬≤[K] :=



Theorem: SciLean.Function.invFun.arg_f_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f_a1.cderiv_rule
  (f : X ‚Üí Y ‚Üí Z)
  (hf : ‚àÄ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X√óY => f xy.1 xy.2))
  : cderiv K (fun x z => invFun (f x) z)
    =
    fun x dx z =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=



Theorem: SciLean.parDistribFwdDeriv.bind_rule
File path: SciLean/Core/Distribution/ParametricDistribFwdDeriv.lean
Theorem statement: theorem bind_rule
    (f : X ‚Üí Y ‚Üí ùíü'(Z,V)) (g : X ‚Üí ùíü'(Y,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    parDistribFwdDeriv (fun x => (g x).bind (f x) L)
    =
    fun x dx =>
      let ydy := parDistribFwdDeriv g x dx  let zdz := fun y => parDistribFwdDeriv (f ¬∑ y) x dx ydy.bind zdz (fun (r,dr) ‚ä∏ fun (s,ds) ‚ä∏ (L r s, L r ds + L dr s)) :=



Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i)) :
    fwdDeriv K (fun x => ‚àë i, f x i)
    =
    fun x dx =>
      let ydy := fun i => fwdDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=



Theorem: SciLean.HasSemiAdjoint.pi_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem pi_rule
    (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i)) :
    HasSemiAdjoint K (fun x i => f x i) :=



Theorem: LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
    (cont : X ‚Üí Cont) (idx : Idx) (elem : X ‚Üí Elem)
    (hcont : HasAdjDiff K cont) (helem : HasAdjDiff K elem) :
    revDerivProj K Idx (fun x => Indexed.set (cont x) idx (elem x))
    =
    fun x =>
      let cdc := revDerivProj K Idx cont x
      let ede := revDeriv K elem x
      (Indexed.set cdc.1 idx ede.1,
       fun i delem =>
         if i = idx then
           ede.2 delem
         else
           cdc.2 i delem) :=



Theorem: SciLean.cderiv.pi_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i))
  : (cderiv K fun (x : X) (i : Œπ) => f x i)
    =
    fun x => fun dx => fun i =>
      cderiv K (f ¬∑ i) x dx
  :=



Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_field
  [Field R] [MulAction R Y]
  (r : R) (f : X ‚Üí Y) (hf : Bijective f) (hr : r ‚â† 0)
  : Bijective (fun x => r ‚Ä¢ f x)
  :=



Theorem: SciLean.inner_basis_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_basis_dualProj (i : Œπ) (x : X)
  : ‚ü™x, ‚Öá i‚ü´[K] = ‚Ñº' i x :=



Theorem: SciLean.inner_proj_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_proj_dualProj {Œπ K X} {_ : IndexType Œπ} [LawfulIndexType Œπ] [DecidableEq Œπ] [RCLike K] [FinVec Œπ K X] (x y : X)
  : ‚ü™x, y‚ü´[K] = ‚àë i, ‚Ñº i x * ‚Ñº' i y :=



Theorem: SciLean.Rand.mean_add'
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add' (x : Rand X) (x' : X) : x' + x.mean = (x' +  x).mean :=



Theorem: GetElem.getElem.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.semiAdjoint_rule_simple (idx : Idx) :
    semiAdjoint K (fun cont : Cont => cont[idx])
    =
    fun elem => oneHot (X:=Cont) idx elem :=



Theorem: SciLean.Rand.bind_pdf
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_pdf (ŒΩ : Measure Y) (x : Rand X) (f : X ‚Üí Rand Y) :
    (x >>= f).pdf R ŒΩ = fun y => ‚à´ x', ((f x').pdf R ŒΩ y) ‚àÇx.‚Ñô :=



Theorem: SciLean.ContCDiffAt.pi_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.pi_rule (x : X)
    (f : X ‚Üí (i : Œπ) ‚Üí E i)
    (hf : ‚àÄ i, ContCDiffAt K n (f ¬∑ i) x) :
    ContCDiffAt K n (fun x i => f x i) x :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X ‚Üí Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x + g x) x :=



Theorem: SciLean.FwdFDeriv.HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at (x : X)
    (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) (hx : g x ‚â† 0) :
    (fwdFDeriv K fun x => f x / g x) x
    =
    fun dx =>
      let ydy := (fwdFDeriv K f x dx)
      let zdz := (fwdFDeriv K g x dx)
      (ydy.1 / zdz.1, (ydy.2 * zdz.1 - ydy.1 * zdz.2) / zdz.1^2) :=



Theorem: SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.postComp.arg_T.IsSmoothLinarMap_rule (T : W ‚Üí ùíü'(X,Y)) (f : Y ‚ä∏ Z)
    (hT : IsSmoothLinearMap R T) :
    IsSmoothLinearMap R (fun w => (T w).postComp f) :=



Theorem: SciLean.ContCDiffMap_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ‚üø[K,‚àû] Y)√óX) => fx.1 fx.2) :=



Theorem: Function.invFun.HSub.hSub.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x - y)
    =
    fun y' =>
      invFun f (y' + y)
  :=



Theorem: SciLean.DistribDiffrentiable.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem DistribDiffrentiable.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    DistribDifferentiable (fun x => f (g x)) :=



Theorem: SciLean.Prod.snd.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiffAt_rule (x : X)
    (f : X ‚Üí Y√óZ) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).2) x :=



Theorem: SciLean.BasisDuality.toDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.inner_dualBasis_proj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_proj  (i : Œπ) (x : X)
  : ‚ü™x, ‚Öá' i‚ü´[K] = ‚Ñº i x :=



Theorem: SciLean.semiAdjoint.let_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem let_rule
    (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y)
    (hf : HasSemiAdjoint K ‚Üøf) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => let y := g x; f x y)
    =
    fun z =>
      let xy := semiAdjoint K (fun xy : X√óY => f xy.1 xy.2) z
      let x' := semiAdjoint K g xy.2
      xy.1 + x' :=



Theorem: SciLean.jacobian.comp_rule
File path: SciLean/Core/Integral/Jacobian.lean
Theorem statement: theorem jacobian.comp_rule (f : U ‚Üí V) (g : U ‚Üí U)
    (hf : HasAdjDiff R f) (hg : HasAdjDiff R g) :
    jacobian R (fun x => f (g x))
    =
    fun x => jacobian R f x * jacobian R g x :=



Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (y : Y)
  (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => f x / y) :=



Theorem: SciLean.CDifferentiable.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.apply_rule (i : Œπ)
  : CDifferentiable K (fun x : (i : Œπ) ‚Üí E i => x i) :=



Theorem: IndexType.sum.arg_f.revDerivProjUpdate_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProjUpdate_rule [DecidableEq Œπ]
    (f : X ‚Üí Œπ ‚Üí Y') (hf : ‚àÄ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProjUpdate K Yi (fun x => ‚àë i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Œπ√óYi) f x
      (‚àë i, ydf.1 i,
       fun j dy dx =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => ydf.2 (i,j) dy dx) dx) :=



Theorem: SciLean.semiAdjoint.Prod.mk.arg_fstsnd.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.semiAdjoint_rule
  (g : X ‚Üí Y) (f : X ‚Üí Z)
  (hg : HasSemiAdjoint K g) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (g x, f x))
    =
    fun yz =>
      let x‚ÇÅ := semiAdjoint K g yz.1
      let x‚ÇÇ := semiAdjoint K f yz.2
      x‚ÇÅ + x‚ÇÇ :=



Theorem: SciLean.Prod.mk.arg_fstsnd.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.CDifferentiableAt_rule
  (x : X)
  (g : X ‚Üí Y) (hg : CDifferentiableAt K g x)
  (f : X ‚Üí Z) (hf : CDifferentiableAt K f x)
  : CDifferentiableAt K (fun x => (g x, f x)) x
  :=



Theorem: SciLean.BasisDuality.toDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.CDifferentiable.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f (g x))
  :=



Theorem: SciLean.Distribution.indextype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.indextype_sum_extAction {I} [IndexType I] (T : I ‚Üí ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (‚àë i, T i).extAction œÜ L = ‚àë i, (T i).extAction œÜ L :=



Theorem: SciLean.semiAdjoint.const_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem const_rule : semiAdjoint K (fun (_ : X) => (0 : Y)) = fun x => 0 :=



Theorem: Function.Bijective.HVAdd.hVAdd.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HVAdd.hVAdd.arg_a1.Bijective_rule_group
  [AddGroup G] [AddAction G Y]
  (g : G) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => g +·µ• f x)
  :=



Theorem: SciLean.cderiv.pi_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule_at
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : (cderiv K fun (x : X) (i : Œπ) => f x i) x
    =
    fun dx => fun i =>
      cderiv K (f ¬∑ i) x dx
  :=



Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.semiAdjoint_rule
  (c : K) (g : X ‚Üí Y) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => c ‚Ä¢ g x)
    =
    fun y => (conj c) ‚Ä¢ semiAdjoint K g y :=



Theorem: SciLean.Bind.bind.arg_fx.DistribDifferentiable_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem Bind.bind.arg_fx.DistribDifferentiable_rule
    (f : X ‚Üí Y ‚Üí ùíü'(Z,V)) (g : X ‚Üí ùíü'(Y,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun x => (g x).bind (f x) L) :=



Theorem: SciLean.decomposeSolution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decomposeSolution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys ‚Üí Zs ‚Üí Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs ‚Üí Prop)       (Q‚ÇÅ : Ys ‚Üí Zs ‚Üí Prop) (Q‚ÇÇ : Ys ‚Üí Zs ‚Üí Prop) (equiv : ‚àÄ ys zs, (Q‚ÇÅ ys zs ‚àß Q‚ÇÇ ys zs) ‚Üî P (f ys zs))
  (unique : ‚àÄ ys, HasUniqueSolution (Q‚ÇÅ ys))
  : (solve xs, P xs)
    =
    let zs' := fun ys => (solve zs, Q‚ÇÅ ys zs)
    let ys  := solve ys, Q‚ÇÇ ys (zs' ys)
    let zs  := zs' ys
    f ys zs
  :=



Theorem: SciLean.CDifferentiableAt.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (x : X)
  (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : CDifferentiableAt K (fun x i => f x i) x
  :=



Theorem: SciLean.inner_dualBasis_basis
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_basis  (i j : Œπ)
  : ‚ü™‚Öá'[X] i, ‚Öá j‚ü´[K] = if i=j then 1 else 0 :=



Theorem: SciLean.Inner.inner.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Inner.inner.arg_a0a1.ContCDiffAt_rule
    (f : X ‚Üí Y) (g : X ‚Üí Y) (x : X)
    (hf : ContCDiffAt R n f x) (hg : ContCDiffAt R n g x) :
    ContCDiffAt R n (fun x => ‚ü™f x, g x‚ü´[R]) x :=



Theorem: Function.invFun.HAdd.hAdd.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.invFun_rule
  [AddGroup Y]
  (y : Y)  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => y + f x)
    =
    fun y' =>
      invFun f (-y + y')
  :=



Theorem: SciLean.Function.invFun.arg_f.cderiv_rule'
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f.cderiv_rule'
  (f : X ‚Üí Y ‚Üí Z) (z : Z)
  (hf : ‚àÄ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X√óY => f xy.1 xy.2))
  : cderiv K (fun x => invFun (f x) z)
    =
    fun x dx =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=



Theorem: SciLean.Prod.fst.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.fst.arg_self.CDifferentiable_rule
  (f : X ‚Üí Y√óZ) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).1)  :=



Theorem: IsAffineMap.IsAffineMap_pi
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_pi (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, IsAffineMap R (f ¬∑ i)) :
    IsAffineMap R (fun x i ‚Ü¶ f x i) :=



Theorem: SciLean.BasisDuality.toDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.norm‚ÇÇ_prod
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_prod {R K X Y} [Scalar R K] [AddCommMonoid K] [Inner K X] [Inner K Y] (x : X) (y : Y) :
  ‚Äñ(x,y)‚Äñ‚ÇÇ[K] = Scalar.sqrt (‚Äñx‚Äñ‚ÇÇ¬≤[K] + ‚Äñy‚Äñ‚ÇÇ¬≤[K]) :=



Theorem: SciLean.Inner.inner.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Inner.inner.arg_a0a1.cderiv_rule_at
  (f : X ‚Üí Y) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt R f x) (hg : CDifferentiableAt R g x)
  : cderiv R (fun x => ‚ü™f x, g x‚ü´[R]) x
    =
    fun dx =>
      let y‚ÇÅ := f x
      let dy‚ÇÅ := cderiv R f x dx
      let y‚ÇÇ := g x
      let dy‚ÇÇ := cderiv R g x dx
      ‚ü™dy‚ÇÅ, y‚ÇÇ‚ü´[R] + ‚ü™y‚ÇÅ, dy‚ÇÇ‚ü´[R] :=



Theorem: SciLean.Measure.prod_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_restrict {X Y} [MeasurableSpace X] [MeasurableSpace Y]
    (Œº : Measure X) (ŒΩ : Measure Y) (A : Set X) (B : Set Y) :
    (Measure.prod (Œº.restrict A) (ŒΩ.restrict B)) = (Œº.prod ŒΩ).restrict (A √óÀ¢ B) :=



Theorem: Function.invFun.HSub.hSub.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a1.invFun_rule
  [AddGroup Y]
   (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => y - f x )
    =
    fun y' =>
      invFun f (y - y')
  :=



Theorem: Function.Bijective.HAdd.hAdd.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.Bijective_rule
  [AddGroup Y]
  (y : Y)  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => y + f x
  :=



Theorem: SciLean.DualBasis.dualProj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.revDerivProjUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasAdjDiff K (f ¬∑ i)) :
    (revDerivProjUpdate K Unit fun (x : X) (i : Œπ) => f x i)
    =
    fun x =>
      let ydf := fun i => revDerivUpdate K (f ¬∑ i) x
      (fun i => (ydf i).1,
       fun _ df dx =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => (ydf i).2 (df i) dx) dx) :=



Theorem: SciLean.Distribution.neg_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.neg_extAction (T : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (- T).extAction œÜ L = - T.extAction œÜ L :=



Theorem: SciLean.CDifferentiableAt.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.apply_rule
  (i : Œπ) (x)
  : CDifferentiableAt K (fun x : (i : Œπ) ‚Üí E i => x i) x :=



Theorem: SciLean.semiAdjoint.Prod.snd.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.semiAdjoint_rule
  (f : X ‚Üí Y√óZ) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).2)
    =
    (fun z => semiAdjoint K f (0,z)) :=



Theorem: SciLean.norm‚ÇÇ_squared_nat
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_squared_nat {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‚Äñx‚Äñ‚ÇÇ[K] ^ 2 = ‚Äñx‚Äñ‚ÇÇ¬≤[K] :=



Theorem: SciLean.cderiv.let_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule_at
  (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K ‚Üøf (x, g x))
  (hg : CDifferentiableAt K g x)
  : (cderiv K
      fun x : X =>
        let y := g x
        f x y) x
    =
    let y  := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K (fun xy : X√óY => f xy.1 xy.2) (x,y) (dx, dy)
      dz :=



Theorem: SciLean.CDifferentiableAt.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.const_rule (y : Y) (x : X)
  : CDifferentiableAt K (fun _ : X => y) x
  :=



Theorem: SciLean.CDifferentiable.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i)
  (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i))
  : CDifferentiable K (fun x i => f x i)
  :=



Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (y' : Y) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x ‚Ä¢ y')
    =
    fun y => semiAdjoint K (fun x => f x) ‚ü™y',y‚ü´[K] :=



Theorem: SciLean.semiAdjoint.id_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem id_rule : semiAdjoint K (fun (x : X) => x) = fun x => x :=



Theorem: SciLean.Rand.swap_bind
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem swap_bind (f : X ‚Üí Y ‚Üí Z) (x : Rand X) (y : Rand Y) :
    (do let x' ‚Üê x; let y' ‚Üê y; pure (f x' y'))
    =
    (do let y' ‚Üê y; let x' ‚Üê x; pure (f x' y')) :=



Theorem: SciLean.Measure.restrict_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.restrict_restrict {X} [MeasurableSpace X] (Œº : Measure X) (A B : Set X) :
    (Œº.restrict A).restrict B = Œº.restrict (A ‚à© B) :=



Theorem: SciLean.Distribution.sub_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.sub_extAction (T T' : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (T - T').extAction œÜ L = T.extAction œÜ L - T'.extAction œÜ L :=



Theorem: SciLean.scalar_abs_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_zero : Scalar.abs (0 : R) = 0 :=



Theorem: Set.HSub.hSub.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x - x') (Ioo a b)
    =
    Ioo (a + x') (b + x') :=



Theorem: SciLean.cderiv.comp_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule_at
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : (cderiv K fun x : X => f (g x)) x
    =
    let y := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K f y dy
      dz :=



Theorem: SciLean.SmoothLinearMap.indextype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.indextype_sum_apply {I} [IndexType I] (f : I ‚Üí X‚ä∏[K] Y) (x : X) :
    (‚àë i, f i) x = ‚àë i, f i x  :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.semiAdjoint.HAdd.hAdd.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.semiAdjoint_rule
  (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x + g x)
    =
    fun y =>
      let x‚ÇÅ := semiAdjoint K f y
      let x‚ÇÇ := semiAdjoint K g y
      x‚ÇÅ + x‚ÇÇ :=



Theorem: IndexType.sum.arg_f.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsAffineMap_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, IsAffineMap R (f ¬∑ i))
  : IsAffineMap R fun x => ‚àë i, f x i :=



Theorem: SciLean.CDifferentiable.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.const_rule (y : Y)
  : CDifferentiable K (fun _ : X => y)
  :=



Theorem: SciLean.SmoothLinearMap.apply_zero
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.apply_zero (f : X ‚ä∏[K] Y) : f 0 = 0 :=



Theorem: SciLean.cderiv.const_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.const_rule (x : X) :
    (cderiv K fun _ : Y => x) = fun _ => fun dx => 0 :=



Theorem: SciLean.odeSolve.arg_x‚ÇÄ.semiAdjoint_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x‚ÇÄ.semiAdjoint_rule
  (f : R ‚Üí X ‚Üí X) (t‚ÇÄ t : R) (x‚ÇÄ : W ‚Üí X)
  (hf : ‚àÄ t, HasSemiAdjoint R (f t)) (hx‚ÇÄ : HasSemiAdjoint R x‚ÇÄ)
  : semiAdjoint R (fun w => odeSolve f t‚ÇÄ t (x‚ÇÄ w))
    =
    fun x‚ÇÄ' =>
      let f' := (fun s y => - semiAdjoint R (f s) y)
      let y := odeSolve f' t t‚ÇÄ x‚ÇÄ'
      semiAdjoint R x‚ÇÄ y :=



Theorem: SciLean.IndexType.sum.arg_f.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem IndexType.sum.arg_f.ContCDiffAt_rule
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, ContCDiffAt K n (fun x => f x i) x)
  : ContCDiffAt K n (fun x => ‚àë i, f x i) x :=



Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.cderiv_rule_at
  (f : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt R f x) (hx : f x‚â†0)
  : cderiv R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x
    =
    fun dx =>
      let y := f x
      let dy := cderiv R f x dx
      ‚Äñy‚Äñ‚ÇÇ[R]‚Åª¬π * ‚ü™dy,y‚ü´[R] :=



Theorem: SciLean.HasSemiAdjoint.starRingEnd.arg_a.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a.HasSemiAdjoint_rule
  (f : X ‚Üí K) (_ : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => conj (f x) :=



Theorem: SciLean.scalar_abs_neg
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_neg (r : R) : Scalar.abs (- r) = Scalar.abs r :=



Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_group
  [Group G] [MulAction G Y]
  (g : G) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => g ‚Ä¢ f x)
  :=



Theorem: SciLean.Neg.neg.arg_a0.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiffAt_rule
    (x : X) (f : X ‚Üí Y) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => - f x) x :=



Theorem: SciLean.explicitSymplecticEuler_eq_implicitSymplecticEulerV1
File path: SciLean/Modules/DifferentialEquations/OdeSolvers/Solvers.lean
Theorem statement: theorem explicitSymplecticEuler_eq_implicitSymplecticEulerV1
  (T V : X ‚Üí R)
  (hT : HasAdjDiff R T) (hV : HasAdjDiff R V)
  : explicitSymplecticEuler (fun q p => T p + V q)
    =
    implicitSymplecticEulerV1 (fun q p => T p + V q) :=



Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ‚ü™y, f x‚ü´[K] :=



Theorem: IndexType.sum.arg_f.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsLinearMap_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, IsLinearMap R (f ¬∑ i))
  : IsLinearMap R fun x => ‚àë i, f x i :=



Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => f x * y)
  :=



Theorem: SciLean.Basis.proj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ‚Ñº i x) :=



Theorem: SciLean.semiAdjoint.Finset.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.semiAdjoint_rule {Œπ : Type _} [Fintype Œπ]
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i))
  : semiAdjoint K (fun x => ‚àë i, f x i)
    =
    (fun y => ‚àë i, semiAdjoint K (f ¬∑ i) y) :=



Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_field
  [Field Y]
  (y : Y) (f : X ‚Üí Y) (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => y * f x)
  :=



Theorem: SciLean.Rand.uniformI.pdf
File path: SciLean/Core/Rand/Distributions/UniformI.lean
Theorem statement: theorem uniformI.pdf :
    (uniformI R).pdf R volume
    =
    fun x => if 0 < x ‚àß x < 1 then 1 else 0 :=



Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a0.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a0.IsContinuousLinearMap_rule
  (f : X ‚Üí Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ (f x) y :=



Theorem: SciLean.parametric_inverse_affine'
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine' (f : X ‚Üí R) (c : R) (hf : IsAffineMap R f) :
    let u  := ‚àá f 0
    let dec := planeDecomposition (n:=card Œπ - 1) (R:=R) u sorry_proof
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‚Äñu‚Äñ‚ÇÇ)
      (dom := fun _ => ‚ä§) :=



Theorem: SciLean.odeSolve.arg_x‚ÇÄ.revCDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x‚ÇÄ.revCDeriv_rule
  (f : R ‚Üí X ‚Üí X) (t‚ÇÄ t : R) (x‚ÇÄ : W ‚Üí X)
  (hf : HasAdjDiff R (fun (t,x) => f t x))
  (hx : HasAdjDiff R x‚ÇÄ)
  : revDeriv R (fun w => odeSolve f t‚ÇÄ t (x‚ÇÄ w))
    =
    fun w =>
      let x‚ÇÄdx‚ÇÄ := revDeriv R x‚ÇÄ w
      let x := fun s => odeSolve f t‚ÇÄ s x‚ÇÄdx‚ÇÄ.1
      let dfdx := fun s dx' => - gradient R (fun x' => f s x') (x s) dx'
      (x t,
       fun dx =>
         let dx := odeSolve dfdx t‚ÇÄ t dx
         x‚ÇÄdx‚ÇÄ.2 dx) :=



Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (y : Y)
  (hf : Bijective f)
  : Bijective (fun x => f x / y) :=



Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X ‚Üí Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x - g x) x :=



Theorem: SciLean.semiAdjoint.Neg.neg.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.semiAdjoint_rule
  (f : X ‚Üí Y)
  : semiAdjoint K (fun x => - f x)
    =
    fun y => - semiAdjoint K f y :=



Theorem: SciLean.ContCDiffMap_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiable (f : W ‚Üí X ‚üø[K,‚àû] Y) (g : W ‚Üí X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=



Theorem: Set.HSub.hSub.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' - x) (Ioo a b)
    =
    Ioo (x' - b) (x' - a) :=



Theorem: SciLean.Prod.snd.arg_self.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiff_rule
    (f : X ‚Üí Y√óZ) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => (f x).2) :=



Theorem: SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule (w : W)
    (f : X ‚Üí Y) (a0 : W ‚Üí Y) (hf : CDifferentiable K f) (ha0 : HasAdjDiffAt K a0 w) :
    HasAdjDiffAt K (fun w => semiAdjoint K f (a0 w)) w :=



Theorem: SciLean.approx_consistency
File path: SciLean/Core/Approx/ApproxSolution.lean
Theorem statement: theorem approx_consistency {N} {lN : Filter N} [T2Space Œ±] {spec : Œ± ‚Üí Prop}
  (approx : ApproxSolution lN spec)
  : ‚àÄ a, a = (limit n ‚àà lN, approx.val n) ‚Üí spec a :=



Theorem: SciLean.Rand.flip.pdf_wrt_flip
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf_wrt_flip (Œ∏ Œ∏' : R) :
    (flip Œ∏).pdf R (flip Œ∏').‚Ñô
    =
    fun b => if b then Œ∏ / Œ∏' else (1-Œ∏) / (1-Œ∏') :=



Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_field
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_field
  [Field Y]
  (f : X ‚Üí Y) (hf : Bijective f) (hf' : ‚àÄ x, f x ‚â† 0)
  : invFun (fun x => (f x)‚Åª¬π)
    =
    fun y =>
      invFun f (y‚Åª¬π)
  :=



Theorem: SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSMul.hSMul.arg_a0a1.cderiv_rule_at (x : X) (f : X ‚Üí K) (g : X ‚Üí Y)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x ‚Ä¢ g x) x
    =
    let k := f x
    let y := g x
    fun dx =>
      k ‚Ä¢ (cderiv K g x dx) + (cderiv K f x dx) ‚Ä¢ y :=



Theorem: SciLean.Prod.snd.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.snd.arg_self.CDifferentiable_rule
  (f : X ‚Üí Y√óZ) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).2)  :=



Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => (f x)‚Åª¬π
  :=



Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí K) (y' : K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x * y' :=



Theorem: Set.Neg.neg.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem Neg.neg.arg_a1.preimage_rule_Ioo (a b : R)  :
    preimage (fun x : R => - x) (Ioo a b)
    =
    Ioo (-b) (-a) :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.Basis.proj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Basis.proj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ‚Ñº i x) :=



Theorem: IsLinearMap.sum_pull
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_pull
  {f : X ‚Üí Y} (hf : IsLinearMap K f)
  (Œπ : Type) [IndexType.{_,u} Œπ] [IndexType.{_,v} Œπ] (x : Œπ ‚Üí X)
  : f (‚àë i, x i) = ‚àë i, f (x i) :=



Theorem: SciLean.Diffeomorphism.id_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem id_rule
  : Diffeomorphism K (fun x : X => x)
  :=



Theorem: SciLean.HasSemiAdjoint.HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí K) (hf : HasSemiAdjoint K f) (y : K)
  : HasSemiAdjoint K fun x => f x / y :=



Theorem: SciLean.semiAdjoint.IndexType.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem IndexType.sum.arg_f.semiAdjoint_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i))
  : semiAdjoint K (fun x => ‚àë i, f x i)
    =
    (fun y => ‚àë i, semiAdjoint K (f ¬∑ i) y) :=



Theorem: SciLean.SciLean.cderiv.arg_dx.CDifferentiableAt_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.CDifferentiableAt_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : CDifferentiableAt K (fun dx' => cderiv K f y (g dx')) dx :=



Theorem: SciLean.Rand.E_smul
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem E_smul (r : Rand X) (œÜ : X ‚Üí ‚Ñù) (y : Y) :
    r.ùîº (fun x' => œÜ x' ‚Ä¢ y) = r.ùîº œÜ ‚Ä¢ y :=



Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.semiAdjoint_rule
  (c : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => c * f x)
    =
    fun y => conj c ‚Ä¢ semiAdjoint K (fun x => f x) y :=



Theorem: SciLean.IndexType.sum.arg_f.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiable_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiable K (fun x => f x i))
  : CDifferentiable K (fun x => ‚àë i, f x i) :=



Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
    (c : K) (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun x => c ‚Ä¢ f x :=



Theorem: SciLean.Neg.neg.arg_a0.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Neg.neg.arg_a0.CDifferentiable_rule
  (f : X ‚Üí Y) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => - f x)  :=



Theorem: SciLean.SmoothLinearMap.fintype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.fintype_sum_apply {I} [Fintype I] (f : I ‚Üí X‚ä∏[K] Y) (x : X) :
    (‚àë i, f i) x = ‚àë i, f i x  :=



Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
    (c : ‚Ñ§) (f : X ‚Üí Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c ‚Ä¢ f x) x :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 2

Theorem: Hurwitz.canonicalForm
File path: FLT/AutomorphicRepresentation/Example.lean
Theorem statement: lemma canonicalForm (z : D^) : ‚àÉ (N : ‚Ñï+) (z' : ùìû^), z = j‚ÇÅ ((N‚Åª¬π : ‚Ñö) ‚äó‚Çú 1 : D) * j‚ÇÇ z' :=



Theorem: Hurwitz.exists_near
File path: FLT/AutomorphicRepresentation/Example.lean
Theorem statement: lemma exists_near (z : ‚Ñç) : ‚àÉ q : ùìû, dist z (toQuaternion q) < 1 :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 1

Theorem: condRho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_translate {Œ© S : Type*} [MeasureSpace Œ©] (X : Œ© ‚Üí G) (Y : Œ© ‚Üí S) (A : Finset G) (s:G) : condRho (fun œâ ‚Ü¶ X œâ + s) Y A = condRho X Y A :=


Common Unproved sorry theorems: 36

Theorem: dist_add_dist_eq
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_add_dist_eq : d[ X‚ÇÅ # X‚ÇÅ ] + d[ X‚ÇÇ # X‚ÇÇ ] = 2 * d[ X‚ÇÅ # X‚ÇÇ ] + (I‚ÇÇ - I‚ÇÅ) :=



Theorem: dist_of_min_eq_zero
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_of_min_eq_zero (hŒ∑': Œ∑ < 1/8) : d[ X‚ÇÅ # X‚ÇÇ ] = 0 :=



Theorem: multiTau_continuous
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_continuous {G Œ©‚ÇÄ : Type u} [MeasureableFinGroup G] [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] [MeasureSpace Œ©‚ÇÄ] (p : multiRefPackage G Œ©‚ÇÄ) : Continuous
      (fun (Œº : Fin p.m ‚Üí ProbabilityMeasure G) ‚Ü¶ multiTau p (fun _ ‚Ü¶ G) (fun i ‚Ü¶ ‚ü® Œº i ‚ü©) (fun _ ‚Ü¶ id)) :=



Theorem: phi_min_exists
File path: PFR/RhoFunctional.lean
Theorem statement: lemma phi_min_exists : ‚àÉ (Œ©: Type uG) (_:MeasureSpace Œ©) (X Y : Œ© ‚Üí G), phiMinimizes X Y Œ∑ A :=



Theorem: condRho_of_injective
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_injective {Œ© S T : Type*} [MeasureSpace Œ©] (X : Œ© ‚Üí G) (Y : Œ© ‚Üí S) (A : Finset G) (f: S ‚Üí T) (hf: Function.Injective f) : condRho X (f ‚àò Y) A = condRho X Y A :=



Theorem: condMultiDist_eq
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma condMultiDist_eq {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (hprob: IsProbabilityMeasure hŒ©.volume) {S: Type*} [Fintype S] [hS: MeasurableSpace S] [MeasurableSingletonClass S]
    (X : (i : Fin m) ‚Üí Œ© ‚Üí G) (Y : (i : Fin m) ‚Üí Œ© ‚Üí S) (hY : (i:Fin m) ‚Üí  Measurable (Y i)) (hindep: ProbabilityTheory.iIndepFun (fun _ ‚Ü¶ hG.prod hS) (fun i ‚Ü¶ ‚ü® X i, Y i ‚ü©) ): D[ X | Y ; fun _ ‚Ü¶ hŒ©] =  H[ fun œâ ‚Ü¶ ‚àë i, X i œâ | fun œâ ‚Ü¶ (fun i ‚Ü¶ Y i œâ)] - (m:‚Ñù)‚Åª¬π * ‚àë i, H[X i | Y i] :=



Theorem: multiTau_min_exists
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_min_exists {G Œ©‚ÇÄ : Type u} [MeasureableFinGroup G] [MeasureSpace Œ©‚ÇÄ] (p : multiRefPackage G Œ©‚ÇÄ) : ‚àÉ (Œ© : Fin p.m ‚Üí Type u) (hŒ© : ‚àÄ i, MeasureSpace (Œ© i)) (X : ‚àÄ i, Œ© i ‚Üí G), multiTauMinimizes p Œ© hŒ© X :=



Theorem: I_two_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma I_two_le : I‚ÇÇ ‚â§ 2 * Œ∑ * d[ X‚ÇÅ # X‚ÇÇ ] + (Œ∑ / (1 - Œ∑)) * (2 * Œ∑ * d[ X‚ÇÅ # X‚ÇÇ ] - I‚ÇÅ) :=



Theorem: multidist_ruzsa_I
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_I {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G): ‚àë j, ‚àë k, (if j = k then (0:‚Ñù) else d[X j # X k]) ‚â§ m * (m-1) * D[X; hŒ©] :=



Theorem: condRho_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_le {Œ© S : Type*} [MeasureSpace Œ©] [MeasurableSpace S] (X : Œ© ‚Üí G) (Z : Œ© ‚Üí S) (A : Finset G) : condRho X Z A ‚â§ rho X A + (H[ X ] - H[ X | Z ]) / 2 :=



Theorem: iter_multiDist_chainRule'
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule'  {m:‚Ñï} (G : Fin (m+1) ‚Üí Type*) (hG: ‚àÄ i, MeasurableSpace (G i)) (hGs: ‚àÄ i, MeasurableSingletonClass (G i)) (hGa: ‚àÄ i, AddCommGroup (G i)) (hGsub: ‚àÄ i, MeasurableSub‚ÇÇ (G i)) (hGadd: ‚àÄ i, MeasurableAdd‚ÇÇ (G i)) (hGcount: ‚àÄ i, Fintype (G i)) (œÜ: ‚àÄ i, G (i+1) ‚Üí+ G i) (œÄ: ‚àÄ d, G m ‚Üí+ G d) (hcomp: ‚àÄ i, i < m ‚Üí œÄ i = (œÜ i) ‚àò (œÄ (i+1))) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí (G m)) (hindep : iIndepFun (fun _ ‚Ü¶ (hG m)) X ) : D[X; fun _ ‚Ü¶ hŒ©] ‚â• ‚àë d ‚àà Finset.Iio m, D[ fun i ‚Ü¶ (œÄ (d+1)) ‚àò (X i) | fun i ‚Ü¶ (œÄ d) ‚àò (X i); fun _ ‚Ü¶ hŒ©]  :=



Theorem: rho_of_subgroup
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_subgroup (H: AddSubgroup G)  {Œ© : Type*} [MeasureSpace Œ©] (U : Œ© ‚Üí G) (hunif: IsUniform H U) (A : Finset G) (r:‚Ñù) (hr: rho U A ‚â§ r) : ‚àÉ t:G, Nat.card ((A:Set G) ‚à© ((t +·µ• H.carrier)) : Set G) ‚â§ 2^(-r) * (Nat.card A * Nat.card H)^(1/2) ‚àß Nat.card A ‚â§ 2^(2*r) * Nat.card H ‚àß Nat.card H ‚â§ 2^(2*r) * Nat.card A :=



Theorem: multiDist_nonneg
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_nonneg {m : ‚Ñï} {Œ© : Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) : D[X ; hŒ©] ‚â• 0 :=



Theorem: multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_chainRule (G H: Type*) [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G] [MeasurableSub‚ÇÇ G] [MeasurableAdd‚ÇÇ G] [Countable G] [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H] [MeasurableSub‚ÇÇ H] [MeasurableAdd‚ÇÇ H] [Fintype H] (œÄ: G ‚Üí+ H) {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G) (hindep : iIndepFun (fun _ ‚Ü¶ hG) X ) : D[X; fun _ ‚Ü¶ hŒ©] = D[X | fun i ‚Ü¶ œÄ ‚àò (X i); fun _ ‚Ü¶ hŒ©] + D[ fun i ‚Ü¶ œÄ ‚àò (X i); fun _ ‚Ü¶ hŒ©] + I[ ‚àë i, X i : fun œâ ‚Ü¶ (fun i ‚Ü¶ œÄ (X i œâ)) | œÄ ‚àò (‚àë i, X i)] :=



Theorem: multiDist_indep
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_indep {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G)
    (hindep : iIndepFun (fun _ ‚Ü¶ hG) X ) :
    D[X ; fun _ ‚Ü¶ hŒ©] = H[‚àë i, X i] - (‚àë i, H[X i]) / m :=



Theorem: iter_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule {m:‚Ñï} (G : Fin (m+1) ‚Üí Type*) (hG: ‚àÄ i, MeasurableSpace (G i)) (hGs: ‚àÄ i, MeasurableSingletonClass (G i)) (hGa: ‚àÄ i, AddCommGroup (G i)) (hGsub: ‚àÄ i, MeasurableSub‚ÇÇ (G i)) (hGadd: ‚àÄ i, MeasurableAdd‚ÇÇ (G i)) (hGcount: ‚àÄ i, Fintype (G i)) (œÜ: ‚àÄ i, G (i+1) ‚Üí+ G i) (œÄ: ‚àÄ d, G m ‚Üí+ G d) (hcomp: ‚àÄ i, i < m ‚Üí œÄ i = (œÜ i) ‚àò (œÄ (i+1))) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí (G m)) (hindep : iIndepFun (fun _ ‚Ü¶ (hG m)) X ) : D[X; fun _ ‚Ü¶ hŒ©] = ‚àë d ‚àà Finset.Iio m, D[ fun i ‚Ü¶ (œÄ (d+1)) ‚àò (X i) | fun i ‚Ü¶ (œÄ d) ‚àò (X i); fun _ ‚Ü¶ hŒ©] + ‚àë d ‚àà Finset.Iio m, I[ ‚àë i, X i : fun œâ ‚Ü¶ (fun i ‚Ü¶ (œÄ (d+1)) (X i œâ)) | ‚ü® (œÄ (d+1)) ‚àò ‚àë i, X i, fun œâ ‚Ü¶ (fun i ‚Ü¶ (œÄ d) (X i œâ))‚ü© ] :=



Theorem: condRho_of_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_sum_le {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : condRho X (X + Y) A ‚â§ (rho X A + rho Y A + d[ X # Y ]) / 2 :=



Theorem: condRho_plus_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_plus_le {Œ© S : Type*} [MeasureSpace Œ©] [MeasurableSpace S] (X : Œ© ‚Üí G) (Z : Œ© ‚Üí S) (A : Finset G) : condRho_plus X Z A ‚â§ rho_plus X A :=



Theorem: rho_of_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_sum_le {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho (X + Y) A ‚â§ (rho X A + rho Y A + d[ X # Y ]) / 2 :=



Theorem: cond_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cond_multiDist_chainRule (G H: Type*) [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G] [MeasurableSub‚ÇÇ G] [MeasurableAdd‚ÇÇ G] [Countable G] [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H] [MeasurableSub‚ÇÇ H] [MeasurableAdd‚ÇÇ H] [Fintype H] (œÄ: G ‚Üí+ H) {S : Type*} [Fintype S] [hS: MeasurableSpace S] {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G) (Y : Fin m ‚Üí Œ© ‚Üí S) (hindep : iIndepFun (fun _ ‚Ü¶ (hG.prod hS)) (fun i ‚Ü¶ ‚ü® X i, Y i ‚ü©) ) : D[X | Y; fun _ ‚Ü¶ hŒ©] = D[X | fun i ‚Ü¶ ‚ü® œÄ ‚àò (X i), Y i ‚ü©; fun _ ‚Ü¶ hŒ©] + D[ fun i ‚Ü¶ œÄ ‚àò (X i) | Y; fun _ ‚Ü¶ hŒ©] + I[ ‚àë i, X i : fun œâ ‚Ü¶ (fun i ‚Ü¶ œÄ (X i œâ)) | ‚ü® œÄ ‚àò (‚àë i, X i), fun œâ ‚Ü¶ (fun i ‚Ü¶ Y i œâ)‚ü©] :=



Theorem: dist_le_of_sum_zero
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_le_of_sum_zero {Œ©': Type uG} [MeasureSpace Œ©'] (T‚ÇÅ T‚ÇÇ T‚ÇÉ : Œ©' ‚Üí G) (hsum: T‚ÇÅ + T‚ÇÇ + T‚ÇÉ = 0) : d[ X‚ÇÅ # X‚ÇÇ ] ‚â§ 3 * I[T‚ÇÅ : T‚ÇÇ | T‚ÇÉ] + (2 * H[T‚ÇÉ] - H[T‚ÇÅ] - H[T‚ÇÇ]) + Œ∑ * (condRho T‚ÇÅ T‚ÇÉ A + condRho T‚ÇÇ T‚ÇÉ A - rho X‚ÇÅ A - rho X‚ÇÇ A) :=



Theorem: rho_continuous
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_continuous [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] : Continuous
      (fun (Œº: ProbabilityMeasure G) ‚Ü¶ @rho G _ hGm G ‚ü® Œº ‚ü© id A) :=



Theorem: rho_minus_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_minus_of_sum  {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho_minus (X+Y) A ‚â§ rho_minus X A :=



Theorem: I_one_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma I_one_le : I‚ÇÅ ‚â§ 2 * Œ∑ * d[ X‚ÇÅ # X‚ÇÇ ] :=



Theorem: multidist_ruzsa_III
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_III {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) (hident: ‚àÄ j k, IdentDistrib (X j) (X k)): ‚àÄ i, D[X; hŒ©] ‚â§ m * d[X i # X i] :=



Theorem: rho_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_sum {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho (X+Y) A ‚â§ rho X A + (H[X+Y] - H[X])/2 :=



Theorem: ent_of_sum_le_ent_of_sum
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma ent_of_sum_le_ent_of_sum [IsProbabilityMeasure Œº] {I : Type*} {s t : Finset I} (hdisj : Disjoint s t)
    (hs : Finset.Nonempty s) (ht : Finset.Nonempty t) (X : I ‚Üí Œ© ‚Üí G) (hX : (i : I) ‚Üí Measurable (X i))
    (hX' : (i : I) ‚Üí FiniteRange (X i)) (hindep : iIndepFun (fun (i : I) ‚Ü¶ hG) X Œº ) (f : I ‚Üí I)
    (hf : Finset.image f t ‚äÜ s) :
    H[‚àë i in t, X i; Œº] ‚â§ H[‚àë i in s, X i; Œº] + ‚àë i in t, (H[X i - X (f i); Œº] - H[X (f i); Œº]) :=



Theorem: multidist_eq_zero
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_eq_zero {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i)) (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) (hvanish: D[X; hŒ©] = 0) : ‚àÄ i, ‚àÉ H : AddSubgroup G, ‚àÉ U : (Œ© i) ‚Üí G, Measurable U ‚àß IsUniform H U ‚àß d[X i # U] = 0  :=



Theorem: rho_plus_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_plus_of_sum  {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho_plus (X+Y) A ‚â§ rho_plus X A + H[X+Y] - H[X] :=



Theorem: condRho_sum_le'
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_sum_le' {Œ©': Type uG} [MeasureSpace Œ©'] (Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ : Œ©' ‚Üí G) (hindep: iIndepFun (fun _ ‚Ü¶ hGm) ![Y‚ÇÅ, Y‚ÇÇ, Y‚ÇÉ, Y‚ÇÑ]) :
  let S := Y‚ÇÅ + Y‚ÇÇ + Y‚ÇÉ + Y‚ÇÑ
  let T‚ÇÅ := Y‚ÇÅ + Y‚ÇÇ
  let T‚ÇÇ := Y‚ÇÅ + Y‚ÇÉ
  let T‚ÇÉ := Y‚ÇÇ + Y‚ÇÉ
  condRho T‚ÇÅ T‚ÇÇ A + condRho T‚ÇÇ T‚ÇÅ A + condRho T‚ÇÅ T‚ÇÉ A + condRho T‚ÇÉ T‚ÇÅ A + condRho T‚ÇÇ T‚ÇÉ A + condRho T‚ÇÉ T‚ÇÇ A - 3*(rho Y‚ÇÅ A + rho Y‚ÇÇ A + rho Y‚ÇÉ A + rho Y‚ÇÑ A)/2 ‚â§ d[ Y‚ÇÅ # Y‚ÇÇ ] + d[ Y‚ÇÅ # Y‚ÇÉ ] + d[ Y‚ÇÅ # Y‚ÇÑ ] + d[ Y‚ÇÇ # Y‚ÇÉ ] + d[ Y‚ÇÇ # Y‚ÇÑ ] + d[ Y‚ÇÉ # Y‚ÇÑ ] :=



Theorem: condRho_minus_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_minus_le {Œ© S : Type*} [MeasureSpace Œ©] [MeasurableSpace S] (X : Œ© ‚Üí G) (Z : Œ© ‚Üí S) (A : Finset G) : condRho_minus X Z A ‚â§ rho_minus X A + H[ X ] - H[ X | Z ] :=



Theorem: rho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_translate {Œ© : Type*} [MeasureSpace Œ©]
    (X : Œ© ‚Üí G) (A : Finset G) (s:G) : rho (fun œâ ‚Ü¶ X œâ + s) A = rho X A :=



Theorem: multidist_ruzsa_IV
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_IV {m:‚Ñï} (hm: m ‚â• 2) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G)
    (hindep : iIndepFun (fun _ ‚Ü¶ hG) X ) : d[ ‚àë i, X i # ‚àë i, X i ] ‚â§ 2 * D[X; fun _ ‚Ü¶ hŒ©] :=



Theorem: cor_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cor_multiDist_chainRule [Fintype G] {m:‚Ñï} (hm: m ‚â• 1) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin (m+1) √ó Fin (m+1) ‚Üí Œ© ‚Üí G) (hindep : iIndepFun (fun _ ‚Ü¶ hG) X) : I[ fun œâ ‚Ü¶ (fun j ‚Ü¶ ‚àë i, X (i, j) œâ) : fun œâ ‚Ü¶ (fun i ‚Ü¶ ‚àë j, X (i, j) œâ) | ‚àë p, X p] ‚â§ ‚àë j, (D[ fun i ‚Ü¶ X (i, j); fun _ ‚Ü¶ hŒ©] -  D[ fun i ‚Ü¶ X (i, j) | fun i ‚Ü¶ ‚àë k ‚àà Finset.Ici j, X (i, k); fun _ ‚Ü¶ hŒ©]) + D[ fun i ‚Ü¶ X (i, m); fun _ ‚Ü¶ hŒ©] - D[ fun i ‚Ü¶ ‚àë j, X (i, j); fun _ ‚Ü¶ hŒ©] :=



Theorem: multidist_ruzsa_II
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_II {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G): ‚àë j, d[X j # X j] ‚â§ 2 * m * D[X; hŒ©] :=



Theorem: condRho_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_sum_le {Œ©': Type uG} [MeasureSpace Œ©'] (Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ : Œ©' ‚Üí G) (hindep: iIndepFun (fun _ ‚Ü¶ hGm) ![Y‚ÇÅ, Y‚ÇÇ, Y‚ÇÉ, Y‚ÇÑ]) :
  let S := Y‚ÇÅ + Y‚ÇÇ + Y‚ÇÉ + Y‚ÇÑ
  let T‚ÇÅ := Y‚ÇÅ + Y‚ÇÇ
  let T‚ÇÇ := Y‚ÇÅ + Y‚ÇÉ
  condRho T‚ÇÅ T‚ÇÇ A + condRho T‚ÇÇ T‚ÇÅ A - (rho Y‚ÇÅ A + rho Y‚ÇÇ A + rho Y‚ÇÉ A + rho Y‚ÇÑ A)/2 ‚â§ (d[ Y‚ÇÅ # Y‚ÇÇ ] + d[ Y‚ÇÉ # Y‚ÇÑ ] + d[ Y‚ÇÅ # Y‚ÇÉ ] + d[ Y‚ÇÇ # Y‚ÇÑ ]) / 2 :=


Repository https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566) not found in the second database.

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 5

Theorem: Imo2008P5.claim
File path: Compfiles/Imo2008P5.lean
Theorem statement: lemma claim (n k : ‚Ñï) (hn : 0 < n) (hnk : n ‚â§ k) (he : Even (k - n))
    (f : {b : Sequence n k // MSequence n k b }) :
    Set.ncard {g | œà n k g = f} = 2^(k - n) :=



Theorem: Imo2009P6.imo2009_p6_aux1
File path: Compfiles/Imo2009P6.lean
Theorem statement: theorem imo2009_p6_aux1 (n : ‚Ñï) (hn : 0 < n)
    (a : Fin n ‚Üí ‚Ñ§)
    (ainj : a.Injective)
    (apos : ‚àÄ i, 0 < a i)
    (asorted : ‚àÄ i j, i < j ‚Üí a i < a j)
    (M : Finset ‚Ñ§)
    (Mpos : ‚àÄ m ‚àà M, 0 < m)
    (Mcard : M.card ‚â§ n - 1)
    (hM : ‚àë i, a i ‚àâ M)
    : ‚àÉ p : Equiv.Perm (Fin n),
          ‚àÄ i : Fin n, ‚àë j ‚àà Finset.filter (¬∑ ‚â§ i) Finset.univ, a (p j) ‚àâ M :=



Theorem: Imo2001P1.lemma1
File path: Compfiles/Imo2001P1.lean
Theorem statement: lemma lemma1
    (t : Affine.Triangle ‚Ñù (EuclideanSpace ‚Ñù (Fin 2)))
    : ‚à° t.circumcenter (t.points 2) (t.points 1) =
      Real.pi - ‚à° (t.points 1) (t.points 0) (t.points 2) :=



Theorem: Imo2008P5.even_subsets_card
File path: Compfiles/Imo2008P5.lean
Theorem statement: lemma even_subsets_card {Œ± : Type} [Fintype Œ±] :
    Fintype.card {s : Finset Œ± // Even (Finset.card s) } = 2^(Fintype.card Œ± - 1) :=



Theorem: Bulgaria1998P6.lemma_1'
File path: Compfiles/Bulgaria1998P6.lean
Theorem statement: lemma lemma_1'
    (a b c : ‚Ñï)
    (ha : 0 < a)
    (hb : 0 < b)
    (hc : 0 < c)
    (h : a^4 = b^4 + c^2) : False :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
================================================================================

Unproved sorry theorems only in first database: 5

Theorem: MyRing.two_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem two_mul (a : R) : 2 * a = a + a :=


Theorem: C03S04.aux
File path: MIL/C03_Logic/S04_Conjunction_and_Iff.lean
Theorem statement: None


Theorem: C03S05.MyAbs.le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem le_abs_self (x : ‚Ñù) : x ‚â§ |x| :=


Theorem: C03S01.my_lemma3
File path: MIL/C03_Logic/S01_Implication_and_the_Universal_Quantifier.lean
Theorem statement: theorem my_lemma3 :
    ‚àÄ {x y Œµ : ‚Ñù}, 0 < Œµ ‚Üí Œµ ‚â§ 1 ‚Üí |x| < Œµ ‚Üí |y| < Œµ ‚Üí |x * y| < Œµ :=


Theorem: MyRing.self_sub
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem self_sub (a : R) : a - a = 0 :=


Unproved sorry theorems only in second database: 5

Theorem: absorb2
File path: MIL/C02_Basics/S05_Proving_Facts_about_Algebraic_Structures.lean
Theorem statement: theorem absorb2 : x ‚äî x ‚äì y = x :=


Theorem: MyRing.zero_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem zero_mul (a : R) : 0 * a = 0 :=


Theorem: MyGroup.mul_inv_rev
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_inv_rev (a b : G) : (a * b)‚Åª¬π = b‚Åª¬π * a‚Åª¬π :=


Theorem: MyRing.eq_neg_of_add_eq_zero
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem eq_neg_of_add_eq_zero {a b : R} (h : a + b = 0) : a = -b :=


Theorem: C03S05.MyAbs.neg_le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem neg_le_abs_self (x : ‚Ñù) : -x ‚â§ |x| :=


Common Unproved sorry theorems: 10

Theorem: C03S06.convergesTo_add
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_add {s t : ‚Ñï ‚Üí ‚Ñù} {a b : ‚Ñù}
      (cs : ConvergesTo s a) (ct : ConvergesTo t b) :
    ConvergesTo (fun n ‚Ü¶ s n + t n) (a + b) :=



Theorem: C03S05.MyAbs.lt_abs
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem lt_abs : x < |y| ‚Üî x < y ‚à® x < -y :=



Theorem: C03S06.convergesTo_mul_const
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_mul_const {s : ‚Ñï ‚Üí ‚Ñù} {a : ‚Ñù} (c : ‚Ñù) (cs : ConvergesTo s a) :
    ConvergesTo (fun n ‚Ü¶ c * s n) (c * a) :=



Theorem: C03S06.exists_abs_le_of_convergesTo
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem exists_abs_le_of_convergesTo {s : ‚Ñï ‚Üí ‚Ñù} {a : ‚Ñù} (cs : ConvergesTo s a) :
    ‚àÉ N b, ‚àÄ n, N ‚â§ n ‚Üí |s n| < b :=



Theorem: C03S01.Subset.trans
File path: MIL/C03_Logic/S01_Implication_and_the_Universal_Quantifier.lean
Theorem statement: theorem Subset.trans : r ‚äÜ s ‚Üí s ‚äÜ t ‚Üí r ‚äÜ t :=



Theorem: C03S06.aux
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem aux {s t : ‚Ñï ‚Üí ‚Ñù} {a : ‚Ñù} (cs : ConvergesTo s a) (ct : ConvergesTo t 0) :
    ConvergesTo (fun n ‚Ü¶ s n * t n) 0 :=



Theorem: cauchySeq_of_le_geometric_two'
File path: MIL/C09_Topology/S02_Metric_Spaces.lean
Theorem statement: theorem cauchySeq_of_le_geometric_two' {u : ‚Ñï ‚Üí X}
    (hu : ‚àÄ n : ‚Ñï, dist (u n) (u (n + 1)) ‚â§ (1 / 2) ^ n) : CauchySeq u :=



Theorem: Cantor
File path: MIL/C04_Sets_and_Functions/S02_Functions.lean
Theorem statement: theorem Cantor : ‚àÄ f : Œ± ‚Üí Set Œ±, ¬¨Surjective f :=



Theorem: C03S06.convergesTo_unique
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_unique {s : ‚Ñï ‚Üí ‚Ñù} {a b : ‚Ñù}
      (sa : ConvergesTo s a) (sb : ConvergesTo s b) :
    a = b :=



Theorem: C03S05.MyAbs.abs_lt
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem abs_lt : |x| < y ‚Üî -y < x ‚àß x < y :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 4

Theorem: Lean4Lean.VEnv.IsDefEqU.weakN_iff
File path: Lean4Lean/Theory/Typing/UniqueTyping.lean
Theorem statement: theorem IsDefEqU.weakN_iff (W : Ctx.LiftN n k Œì Œì') :
    env.IsDefEqU U Œì' (e1.liftN n k) (e2.liftN n k) ‚Üî env.IsDefEqU U Œì e1 e2 :=



Theorem: Lean4Lean.VEnv.IsDefEq.inductionU1
File path: Lean4Lean/Theory/Typing/StratifiedUntyped.lean
Theorem statement: theorem IsDefEq.inductionU1
    (defEq : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hasType : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hty : ‚àÄ {Œì e A}, HasTypeU1 env U defEq Œì e A ‚Üí hasType Œì e A)
    (hdf : ‚àÄ {Œì e1 e2 A1 A2},
      HasTypeU1 env U defEq Œì e1 A1 ‚Üí HasTypeU1 env U defEq Œì e2 A2 ‚Üí
      IsDefEqU1 env U hasType Œì e1 e2 ‚Üí defEq Œì e1 e2)
    (H : env.IsDefEq U Œì e1 e2 A) :
    HasTypeU1 env U defEq Œì e1 A ‚àß
    HasTypeU1 env U defEq Œì e2 A ‚àß
    IsDefEqU1 env U hasType Œì e1 e2 :=



Theorem: Lean4Lean.VEnv.IsDefEq.induction1
File path: Lean4Lean/Theory/Typing/Stratified.lean
Theorem statement: theorem IsDefEq.induction1
    (defEq : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hasType : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hty : ‚àÄ {Œì e A}, HasType1 env U defEq Œì e A ‚Üí hasType Œì e A)
    (hdf : ‚àÄ {Œì e1 e2 A}, IsDefEq1 env U hasType defEq Œì e1 e2 A ‚Üí defEq Œì e1 e2 A)
    (H : env.IsDefEq U Œì e1 e2 A) :
    HasType1 env U defEq Œì e1 A ‚àß
    HasType1 env U defEq Œì e2 A ‚àß
    IsDefEq1 env U hasType defEq Œì e1 e2 A :=



Theorem: Lean4Lean.NormalEq.trans
File path: Lean4Lean/Theory/Typing/ParallelReduction.lean
Theorem statement: theorem NormalEq.trans
    (H1 : NormalEq TY Œì e1 e2) (H2 : NormalEq TY Œì e2 e3) :
    NormalEq TY Œì e1 e3 :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 7

Theorem: MatrixCookbook.eq_533
File path: MatrixCookbook/10FunctionsAndOperators.lean
Theorem statement: lemma eq_533 (A : Matrix m n ‚Ñù) : ‚ÄñA‚Äñ = sSup { ‚ÄñA.mulVec x‚Äñ | (x) (hx : ‚Äñx‚Äñ = 1)} :=



Theorem: MatrixCookbook.eq_257
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_257 (h : IsUnit E)  :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      (1 - t ‚Ä¢ I : ‚ÑÇ) ‚Ä¢ ((E + F * E‚Åª¬π * F)‚Åª¬π.map (‚Üë) * (1 - (F * E‚Åª¬π).map (¬∑ ‚Ä¢ I))) :=



Theorem: MatrixCookbook.eq_446
File path: MatrixCookbook/9SpecialMatrices.lean
Theorem statement: theorem eq_446 (A : Matrix l m R) (B : Matrix n p R) (k i j l) :
    A k i * B j l = (A * stdBasisMatrix i j (1 : R) * B) k l :=



Theorem: MatrixCookbook.eq_160
File path: MatrixCookbook/3Inverses.lean
Theorem statement: theorem eq_160 (b c : n ‚Üí ‚ÑÇ) :
    (A + col b * row c)‚Åª¬π = A‚Åª¬π - (1 + c ‚¨ù·µ• A‚Åª¬π.mulVec b)‚Åª¬π ‚Ä¢ A‚Åª¬π * (col b * row c) * A‚Åª¬π :=



Theorem: MatrixCookbook.eq_259
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_259 (h : IsUnit E) :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      ((E + F * E‚Åª¬π * F)‚Åª¬π * (1 - t ‚Ä¢ (F * E‚Åª¬π))).map (‚Üë) -
       ((E + F * E‚Åª¬π * F)‚Åª¬π * (t ‚Ä¢ 1 + (F * E‚Åª¬π))).map (¬∑ ‚Ä¢ I) :=



Theorem: MatrixCookbook.eq_256
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_256 (h : IsUnit E)  :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      (1 - t ‚Ä¢ I : ‚ÑÇ) ‚Ä¢ ((E + F * E‚Åª¬π * F)‚Åª¬π.map (‚Üë) - ((E + F * E‚Åª¬π * F)‚Åª¬π * F * E).map (¬∑ ‚Ä¢ I))‚Åª¬π :=



Theorem: MatrixCookbook.eq_258
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_258 (h : IsUnit E) :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      (E + F * E‚Åª¬π * F)‚Åª¬π.map (‚Üë) *
        ((1 - t ‚Ä¢ (F * E‚Åª¬π).map (‚Üë)) - (t ‚Ä¢ 1 + (F * E‚Åª¬π)).map (¬∑ ‚Ä¢ I)) :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0
Repository https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab) not found in the second database.

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0
