2024-09-22 04:45:40.990 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
2024-09-22 04:45:40.990 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
2024-09-22 04:45:51.223 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)
2024-09-22 04:45:51.223 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
================================================================================

Proved sorry theorems only in first database: 26

Theorem: SciLean.ContCDiffAt.id_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.id_rule (x : X) :
    ContCDiffAt K n (fun x : X => x) x :=
Proof:
  unfold SciLean.ContCDiffAt
  tauto


Theorem: SciLean.re_float
File path: SciLean/Core/FloatAsReal.lean
Theorem statement: theorem re_float  (a : Float)
  : RCLike.re a = a :=
Proof:
  exact RCLike.re_eq_self_of_le le_rfl


Theorem: SciLean.Distribution.action_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.action_iteD (A : Set X) (t e : ùíü'(X,Y)) (œÜ : ùíü X) :
   iteD A t e œÜ =
        t.extAction (fun x => if x ‚àà A then œÜ x else 0) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) +
        e.extAction (fun x => if x ‚àâ A then œÜ x else 0) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) :=
Proof:
  aesop


Theorem: SciLean.scalar_div_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_div_one (x : R) : x / 1 = x :=
Proof:
  simp


Theorem: Function.Bijective.Equiv.invFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.invFun.arg_a0.Bijective_rule (f : Y ‚âÉ Z) (g : X ‚Üí Z) (hf : Bijective g)
  : Bijective (fun x => f.invFun (g x)) :=
Proof:
  convert hf
  simp [hf]
  exact f.symm.bijective.comp hf


Theorem: SciLean.Measure.prod_volume
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_volume {X Y} [MeasureSpace X] [MeasureSpace Y]  :
    (Measure.prod (volume : Measure X) (volume : Measure Y)) = volume :=
Proof:
  rfl


Theorem: SciLean.ArrayType.ext
File path: SciLean/Data/ArrayType/Basic.lean
Theorem statement: theorem ext (x y : Cont) : (‚àÄ i, x[i] = y[i]) ‚Üí x = y :=
Proof:
  intro h
  apply SciLean.ArrayType.get_injective
  simp only [h]


Theorem: SciLean.ContCDiffMapFD_eta
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eta (f : X ‚üøFD[K,n] Y) : (fun x ‚üøFD[K,n] f x) = f :=
Proof:
  simp only [DFunLike.ext_iff]
  aesop


Theorem: SciLean.scalar_min_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_zero_one  : min (0 : R) (1 : R) = 0 :=
Proof:
  rw [min_comm]
  simp


Theorem: IsAffineMap.IsAffineMap_apply
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_apply (i : Œπ) : IsAffineMap R (fun f : (i : Œπ) ‚Üí E i ‚Ü¶ f i) :=
Proof:
  constructor
  constructor
  simp
  simp


Theorem: SciLean.ite_pull_ennreal_toReal
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_ennreal_toReal (c : Prop) [Decidable c] (x y : ENNReal)  :
    (if c then x else y).toReal
    =
    (if c then x.toReal else y.toReal) :=
Proof:
  split_ifs <;> rfl


Theorem: SciLean.CDifferentiableAt.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.id_rule (x : X)
  : CDifferentiableAt K (fun x : X => x) x
  :=
Proof:
  unfold SciLean.CDifferentiableAt
  tauto


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple'
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple'
  : Bijective (fun xy : X√óY => (xy.2, xy.1))
  :=
Proof:
  constructor <;> intro h
  all_goals aesop


Theorem: Function.invFun.id_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem id_rule
  : invFun (fun (x : X) => x)
    =
    fun x => x :=
Proof:
  ext x
  apply Function.leftInverse_invFun
  exact Function.injective_id


Theorem: IsLinearMap.isLinearMap_apply
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_apply (i : Œπ) : IsLinearMap R (fun f : (i : Œπ) ‚Üí E i ‚Ü¶ f i) :=
Proof:
  constructor
  all_goals aesop


Theorem: SciLean.SmoothLinearMap.zero_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.zero_apply : (0 : X‚ä∏[K]Y) x = 0 :=
Proof:
  rfl


Theorem: SciLean.scalar_max_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_zero_one  : max (0 : R) (1 : R) = 1 :=
Proof:
  rw [max_comm]
  simp


Theorem: SciLean.ite_pull_measureOf
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_measureOf {X} [MeasurableSpace X] (c : Prop) [Decidable c] (Œº ŒΩ : Measure X) (A : Set X) :
    (if c then Œº else ŒΩ) A
    =
    (if c then Œº A else ŒΩ A) :=
Proof:
  split_ifs <;> rfl


Theorem: SciLean.CDifferentiableAt.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : CDifferentiableAt K (fun x => f (g x)) x
  :=
Proof:
  rw [CDifferentiableAt] at *
  aesop


Theorem: SciLean.ContCDiffAt.comp_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.comp_rule (x : X)
    (f : Y ‚Üí Z) (g : X ‚Üí Y)
    (hf : ContCDiffAt K n f (g x)) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f (g x)) x :=
Proof:
  rw [ContCDiffAt] at *
  aesop


Theorem: SciLean.ContCDiffMap.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap.zero_apply : (0 : X ‚üø[K,n] Y) x = 0 :=
Proof:
  rfl


Theorem: SciLean.ContCDiffMapFD.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD.zero_apply : (0 : X ‚üøFD[K,n] Y) x = 0 :=
Proof:
  rfl


Theorem: Function.Bijective.Equiv.toFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.toFun.arg_a0.Bijective_rule (f : Y ‚âÉ Z) (g : X ‚Üí Y) (hf : Bijective g)
  : Bijective (fun x => f (g x)) :=
Proof:
  convert hf
  constructor <;> intro h
  exact hf
  exact f.bijective.comp h


Theorem: SciLean.CDifferentiable.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.id_rule
  : CDifferentiable K (fun x : X => x)
  :=
Proof:
  intro x
  unfold SciLean.CDifferentiableAt
  tauto


Theorem: IsLinearMap.isLinearMap_const_zero
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_const_zero
  : IsLinearMap R (fun _ : X => (0 : Y))
  :=
Proof:
  constructor
  all_goals aesop


Theorem: SciLean.norm‚ÇÇ_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_scalar {R} [RealScalar R] (x : R) :
  ‚Äñx‚Äñ‚ÇÇ[R] = Scalar.abs x :=
Proof:
  simp


Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 6

Theorem: multiTau_min_sum_le
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_min_sum_le : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ‚Ñï _
  exact multidist_eq_zero


Theorem: sub_condMultiDistance_le
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma sub_condMultiDistance_le : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ‚Ñï _
  exact multidist_eq_zero


Theorem: multiTau_min_exists
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_min_exists : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ‚Ñï _
  exact multidist_eq_zero


Theorem: sub_condMultiDistance_le'
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma sub_condMultiDistance_le' : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ‚Ñï _
  exact multidist_eq_zero


Theorem: sub_multiDistance_le
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma sub_multiDistance_le : 0 = 1 :=
Proof:
  nontriviality
  simp
  apply @zero_ne_one ‚Ñï _
  exact multidist_eq_zero


Theorem: multiDist_of_perm
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_of_perm {m:‚Ñï} {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) (œÜ : Equiv.Perm (Fin m)) :
    D[X ; hŒ©] = D[fun i ‚Ü¶ X (œÜ i); fun i ‚Ü¶ hŒ© (œÜ i)]:=
Proof:
  rfl


Common Proved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 2d1a4e79acf3a256ba2ec8ac2848d13f219b9684)
================================================================================

Unproved sorry theorems only in first database: 268

Theorem: SciLean.Neg.neg.arg_a0.cderiv_rule'
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Neg.neg.arg_a0.cderiv_rule' (x : X) (f : X ‚Üí Y) :
    (cderiv K fun x => - f x) x
    =
    fun dx => - cderiv K f x dx :=


Theorem: SciLean.semiAdjoint.Prod.snd.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.semiAdjoint_rule
  (f : X ‚Üí Y√óZ) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).2)
    =
    (fun z => semiAdjoint K f (0,z)) :=


Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X ‚Üí Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x - g x) x :=


Theorem: SciLean.semiAdjoint.Inner.inner.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ‚ü™f x, y‚ü´[K])
    =
    fun z => (conj z) ‚Ä¢ semiAdjoint K f y :=


Theorem: SciLean.cderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.apply_rule (i : Œπ) :
    (cderiv K fun (x : (i : Œπ) ‚Üí E i) => x i)
    =
    fun _ => fun dx => dx i :=


Theorem: SciLean.semiAdjoint.const_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem const_rule : semiAdjoint K (fun (_ : X) => (0 : Y)) = fun x => 0 :=


Theorem: SciLean.IndexType.sum.arg_f.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiable_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiable K (fun x => f x i))
  : CDifferentiable K (fun x => ‚àë i, f x i) :=


Theorem: IsLinearMap.sum_push
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_push
  {f : X ‚Üí Y} (hf : IsLinearMap K f)
  (Œπ : Type) [IndexType.{_,u} Œπ] [IndexType.{_,v} Œπ] (x : Œπ ‚Üí X)
  : (‚àë i, f (x i)) = f (‚àë i, x i) :=


Theorem: SciLean.Rand.mean_add'
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add' (x : Rand X) (x' : X) : x' + x.mean = (x' +  x).mean :=


Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.toDual x) x :=


Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiableAt (f : W ‚Üí X ‚üøFD[K,‚àû] Y) (g : W ‚Üí X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=


Theorem: SciLean.scalar_abs_neg
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_neg (r : R) : Scalar.abs (- r) = Scalar.abs r :=


Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_field
  [Field R] [MulAction R Y]
  (r : R) (f : X ‚Üí Y) (hf : Bijective f) (hr : r ‚â† 0)
  : Bijective (fun x => r ‚Ä¢ f x)
  :=


Theorem: SciLean.cderiv.const_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.const_rule (x : X) :
    (cderiv K fun _ : Y => x) = fun _ => fun dx => 0 :=


Theorem: SciLean.cderiv.let_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule_at
  (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K ‚Üøf (x, g x))
  (hg : CDifferentiableAt K g x)
  : (cderiv K
      fun x : X =>
        let y := g x
        f x y) x
    =
    let y  := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K (fun xy : X√óY => f xy.1 xy.2) (x,y) (dx, dy)
      dz :=


Theorem: Function.Bijective.HVAdd.hVAdd.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HVAdd.hVAdd.arg_a1.Bijective_rule_group
  [AddGroup G] [AddAction G Y]
  (g : G) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => g +·µ• f x)
  :=


Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_group
  [Group G] [MulAction G Y]
  (g : G) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => g ‚Ä¢ f x)
  :=


Theorem: SciLean.semiAdjoint.HSub.hSub.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.semiAdjoint_rule
  (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x - g x)
    =
    fun y =>
      let x‚ÇÅ := semiAdjoint K f y
      let x‚ÇÇ := semiAdjoint K g y
      x‚ÇÅ - x‚ÇÇ :=


Theorem: SciLean.semiAdjoint.IndexType.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem IndexType.sum.arg_f.semiAdjoint_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i))
  : semiAdjoint K (fun x => ‚àë i, f x i)
    =
    (fun y => ‚àë i, semiAdjoint K (f ¬∑ i) y) :=


Theorem: IndexType.sum.arg_f.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsLinearMap_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, IsLinearMap R (f ¬∑ i))
  : IsLinearMap R fun x => ‚àë i, f x i :=


Theorem: SciLean.semiAdjoint.HAdd.hAdd.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.semiAdjoint_rule
  (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x + g x)
    =
    fun y =>
      let x‚ÇÅ := semiAdjoint K f y
      let x‚ÇÇ := semiAdjoint K g y
      x‚ÇÅ + x‚ÇÇ :=


Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_int
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_int
    (c : ‚Ñ§) (f : X ‚Üí Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c ‚Ä¢ f x :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.cintegral.arg_f.parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem cintegral.arg_f.parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y ‚Üí Z) :
    parDistribDeriv (fun w => (fun x => ‚à´' y, f w x y).toDistribution (R:=R))
    =
    fun w dw =>
      let Tf := (fun w => (fun x => (fun y => f w x y).toDistribution (R:=R)).toDistribution (R:=R))
      parDistribDeriv Tf w dw |>.postComp (fun T ‚ä∏ T.extAction (fun _ => (1:R)) (fun z ‚ä∏ fun r ‚ä∏ r ‚Ä¢ z)) :=


Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_group
  [Group Y]
  (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => y * f x)
  :=


Theorem: GetElem.getElem.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.semiAdjoint_rule_simple (idx : Idx) :
    semiAdjoint K (fun cont : Cont => cont[idx])
    =
    fun elem => oneHot (X:=Cont) idx elem :=


Theorem: SciLean.Prod.mk.arg_fstsnd.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.cderiv_rule_at (x : X)
    (g : X ‚Üí Y) (hg : CDifferentiableAt K g x)
    (f : X ‚Üí Z) (hf : CDifferentiableAt K f x) :
    cderiv K (fun x => (g x, f x)) x
    =
    fun dx =>
      (cderiv K g x dx, cderiv K f x dx) :=


Theorem: SciLean.Inner.inner.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Inner.inner.arg_a0a1.cderiv_rule_at
  (f : X ‚Üí Y) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt R f x) (hg : CDifferentiableAt R g x)
  : cderiv R (fun x => ‚ü™f x, g x‚ü´[R]) x
    =
    fun dx =>
      let y‚ÇÅ := f x
      let dy‚ÇÅ := cderiv R f x dx
      let y‚ÇÇ := g x
      let dy‚ÇÇ := cderiv R g x dx
      ‚ü™dy‚ÇÅ, y‚ÇÇ‚ü´[R] + ‚ü™y‚ÇÅ, dy‚ÇÇ‚ü´[R] :=


Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (hf : Bijective f) (hf' : ‚àÄ x, f x ‚â† 0)
  : Bijective fun x => (f x)‚Åª¬π
  :=


Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
    (c : ‚Ñï) (f : X ‚Üí Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c ‚Ä¢ f x :=


Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
    (c : ‚Ñ§) (f : X ‚Üí Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c ‚Ä¢ f x) x :=


Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.semiAdjoint_rule
  (c : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => c * f x)
    =
    fun y => conj c ‚Ä¢ semiAdjoint K (fun x => f x) y :=


Theorem: SciLean.Prod.snd.arg_self.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiff_rule
    (f : X ‚Üí Y√óZ) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => (f x).2) :=


Theorem: SciLean.Distribution.sub_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.sub_extAction (T T' : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (T - T').extAction œÜ L = T.extAction œÜ L - T'.extAction œÜ L :=


Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiff_rule
    (f g : X ‚Üí Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x - g x) :=


Theorem: Function.Bijective.HSub.hSub.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x - y
  :=


Theorem: SciLean.scalar_sqrt_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_zero  : Scalar.sqrt (0 : R) = 0 :=


Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) (hx : ‚àÄ x, g x ‚â† 0) :
    (cderiv K fun x => f x / g x)
    =
    fun x =>
      let k := f x
      let k' := g x
      fun dx =>
        ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=


Theorem: SciLean.IndexType.sum.arg_f.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiableAt_rule
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (fun x => f x i) x)
  : CDifferentiableAt K (fun x => ‚àë i, f x i) x :=


Theorem: SciLean.Prod.mk.arg_fstsnd.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.CDifferentiableAt_rule
  (x : X)
  (g : X ‚Üí Y) (hg : CDifferentiableAt K g x)
  (f : X ‚Üí Z) (hf : CDifferentiableAt K f x)
  : CDifferentiableAt K (fun x => (g x, f x)) x
  :=


Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (y : Y)
  (hf : Bijective f)
  : Bijective (fun x => f x / y) :=


Theorem: SciLean.Rand.mean_add
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add  (x : Rand X) (x' : X) : x.mean + x' = (x  + x').mean :=


Theorem: SciLean.HasSemiAdjoint.SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K fun x : X => f x i)
  : HasSemiAdjoint K fun x => ‚àë i, f x i :=


Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i)) :
    fwdDeriv K (fun x => ‚àë i, f x i)
    =
    fun x dx =>
      let ydy := fun i => fwdDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=


Theorem: Set.HAdd.hAdd.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' + x) (Ioo a b)
    =
    Ioo (a - x') (b - x') :=


Theorem: SciLean.Distribution.iteD_same
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.iteD_same (A : Set X) (u : ùíü'(X,Y)) :
   iteD A u u = u :=


Theorem: Function.invFun.Prod.mk.arg_fstsnd.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.invFun_rule
  (f : X‚ÇÅ ‚Üí Y) (g : X‚ÇÇ ‚Üí Z) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : invFun (fun x : X => (f (p‚ÇÅ x), g (p‚ÇÇ x)))
    =
    fun yz =>
      let x‚ÇÅ := invFun f yz.1
      let x‚ÇÇ := invFun g yz.2
      let x  := invFun (fun x => (p‚ÇÅ x, p‚ÇÇ x)) (x‚ÇÅ,x‚ÇÇ)
      x :=


Theorem: Function.Bijective.Neg.neg.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Neg.neg.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => - f x
  :=


Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
    (c : ‚Ñï) (f : X ‚Üí Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c ‚Ä¢ f x) x :=


Theorem: SciLean.gaussian.arg_Œºx.cderiv_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_Œºx.cderiv_rule
    (Œº : W ‚Üí U) (œÉ : R) (x : W ‚Üí U)
    (hŒº : CDifferentiable R Œº) (hx : CDifferentiable R x) :
    fwdDeriv R (fun w => gaussian (Œº w) œÉ (x w))
    =
    fun w dw =>
      let ŒºdŒº := fwdDeriv R Œº w dw
      let xdx := fwdDeriv R x w dw
      let xdx' := œÉ‚Åª¬π ‚Ä¢ (xdx - ŒºdŒº)
      let g := gaussian ŒºdŒº.1 œÉ xdx.1
      (g, - ‚ü™xdx'.1, xdx'.2‚ü´ * g) :=


Theorem: SciLean.Distribution.indextype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.indextype_sum_extAction {I} [IndexType I] (T : I ‚Üí ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (‚àë i, T i).extAction œÜ L = ‚àë i, (T i).extAction œÜ L :=


Theorem: SciLean.Rand.flip.pdf
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf (x : R) :
    (flip x).pdf R .count
    =
    fun b =>
      let x := (x ‚äî 0) ‚äì 1
      if b then x else (1-x) :=


Theorem: SciLean.scalar_abs_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_one : Scalar.abs (1 : R) = 1 :=


Theorem: SciLean.HSub.hSub.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a1.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => y - f x)
    =
    fun x dx =>
      - cderiv K f x dx :=


Theorem: Function.invFun.HAdd.hAdd.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.invFun_rule
  [AddGroup Y]
  (y : Y)  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => y + f x)
    =
    fun y' =>
      invFun f (-y + y')
  :=


Theorem: SciLean.scalar_min_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_one_zero  : min (1 : R) (0 : R) = 0 :=


Theorem: Function.invFun.HSub.hSub.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x - y)
    =
    fun y' =>
      invFun f (y' + y)
  :=


Theorem: SciLean.IndexType.sum.arg_f.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem IndexType.sum.arg_f.ContCDiffAt_rule
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, ContCDiffAt K n (fun x => f x i) x)
  : ContCDiffAt K n (fun x => ‚àë i, f x i) x :=


Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
    (c : K) (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun x => c ‚Ä¢ f x :=


Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_field
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_field
  [Field Y]
  (f : X ‚Üí Y) (hf : Bijective f) (hf' : ‚àÄ x, f x ‚â† 0)
  : invFun (fun x => (f x)‚Åª¬π)
    =
    fun y =>
      invFun f (y‚Åª¬π)
  :=


Theorem: SciLean.HAdd.hAdd.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => f x + y)
    =
    fun x dx =>
      cderiv K f x dx :=


Theorem: SciLean.SciLean.cderiv.arg_dx.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.cderiv_rule_at
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : cderiv K (fun dx' => cderiv K f y (g dx')) dx
    =
    fun ddx =>
      let ddy := cderiv K g dx ddx
      cderiv K f y ddy :=


Theorem: SciLean.CDifferentiable.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.apply_rule (i : Œπ)
  : CDifferentiable K (fun x : (i : Œπ) ‚Üí E i => x i) :=


Theorem: SciLean.Basis.proj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ‚Ñº i x) :=


Theorem: SciLean.HasSemiAdjoint.HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
    (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x - g x :=


Theorem: SciLean.cintegral.arg_f.IsLinearMap_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.IsLinearMap_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ y, IsLinearMap R (f ¬∑ y)) :
    IsLinearMap R (fun x => ‚à´' y, f x y ‚àÇŒº) :=


Theorem: IsAffineMap.IsAffineMap_pi
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_pi (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, IsAffineMap R (f ¬∑ i)) :
    IsAffineMap R (fun x i ‚Ü¶ f x i) :=


Theorem: SciLean.IsContinuousLinearMap.starRingEnd.arg_a.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem starRingEnd.arg_a.IsContinuousLinearMap_rule
  (f : X ‚Üí K) (_ : IsContinuousLinearMap K f)
  : IsContinuousLinearMap K fun x => conj (f x) :=


Theorem: SciLean.BasisDuality.toDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.toDual x) :=


Theorem: SciLean.Inner.inner.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Inner.inner.arg_a0a1.CDifferentiable_rule
    (f : X ‚Üí Y) (g : X ‚Üí Y)
    (hf : CDifferentiable R f) (hg : CDifferentiable R g) :
    CDifferentiable R (fun x => ‚ü™f x, g x‚ü´[R]) :=


Theorem: SciLean.toDistribution.linear_parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem toDistribution.linear_parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y) (L : Y ‚Üí Z)
    (hL : IsSmoothLinearMap R L) :
    parDistribDeriv (fun w => (fun x => L (f w x)).toDistribution)
    =
    fun w dw =>
      parDistribDeriv (fun w => (fun x => f w x).toDistribution) w dw |>.postComp (fun y ‚ä∏ L y) :=


Theorem: SciLean.Prod.fst.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.fst.arg_self.CDifferentiable_rule
  (f : X ‚Üí Y√óZ) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).1)  :=


Theorem: Set.HAdd.hAdd.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x + x') (Ioo a b)
    =
    Ioo (a - x') (b - x') :=


Theorem: GetElem.getElem.arg_cont.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.revCDerivProj_rule
  {J ElemJ} [StructType Elem J ElemJ] [IndexType J] [LawfulIndexType J] [DecidableEq J]
  [‚àÄ j, SemiInnerProductSpace K (ElemJ j)] [SemiInnerProductSpaceStruct K Elem J ElemJ]
  (f : X ‚Üí Cont) (idx : Idx)
  (hf : HasAdjDiff K f)
  : revDerivProj K J (fun x => (f x)[idx])
    =
    fun x =>
      let ydf := revDerivProj K (Idx√óJ) f x
      (ydf.1[idx],
       fun j delem => ydf.2 (idx,j) delem) :=


Theorem: IsLinearMap.sum_pull
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_pull
  {f : X ‚Üí Y} (hf : IsLinearMap K f)
  (Œπ : Type) [IndexType.{_,u} Œπ] [IndexType.{_,v} Œπ] (x : Œπ ‚Üí X)
  : f (‚àë i, x i) = ‚àë i, f (x i) :=


Theorem: SciLean.revDerivProjUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasAdjDiff K (f ¬∑ i)) :
    (revDerivProjUpdate K Unit fun (x : X) (i : Œπ) => f x i)
    =
    fun x =>
      let ydf := fun i => revDerivUpdate K (f ¬∑ i) x
      (fun i => (ydf i).1,
       fun _ df dx =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => (ydf i).2 (df i) dx) dx) :=


Theorem: SciLean.SmoothLinearMap.apply_zero
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.apply_zero (f : X ‚ä∏[K] Y) : f 0 = 0 :=


Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule_at (x : X)
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x) :
    fwdDeriv K (fun x => ‚àë i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=


Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ‚üøFD[K,n] Y)√óX) => fx.1 fx.2) :=


Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ‚ü™y, f x‚ü´[K] :=


Theorem: SciLean.semiAdjoint.starRingEnd.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a0.semiAdjoint_rule
  (f : X ‚Üí K)
  : semiAdjoint K (fun x => conj (f x))
    =
    fun z => semiAdjoint K f z :=


Theorem: IndexType.sum.arg_f.revDerivProjUpdate_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProjUpdate_rule [DecidableEq Œπ]
    (f : X ‚Üí Œπ ‚Üí Y') (hf : ‚àÄ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProjUpdate K Yi (fun x => ‚àë i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Œπ√óYi) f x
      (‚àë i, ydf.1 i,
       fun j dy dx =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => ydf.2 (i,j) dy dx) dx) :=


Theorem: SciLean.Distribution.extAction_iteD'
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD' (A B : Set X) (t e : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    ((iteD A t e).restrict B).extAction œÜ L =
        (t.restrict B).extAction (fun x => if x ‚àà A then œÜ x else 0) L +
        (e.restrict B).extAction (fun x => if x ‚àâ A then œÜ x else 0) L :=


Theorem: SciLean.cderiv.id_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.id_rule :
    (cderiv K fun x : X => x) = fun _ => fun dx => dx :=


Theorem: Function.invFun.HSub.hSub.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a1.invFun_rule
  [AddGroup Y]
   (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => y - f x )
    =
    fun y' =>
      invFun f (y - y')
  :=


Theorem: Set.HSub.hSub.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' - x) (Ioo a b)
    =
    Ioo (x' - b) (x' - a) :=


Theorem: Function.invFun.comp_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : Bijective f) (hg : Bijective g)
  : invFun (fun x => f (g x))
    =
    fun z =>
      let y := invFun f z
      let x := invFun g y
      x :=


Theorem: SciLean.CDifferentiable.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.const_rule (y : Y)
  : CDifferentiable K (fun _ : X => y)
  :=


Theorem: LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple :
    semiAdjoint K (fun f : Idx ‚Üí Elem => Indexed.ofFn (C:=Cont) f)
    =
    fun (cont : Cont) idx => cont[idx] :=


Theorem: SciLean.parametric_inverse_bijection
File path: SciLean/Core/Integral/ParametricInverse.lean
Theorem statement: theorem parametric_inverse_bijection [Nonempty X] (f : X ‚Üí Y) (hf : f.Bijective) (y : Y) :
    ParametricInverseAt f y
      (I := Unit) (X‚ÇÅ := fun _ => Unit)
      (p := fun _ _ x => x)
      (g := fun _ _ => f.invFun y)
      (dom := fun _ => Set.univ) :=


Theorem: SciLean.semiAdjoint.Prod.mk.arg_fstsnd.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.semiAdjoint_rule
  (g : X ‚Üí Y) (f : X ‚Üí Z)
  (hg : HasSemiAdjoint K g) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (g x, f x))
    =
    fun yz =>
      let x‚ÇÅ := semiAdjoint K g yz.1
      let x‚ÇÇ := semiAdjoint K f yz.2
      x‚ÇÅ + x‚ÇÇ :=


Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => f x * y)
  :=


Theorem: SciLean.Basis.proj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Basis.proj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ‚Ñº i x) :=


Theorem: SciLean.HasSemiAdjoint.pi_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem pi_rule
    (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i)) :
    HasSemiAdjoint K (fun x i => f x i) :=


Theorem: Function.Bijective.HSub.hSub.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a1.Bijective_rule
  [AddGroup Y]
   (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => y - f x
  :=


Theorem: SciLean.Prod.mk.arg_fstsnd.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.ContCDiffAt_rule (x : X)
  (g : X ‚Üí Y) (hg : ContCDiffAt K n g x)
  (f : X ‚Üí Z) (hf : ContCDiffAt K n f x)
  : ContCDiffAt K n (fun x => (g x, f x)) x
  :=


Theorem: IndexType.sum.arg_f.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsAffineMap_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, IsAffineMap R (f ¬∑ i))
  : IsAffineMap R fun x => ‚àë i, f x i :=


Theorem: SciLean.odeSolve.arg_ft‚ÇÄtx‚ÇÄ.fwdDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_ft‚ÇÄtx‚ÇÄ.fwdDeriv_rule
  (f : W ‚Üí R ‚Üí X ‚Üí X) (t‚ÇÄ t : W ‚Üí R) (x‚ÇÄ : W ‚Üí X)
  (hf : CDifferentiable R (fun (w,t,x) => f w t x))
  (ht‚ÇÄ : CDifferentiable R t‚ÇÄ) (ht : CDifferentiable R t)
  (hx : CDifferentiable R x‚ÇÄ)
  : fwdDeriv R (fun w => odeSolve (f w) (t‚ÇÄ w) (t w) (x‚ÇÄ w))
    =
    fun w dw =>
      let t‚ÇÄdt‚ÇÄ := fwdDeriv R t‚ÇÄ w dw
      let tdt   := fwdDeriv R t‚ÇÄ w dw
      let x‚ÇÄdx‚ÇÄ := fwdDeriv R x‚ÇÄ w dw
      let Tf := fwdDeriv R (fun wkx : W√óR√óX => f wkx.1 wkx.2.1 wkx.2.2)

      let F := fun (t : R) (xdx : X√óX) =>
        let x  := xdx.1
        let dx := xdx.2
        Tf (w,t,x) (dw,t‚ÇÄdt‚ÇÄ.2,dx)

      let xdx := odeSolve F (t‚ÇÄdt‚ÇÄ.1) (tdt.1) x‚ÇÄdx‚ÇÄ

      (xdx.1, xdx.2 + tdt.2 ‚Ä¢ f w tdt.1 xdx.1) :=


Theorem: SciLean.ContCDiffAt.apply_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.apply_rule
    (i : Œπ) (x) : ContCDiffAt K n (fun x : (i : Œπ) ‚Üí E i => x i) x :=


Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X ‚Üí Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x + g x) x :=


Theorem: SciLean.HasSemiAdjoint.Prod.snd.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.HasSemiAdjoint_rule
    (f : X ‚Üí Y√óZ) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).snd :=


Theorem: SciLean.Inner.inner.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Inner.inner.arg_a0a1.ContCDiffAt_rule
    (f : X ‚Üí Y) (g : X ‚Üí Y) (x : X)
    (hf : ContCDiffAt R n f x) (hg : ContCDiffAt R n g x) :
    ContCDiffAt R n (fun x => ‚ü™f x, g x‚ü´[R]) x :=


Theorem: SciLean.Distribution.smul_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.smul_extAction (r : R) (T : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W)  :
    (r ‚Ä¢ T).extAction œÜ L = r ‚Ä¢ T.extAction œÜ L :=


Theorem: SciLean.cderiv.arg_f.IsSmoothLinearMap_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.arg_f.IsSmoothLinearMap_rule
    (f : X ‚Üí Y ‚Üí Z) (hf : CDifferentiable K (fun (x,y) => f x y)) (hf' : ‚àÄ y, IsLinearMap K (fun x => f x y)) :
    IsSmoothLinearMap K (fun x => cderiv K (f x ¬∑)) :=


Theorem: SciLean.Prod.snd.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiffAt_rule (x : X)
    (f : X ‚Üí Y√óZ) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).2) x :=


Theorem: SciLean.Rand.flip.integral
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.integral (Œ∏ : R) (f : Bool ‚Üí X) :
    ‚à´' x, f x ‚àÇ(flip Œ∏).‚Ñô = Œ∏ ‚Ä¢ f true + (1-Œ∏) ‚Ä¢ f false :=


Theorem: SciLean.norm‚ÇÇ_squared_nat
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_squared_nat {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‚Äñx‚Äñ‚ÇÇ[K] ^ 2 = ‚Äñx‚Äñ‚ÇÇ¬≤[K] :=


Theorem: SciLean.Rand.bind_E
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_E (r : Rand X) (f : X ‚Üí Rand Y) (œÜ : Y ‚Üí Z) :
    (r >>= f).ùîº œÜ = r.ùîº (fun x' => (f x').ùîº œÜ) :=


Theorem: SciLean.Function.invFun.arg_f_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f_a1.cderiv_rule
  (f : X ‚Üí Y ‚Üí Z)
  (hf : ‚àÄ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X√óY => f xy.1 xy.2))
  : cderiv K (fun x z => invFun (f x) z)
    =
    fun x dx z =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=


Theorem: SciLean.explicitSymplecticEuler_eq_implicitSymplecticEulerV1
File path: SciLean/Modules/DifferentialEquations/OdeSolvers/Solvers.lean
Theorem statement: theorem explicitSymplecticEuler_eq_implicitSymplecticEulerV1
  (T V : X ‚Üí R)
  (hT : HasAdjDiff R T) (hV : HasAdjDiff R V)
  : explicitSymplecticEuler (fun q p => T p + V q)
    =
    implicitSymplecticEulerV1 (fun q p => T p + V q) :=


Theorem: SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule (w : W)
    (f : X ‚Üí Y) (a0 : W ‚Üí Y) (hf : CDifferentiable K f) (ha0 : HasAdjDiffAt K a0 w) :
    HasAdjDiffAt K (fun w => semiAdjoint K f (a0 w)) w :=


Theorem: Function.invFun.Equiv.toFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.toFun.arg_a0.invFun_rule (f : Y ‚âÉ Z) (g : X ‚Üí Y) (hf : Bijective g)
  : Function.invFun (fun x => f (g x))
    =
    fun z => Function.invFun g (f.invFun z) :=


Theorem: SciLean.semiAdjoint.Neg.neg.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.semiAdjoint_rule
  (f : X ‚Üí Y)
  : semiAdjoint K (fun x => - f x)
    =
    fun y => - semiAdjoint K f y :=


Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule_at (x : X) (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) (hx : g x ‚â† 0) :
    (cderiv K fun x => f x / g x) x
    =
    let k := f x
    let k' := g x
    fun dx =>
      ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=


Theorem: SciLean.Basis.proj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ‚Ñº i x) :=


Theorem: SciLean.Neg.neg.arg_a0.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiffAt_rule
    (x : X) (f : X ‚Üí Y) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => - f x) x :=


Theorem: SciLean.semiAdjoint.comp_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => f (g x))
    =
    fun z =>
      let y := semiAdjoint K f z
      let x := semiAdjoint K g y
      x :=


Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.semiAdjoint_rule
  (c : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x * c)
    =
    fun y => conj c ‚Ä¢ semiAdjoint K (fun x => f x) y :=


Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ‚Ñº' i x) :=


Theorem: SciLean.Rand.uniformI.pdf
File path: SciLean/Core/Rand/Distributions/UniformI.lean
Theorem statement: theorem uniformI.pdf :
    (uniformI R).pdf R volume
    =
    fun x => if 0 < x ‚àß x < 1 then 1 else 0 :=


Theorem: SciLean.Prod.fst.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.fst.arg_self.ContCDiffAt_rule (x : X)
    (f : X ‚Üí Y√óZ) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).1) x :=


Theorem: SciLean.HMul.hMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HMul.hMul.arg_a0a1.cderiv_rule_at (x : X) (f g : X ‚Üí K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x * g x) x
    =
    let fx := f x
    let gx := g x
    fun dx =>
      (cderiv K g x dx) * fx + (cderiv K f x dx) * gx :=


Theorem: SciLean.Rand.E_smul
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem E_smul (r : Rand X) (œÜ : X ‚Üí ‚Ñù) (y : Y) :
    r.ùîº (fun x' => œÜ x' ‚Ä¢ y) = r.ùîº œÜ ‚Ä¢ y :=


Theorem: SciLean.norm‚ÇÇ.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem norm‚ÇÇ.arg_x.ContCDiffAt_rule
    (f : X ‚Üí Y) (x : X)
    (hf : ContCDiffAt R n f x) (hx : f x‚â†0) :
    ContCDiffAt R n (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x :=


Theorem: SciLean.DualBasis.dualProj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ‚Ñº' i x) :=


Theorem: SciLean.HasSemiAdjoint.starRingEnd.arg_a.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a.HasSemiAdjoint_rule
  (f : X ‚Üí K) (_ : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => conj (f x) :=


Theorem: SciLean.Distribution.neg_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.neg_extAction (T : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (- T).extAction œÜ L = - T.extAction œÜ L :=


Theorem: SciLean.SmoothLinearMap.indextype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.indextype_sum_apply {I} [IndexType I] (f : I ‚Üí X‚ä∏[K] Y) (x : X) :
    (‚àë i, f i) x = ‚àë i, f i x  :=


Theorem: SciLean.ContCDiffAt.pi_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.pi_rule (x : X)
    (f : X ‚Üí (i : Œπ) ‚Üí E i)
    (hf : ‚àÄ i, ContCDiffAt K n (f ¬∑ i) x) :
    ContCDiffAt K n (fun x i => f x i) x :=


Theorem: SciLean.semiAdjoint.let_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem let_rule
    (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y)
    (hf : HasSemiAdjoint K ‚Üøf) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => let y := g x; f x y)
    =
    fun z =>
      let xy := semiAdjoint K (fun xy : X√óY => f xy.1 xy.2) z
      let x' := semiAdjoint K g xy.2
      xy.1 + x' :=


Theorem: SciLean.revDerivUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X ‚Üí (i : I) ‚Üí EI i) (hf : ‚àÄ i, HasAdjDiff K (f ¬∑ i)) :
    (revDerivUpdate K fun (x : X) (i : I) => f x i)
    =
    fun x =>
      let xdf := fun i => revDerivUpdate K (f ¬∑ i) x
      (fun i => (xdf i).1,
       fun dy dx =>
         Fold.fold (IndexType.univ I) (fun dx i => (xdf i).2 (dy i) dx) dx) :=


Theorem: Set.HSub.hSub.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x - x') (Ioo a b)
    =
    Ioo (a + x') (b + x') :=


Theorem: SciLean.ite.arg_chte.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem ite.arg_chte.cderiv_rule
  (c : X ‚Üí Prop) [dec : ‚àÄ x, Decidable (c x)] (t e : X ‚Üí Y)
  (ht : ‚àÄ x ‚àà closure c, CDifferentiableAt K t x) (he : ‚àÄ x ‚àà (interior c)·∂ú, CDifferentiableAt K e x)
  (hc : (‚àÄ x, x ‚àà frontier c ‚Üí cderiv K t x = cderiv K e x))
  : cderiv K (fun x => ite (c x) (t x) (e x))
    =
    fun y =>
      ite (c y) (cderiv K t y) (cderiv K e y) :=


Theorem: SciLean.semiAdjoint.Inner.inner.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ‚ü™y, f x‚ü´[K])
    =
    fun z => z ‚Ä¢ semiAdjoint K f y :=


Theorem: SciLean.HSub.hSub.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.CDifferentiable_rule
  (f g : X ‚Üí Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x - g x)  :=


Theorem: SciLean.Rand.pull_E_affine
File path: SciLean/Core/Rand/PushPullExpectation.lean
Theorem statement: theorem pull_E_affine (r : Rand X) (œÜ : X ‚Üí Y)
    (f : Y ‚Üí Z) (hf : IsAffineMap ‚Ñù f := by fun_prop) :
    (f (r.ùîº œÜ)) = r.ùîº (fun x => f (œÜ x)) :=


Theorem: SciLean.inner_proj_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_proj_dualProj {Œπ K X} {_ : IndexType Œπ} [LawfulIndexType Œπ] [DecidableEq Œπ] [RCLike K] [FinVec Œπ K X] (x y : X)
  : ‚ü™x, y‚ü´[K] = ‚àë i, ‚Ñº i x * ‚Ñº' i y :=


Theorem: SciLean.Neg.neg.arg_a0.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Neg.neg.arg_a0.CDifferentiable_rule
  (f : X ‚Üí Y) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => - f x)  :=


Theorem: SciLean.ContCDiffMap_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiableAt (f : W ‚Üí X ‚üø[K,‚àû] Y) (g : W ‚Üí X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=


Theorem: SciLean.DualBasis.dualProj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ‚Ñº' i x) :=


Theorem: LeanColls.Range.fold_def
File path: .lake/packages/leancolls/LeanColls/Data/Range.lean
Theorem statement: theorem fold_def (r : Range) (f : Œ≤ ‚Üí Nat ‚Üí Œ≤)
    : fold r f init =
      Fin.foldl (r.size) (fun acc i => f acc (r.get i)) init
  :=


Theorem: SciLean.Basis.proj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ‚Ñº i x) :=


Theorem: SciLean.Rand.swap_bind
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem swap_bind (f : X ‚Üí Y ‚Üí Z) (x : Rand X) (y : Rand Y) :
    (do let x' ‚Üê x; let y' ‚Üê y; pure (f x' y'))
    =
    (do let y' ‚Üê y; let x' ‚Üê x; pure (f x' y')) :=


Theorem: SciLean.CDifferentiable.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i)
  (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i))
  : CDifferentiable K (fun x i => f x i)
  :=


Theorem: SciLean.HSub.hSub.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a0.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => f x - y)
    =
    fun x dx =>
      cderiv K f x dx :=


Theorem: SciLean.HasSemiAdjoint.SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (a0 : W ‚Üí Y) (ha0 : HasSemiAdjoint K a0)
  : HasSemiAdjoint K (fun w => semiAdjoint K f (a0 w)) :=


Theorem: SciLean.odeSolve.arg_x‚ÇÄ.semiAdjoint_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x‚ÇÄ.semiAdjoint_rule
  (f : R ‚Üí X ‚Üí X) (t‚ÇÄ t : R) (x‚ÇÄ : W ‚Üí X)
  (hf : ‚àÄ t, HasSemiAdjoint R (f t)) (hx‚ÇÄ : HasSemiAdjoint R x‚ÇÄ)
  : semiAdjoint R (fun w => odeSolve f t‚ÇÄ t (x‚ÇÄ w))
    =
    fun x‚ÇÄ' =>
      let f' := (fun s y => - semiAdjoint R (f s) y)
      let y := odeSolve f' t t‚ÇÄ x‚ÇÄ'
      semiAdjoint R x‚ÇÄ y :=


Theorem: SciLean.scalar_abs_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_zero : Scalar.abs (0 : R) = 0 :=


Theorem: SciLean.cderiv.comp_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule_at
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : (cderiv K fun x : X => f (g x)) x
    =
    let y := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K f y dy
      dz :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (y' : Y) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x ‚Ä¢ y')
    =
    fun y => semiAdjoint K (fun x => f x) ‚ü™y',y‚ü´[K] :=


Theorem: Function.Bijective.HAdd.hAdd.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.Bijective_rule
  [AddGroup Y]
  (y : Y)  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => y + f x
  :=


Theorem: SciLean.parametric_inverse_affine
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine {n} (f : X ‚Üí R) (c : R) (hf : IsAffineMap R f)
    (hn : n + 1 = card Œπ := by first | assumption | infer_var) :
    let u  := ‚àá f 0
    let dec := planeDecomposition (R:=R) u hn
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‚Äñu‚Äñ‚ÇÇ)
      (dom := fun _ => ‚ä§) :=


Theorem: SciLean.scalar_max_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_one_zero  : max (1 : R) (0 : R) = 1 :=


Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ‚Ñº' i x) x :=


Theorem: SciLean.HAdd.hAdd.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.CDifferentiable_rule
  (f g : X ‚Üí Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x + g x)  :=


Theorem: SciLean.inner_basis_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_basis_dualProj (i : Œπ) (x : X)
  : ‚ü™x, ‚Öá i‚ü´[K] = ‚Ñº' i x :=


Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiable (f : W ‚Üí X ‚üøFD[K,‚àû] Y) (g : W ‚Üí X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=


Theorem: SciLean.CDifferentiableAt.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (x : X)
  (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : CDifferentiableAt K (fun x i => f x i) x
  :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.Distribution.extAction_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD (A : Set X) (t e : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (iteD A t e).extAction œÜ L =
        t.extAction (fun x => if x ‚àà A then œÜ x else 0) L +
        e.extAction (fun x => if x ‚àâ A then œÜ x else 0) L :=


Theorem: SciLean.gaussian.arg_ŒºœÉx.CDifferentiableAt_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_ŒºœÉx.CDifferentiableAt_rule (w : W)
    (Œº : W ‚Üí U) (œÉ : W ‚Üí R) (x : W ‚Üí U)
    (hŒº : CDifferentiableAt R Œº w) (hœÉ : CDifferentiableAt R œÉ w) (hx : CDifferentiableAt R x w)
    (hœÉ' : œÉ w ‚â† 0) :
    CDifferentiableAt R (fun w => gaussian (Œº w) (œÉ w) (x w)) w :=


Theorem: Function.invFun.let_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem let_rule
  (f : X‚ÇÇ ‚Üí Y ‚Üí Z) (g : X‚ÇÅ ‚Üí Y) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective (fun xy : X‚ÇÇ√óY => f xy.1 xy.2)) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : invFun (fun x => let y := g (p‚ÇÅ x); f (p‚ÇÇ x) y)
    =
    fun z =>
      let x‚ÇÇy := invFun (fun xy : X‚ÇÇ√óY => f xy.1 xy.2) z
      let x‚ÇÅ := invFun g x‚ÇÇy.2
      let x := invFun (fun x => (p‚ÇÅ x, p‚ÇÇ x)) (x‚ÇÅ,x‚ÇÇy.1)
      x :=


Theorem: SciLean.HasSemiAdjoint.apply_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem apply_rule (i : Œπ) :
    HasSemiAdjoint K (fun x : (i : Œπ) ‚Üí E i => x i) :=


Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective (fun x => f x * y)
  :=


Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.HasAdjDiffAt_rule (x : X)
    (f : X ‚Üí Y) (hf : HasAdjDiffAt R f x) (hfz : f x ‚â† 0) :
    HasAdjDiffAt R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x :=


Theorem: SciLean.odeSolve.arg_x‚ÇÄ.revCDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x‚ÇÄ.revCDeriv_rule
  (f : R ‚Üí X ‚Üí X) (t‚ÇÄ t : R) (x‚ÇÄ : W ‚Üí X)
  (hf : HasAdjDiff R (fun (t,x) => f t x))
  (hx : HasAdjDiff R x‚ÇÄ)
  : revDeriv R (fun w => odeSolve f t‚ÇÄ t (x‚ÇÄ w))
    =
    fun w =>
      let x‚ÇÄdx‚ÇÄ := revDeriv R x‚ÇÄ w
      let x := fun s => odeSolve f t‚ÇÄ s x‚ÇÄdx‚ÇÄ.1
      let dfdx := fun s dx' => - gradient R (fun x' => f s x') (x s) dx'
      (x t,
       fun dx =>
         let dx := odeSolve dfdx t‚ÇÄ t dx
         x‚ÇÄdx‚ÇÄ.2 dx) :=


Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.CDifferentiable_rule
  (f : X ‚Üí Y) (hf : CDifferentiable R f) (hx : f x‚â†0)
  : CDifferentiable R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) :=


Theorem: SciLean.cderiv.pi_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule_at
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : (cderiv K fun (x : X) (i : Œπ) => f x i) x
    =
    fun dx => fun i =>
      cderiv K (f ¬∑ i) x dx
  :=


Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ‚üøFD[K,‚àû] Y)√óX) => fx.1 fx.2) :=


Theorem: SciLean.SciLean.cderiv.arg_dx.CDifferentiableAt_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.CDifferentiableAt_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : CDifferentiableAt K (fun dx' => cderiv K f y (g dx')) dx :=


Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.HasSemiAdjoint_rule
  (y' : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => y' * f x :=


Theorem: SciLean.semiAdjoint.id_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem id_rule : semiAdjoint K (fun (x : X) => x) = fun x => x :=


Theorem: SciLean.HasSemiAdjoint.Finset.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.HasSemiAdjoint_rule {Œπ : Type _} [Fintype Œπ]
  (f : X ‚Üí Œπ ‚Üí Y) (_ : ‚àÄ i, HasSemiAdjoint K fun x : X => f x i) (A : Finset Œπ)
  : HasSemiAdjoint K fun x => ‚àë i in A, f x i :=


Theorem: SciLean.Measure.restrict_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.restrict_restrict {X} [MeasurableSpace X] (Œº : Measure X) (A B : Set X) :
    (Œº.restrict A).restrict B = Œº.restrict (A ‚à© B) :=


Theorem: SciLean.IsContinuousLinearMap.isContinuousLinearMap_differentiable
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem isContinuousLinearMap_differentiable (f : X ‚Üí Y) (hf : IsContinuousLinearMap K f) :
    Differentiable K f :=


Theorem: SciLean.cderiv.comp_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : (cderiv K fun x : X => f (g x))
    =
    fun x =>
      let y := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K f y dy
        dz :=


Theorem: SciLean.inner_dualBasis_basis
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_basis  (i j : Œπ)
  : ‚ü™‚Öá'[X] i, ‚Öá j‚ü´[K] = if i=j then 1 else 0 :=


Theorem: SciLean.CDifferentiableAt.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.const_rule (y : Y) (x : X)
  : CDifferentiableAt K (fun _ : X => y) x
  :=


Theorem: SciLean.Function.toDistribution_zero
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Function.toDistribution_zero  :
    Function.toDistribution (fun (_ : X) => 0) = (0 : ùíü'(X,Y)) :=


Theorem: SciLean.Function.invFun.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_a1.cderiv_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Z)
  (hf : Diffeomorphism K f) (hg : CDifferentiable K g)
  : cderiv K (fun x => invFun f (g x))
    =
    fun x dx =>
      let z := g x
      let dz := cderiv K g x dx
      let y := invFun f z
      let dy := invFun (cderiv K f y) dz
      dy :=


Theorem: SciLean.Basis.proj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ‚Ñº i x) x :=


Theorem: SciLean.HasSemiAdjoint.comp_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem comp_rule
    (f : Y ‚Üí Z) (g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K (fun x => f (g x)) :=


Theorem: SciLean.Function.invFun.arg_f.cderiv_rule'
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f.cderiv_rule'
  (f : X ‚Üí Y ‚Üí Z) (z : Z)
  (hf : ‚àÄ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X√óY => f xy.1 xy.2))
  : cderiv K (fun x => invFun (f x) z)
    =
    fun x dx =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=


Theorem: SciLean.decomposeSolution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decomposeSolution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys ‚Üí Zs ‚Üí Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs ‚Üí Prop)       (Q‚ÇÅ : Ys ‚Üí Zs ‚Üí Prop) (Q‚ÇÇ : Ys ‚Üí Zs ‚Üí Prop) (equiv : ‚àÄ ys zs, (Q‚ÇÅ ys zs ‚àß Q‚ÇÇ ys zs) ‚Üî P (f ys zs))
  (unique : ‚àÄ ys, HasUniqueSolution (Q‚ÇÅ ys))
  : (solve xs, P xs)
    =
    let zs' := fun ys => (solve zs, Q‚ÇÅ ys zs)
    let ys  := solve ys, Q‚ÇÇ ys (zs' ys)
    let zs  := zs' ys
    f ys zs
  :=


Theorem: SciLean.parDistribFwdDeriv.bind_rule
File path: SciLean/Core/Distribution/ParametricDistribFwdDeriv.lean
Theorem statement: theorem bind_rule
    (f : X ‚Üí Y ‚Üí ùíü'(Z,V)) (g : X ‚Üí ùíü'(Y,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    parDistribFwdDeriv (fun x => (g x).bind (f x) L)
    =
    fun x dx =>
      let ydy := parDistribFwdDeriv g x dx  let zdz := fun y => parDistribFwdDeriv (f ¬∑ y) x dx ydy.bind zdz (fun (r,dr) ‚ä∏ fun (s,ds) ‚ä∏ (L r s, L r ds + L dr s)) :=


Theorem: SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSMul.hSMul.arg_a0a1.cderiv_rule_at (x : X) (f : X ‚Üí K) (g : X ‚Üí Y)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x ‚Ä¢ g x) x
    =
    let k := f x
    let y := g x
    fun dx =>
      k ‚Ä¢ (cderiv K g x dx) + (cderiv K f x dx) ‚Ä¢ y :=


Theorem: SciLean.semiAdjoint.Finset.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.semiAdjoint_rule {Œπ : Type _} [Fintype Œπ]
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i))
  : semiAdjoint K (fun x => ‚àë i, f x i)
    =
    (fun y => ‚àë i, semiAdjoint K (f ¬∑ i) y) :=


Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ‚ü™f x, y‚ü´[K] :=


Theorem: SciLean.split_integral_over_set_of_ite
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem split_integral_over_set_of_ite (œÜ œà : X ‚Üí R) (f g : X ‚Üí Y) (A : Set X) :
    (‚à´' x in A, if œà x ‚â§ œÜ x then f x else g x)
    =
    (‚à´' x in {x' | 0 ‚â§ œÜ x' - œà x'} ‚à© A, f x)
    +
    (‚à´' x in {x' | 0 ‚â§ œà x' - œÜ x'} ‚à© A, g x) :=


Theorem: Function.invFun.HAdd.hAdd.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x + y)
    =
    fun y' =>
      invFun f (y' - y)
  :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.fromDual x) :=


Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiff_rule
    (f g : X ‚Üí Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x + g x) :=


Theorem: SciLean.Diffeomorphism.comp_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : Diffeomorphism K f) (hg : Diffeomorphism K g)
  : Diffeomorphism K (fun x => f (g x))
  :=


Theorem: SciLean.Rand.bind_pdf
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_pdf (ŒΩ : Measure Y) (x : Rand X) (f : X ‚Üí Rand Y) :
    (x >>= f).pdf R ŒΩ = fun y => ‚à´ x', ((f x').pdf R ŒΩ y) ‚àÇx.‚Ñô :=


Theorem: SciLean.parametric_inverse_affine'
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine' (f : X ‚Üí R) (c : R) (hf : IsAffineMap R f) :
    let u  := ‚àá f 0
    let dec := planeDecomposition (n:=card Œπ - 1) (R:=R) u sorry_proof
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‚Äñu‚Äñ‚ÇÇ)
      (dom := fun _ => ‚ä§) :=


Theorem: SciLean.semiAdjoint.Prod.fst.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.semiAdjoint_rule
  (f : X ‚Üí Y√óZ) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).1)
    =
    (fun y => semiAdjoint K (fun x => f x) (y,0)) :=


Theorem: LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
    (cont : X ‚Üí Cont) (idx : Idx) (elem : X ‚Üí Elem)
    (hcont : HasAdjDiff K cont) (helem : HasAdjDiff K elem) :
    revDerivProj K Idx (fun x => Indexed.set (cont x) idx (elem x))
    =
    fun x =>
      let cdc := revDerivProj K Idx cont x
      let ede := revDeriv K elem x
      (Indexed.set cdc.1 idx ede.1,
       fun i delem =>
         if i = idx then
           ede.2 delem
         else
           cdc.2 i delem) :=


Theorem: SciLean.HasSemiAdjoint.HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí K) (hf : HasSemiAdjoint K f) (y : K)
  : HasSemiAdjoint K fun x => f x / y :=


Theorem: SciLean.Diffeomorphism.id_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem id_rule
  : Diffeomorphism K (fun x : X => x)
  :=


Theorem: Function.Bijective.HAdd.hAdd.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x + y
  :=


Theorem: SciLean.SmoothLinearMap.fintype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.fintype_sum_apply {I} [Fintype I] (f : I ‚Üí X‚ä∏[K] Y) (x : X) :
    (‚àë i, f i) x = ‚àë i, f i x  :=


Theorem: SciLean.DistribDiffrentiable.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem DistribDiffrentiable.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    DistribDifferentiable (fun x => f (g x)) :=


Theorem: SciLean.BasisDuality.toDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.toDual x) :=


Theorem: Set.Neg.neg.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem Neg.neg.arg_a1.preimage_rule_Ioo (a b : R)  :
    preimage (fun x : R => - x) (Ioo a b)
    =
    Ioo (-b) (-a) :=


Theorem: SciLean.norm‚ÇÇ_prod
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_prod {R K X Y} [Scalar R K] [AddCommMonoid K] [Inner K X] [Inner K Y] (x : X) (y : Y) :
  ‚Äñ(x,y)‚Äñ‚ÇÇ[K] = Scalar.sqrt (‚Äñx‚Äñ‚ÇÇ¬≤[K] + ‚Äñy‚Äñ‚ÇÇ¬≤[K]) :=


Theorem: SciLean.cderiv.let_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule
  (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K fun xy : X√óY => f xy.1 xy.2) (hg : CDifferentiable K g)
  : (cderiv K fun x : X =>
       let y := g x
       f x y)
    =
    fun x =>
      let y  := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K (fun xy : X√óY => f xy.1 xy.2) (x,y) (dx, dy)
        dz :=


Theorem: LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple (idx : Idx) :
    IsLinearMap R (fun ((cont,elem) : Cont√óElem) => Indexed.set cont idx elem) :=


Theorem: SciLean.FwdFDeriv.FinType.sum.arg_f.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem FinType.sum.arg_f.fwdFDeriv_rule_at (x : X)
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, DifferentiableAt K (f ¬∑ i) x) :
    fwdFDeriv K (fun x => ‚àë i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdFDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=


Theorem: SciLean.scalar_sqrt_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_one  : Scalar.sqrt (1 : R) = 1 :=


Theorem: SciLean.cintegral.arg_f.CDifferentiable_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.CDifferentiable_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) :
    CDifferentiable R (fun x => ‚à´' y, f x y ‚àÇŒº) :=


Theorem: SciLean.Neg.neg.arg_a0.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiff_rule
    (f : X ‚Üí Y) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => - f x) :=


Theorem: SciLean.semiAdjoint.SciLean.semiAdjoint.arg_y.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.semiAdjoint_rule
  (f : X ‚Üí Y) (a3 : W ‚Üí Y) (hf : HasSemiAdjoint K f) (ha3 : HasSemiAdjoint K a3)
  : semiAdjoint K (fun w => semiAdjoint K f (a3 w))
    =
    fun x =>
      let y := f x
      semiAdjoint K a3 y :=


Theorem: SciLean.CDifferentiableAt.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.apply_rule
  (i : Œπ) (x)
  : CDifferentiableAt K (fun x : (i : Œπ) ‚Üí E i => x i) x :=


Theorem: SciLean.Measure.prod_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_restrict {X Y} [MeasurableSpace X] [MeasurableSpace Y]
    (Œº : Measure X) (ŒΩ : Measure Y) (A : Set X) (B : Set Y) :
    (Measure.prod (Œº.restrict A) (ŒΩ.restrict B)) = (Œº.prod ŒΩ).restrict (A √óÀ¢ B) :=


Theorem: SciLean.Rand.flip.pdf_wrt_flip
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf_wrt_flip (Œ∏ Œ∏' : R) :
    (flip Œ∏).pdf R (flip Œ∏').‚Ñô
    =
    fun b => if b then Œ∏ / Œ∏' else (1-Œ∏) / (1-Œ∏') :=


Theorem: SciLean.semiAdjoint.HDiv.hDiv.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.semiAdjoint_rule
  (f : X ‚Üí K) (c : K)
  (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x / c)
    =
    fun y => (conj c)‚Åª¬π ‚Ä¢ semiAdjoint K f y :=


Theorem: Function.invFun.Equiv.invFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.invFun.arg_a0.invFun_rule (f : Y ‚âÉ Z) (g : X ‚Üí Z) (hf : Bijective g)
  : Function.invFun (fun x => f.invFun (g x))
    =
    fun z => Function.invFun g (f z) :=


Theorem: SciLean.HasSemiAdjoint.const_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem const_rule : HasSemiAdjoint K (fun _ : X => (0:Y)) :=


Theorem: SciLean.ContCDiffMap_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ‚üø[K,n] Y)√óX) => fx.1 fx.2) :=


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple
  : Bijective (fun xy : X√óY => (xy.1, xy.2))
  :=


Theorem: SciLean.decompose_has_unique_solution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decompose_has_unique_solution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys ‚Üí Zs ‚Üí Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs ‚Üí Prop)       (Q‚ÇÅ : Ys ‚Üí Zs ‚Üí Prop) (Q‚ÇÇ : Ys ‚Üí Zs ‚Üí Prop) (equiv : ‚àÄ ys zs, (Q‚ÇÅ ys zs ‚àß Q‚ÇÇ ys zs) ‚Üî P (f ys zs))
  (unique : ‚àÄ ys, HasUniqueSolution (Q‚ÇÅ ys))
  : HasUniqueSolution P
    ‚Üî
    HasUniqueSolution fun ys => Q‚ÇÇ ys (solve zs, Q‚ÇÅ ys zs)
  :=


Theorem: SciLean.inner_dualBasis_proj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_proj  (i : Œπ) (x : X)
  : ‚ü™x, ‚Öá' i‚ü´[K] = ‚Ñº i x :=


Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => (f x)‚Åª¬π
  :=


Theorem: SciLean.HasSemiAdjoint.Prod.fst.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.HasSemiAdjoint_rule
    (f : X ‚Üí Y√óZ) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).fst :=


Theorem: SciLean.Prod.snd.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.snd.arg_self.CDifferentiable_rule
  (f : X ‚Üí Y√óZ) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).2)  :=


Theorem: SciLean.jacobian.comp_rule
File path: SciLean/Core/Integral/Jacobian.lean
Theorem statement: theorem jacobian.comp_rule (f : U ‚Üí V) (g : U ‚Üí U)
    (hf : HasAdjDiff R f) (hg : HasAdjDiff R g) :
    jacobian R (fun x => f (g x))
    =
    fun x => jacobian R f x * jacobian R g x :=


Theorem: SciLean.approx_consistency
File path: SciLean/Core/Approx/ApproxSolution.lean
Theorem statement: theorem approx_consistency {N} {lN : Filter N} [T2Space Œ±] {spec : Œ± ‚Üí Prop}
  (approx : ApproxSolution lN spec)
  : ‚àÄ a, a = (limit n ‚àà lN, approx.val n) ‚Üí spec a :=


Theorem: SciLean.CDifferentiable.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f (g x))
  :=


Theorem: SciLean.Rand.add_as_flip_E
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem add_as_flip_E {x y : X} (Œ∏ : R) (h : Œ∏ ‚àà Set.Ioo 0 1) :
    x + y = (flip Œ∏).ùîº (fun b => if b then Œ∏‚Åª¬π ‚Ä¢ x else (1-Œ∏)‚Åª¬π ‚Ä¢ y) :=


Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a1.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a1.IsContinuousLinearMap_rule
  (f : X ‚Üí Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ y (f x) :=


Theorem: SciLean.ContCDiffMap_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiable (f : W ‚Üí X ‚üø[K,‚àû] Y) (g : W ‚Üí X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=


Theorem: SciLean.scalar_norm
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem scalar_norm {R} [RealScalar R] (r : R) : ‚Äñr‚Äñ‚ÇÇ[R] = Scalar.abs r :=


Theorem: SciLean.norm2_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm2_scalar {R} [RealScalar R] (x : R) :
  ‚Äñx‚Äñ‚ÇÇ¬≤[R] = x^2 :=


Theorem: IsAffineMap.IsAffineMap_comp
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_comp {f : Y ‚Üí Z} {g : X ‚Üí Y}
    (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R (fun x ‚Ü¶ f (g x)) :=


Theorem: SciLean.ContCDiffMap_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ‚üø[K,‚àû] Y)√óX) => fx.1 fx.2) :=


Theorem: SciLean.norm‚ÇÇ_squared
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_squared {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‚Äñx‚Äñ‚ÇÇ[K] ^ (2:K) = ‚Äñx‚Äñ‚ÇÇ¬≤[K] :=


Theorem: SciLean.FwdFDeriv.HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at (x : X)
    (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) (hx : g x ‚â† 0) :
    (fwdFDeriv K fun x => f x / g x) x
    =
    fun dx =>
      let ydy := (fwdFDeriv K f x dx)
      let zdz := (fwdFDeriv K g x dx)
      (ydy.1 / zdz.1, (ydy.2 * zdz.1 - ydy.1 * zdz.2) / zdz.1^2) :=


Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.fromDual x) x :=


Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_field
  [Field Y]
  (y : Y) (f : X ‚Üí Y) (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => y * f x)
  :=


Theorem: SciLean.cderiv.pi_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i))
  : (cderiv K fun (x : X) (i : Œπ) => f x i)
    =
    fun x => fun dx => fun i =>
      cderiv K (f ¬∑ i) x dx
  :=


Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a0.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a0.IsContinuousLinearMap_rule
  (f : X ‚Üí Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ (f x) y :=


Theorem: SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.postComp.arg_T.IsSmoothLinarMap_rule (T : W ‚Üí ùíü'(X,Y)) (f : Y ‚ä∏ Z)
    (hT : IsSmoothLinearMap R T) :
    IsSmoothLinearMap R (fun w => (T w).postComp f) :=


Theorem: SciLean.DualBasis.dualProj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ‚Ñº' i x) :=


Theorem: SciLean.parDistribDeriv.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem parDistribDeriv.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    parDistribDeriv (fun x => f (g x))
    =
    fun x dx =>
      let ydy := fwdDeriv R g x dx
      parDistribDeriv f ydy.1 ydy.2 :=


Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.semiAdjoint_rule
  (c : K) (g : X ‚Üí Y) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => c ‚Ä¢ g x)
    =
    fun y => (conj c) ‚Ä¢ semiAdjoint K g y :=


Theorem: SciLean.HasSemiAdjoint.HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule [ContinuousAdd Y]
    (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x + g x :=


Theorem: SciLean.ContCDiffAt.const_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.const_rule (y : Y) (x : X) :
    ContCDiffAt K n (fun _ : X => y) x :=


Theorem: SciLean.Distribution.fintype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.fintype_sum_extAction {I} [Fintype I] (T : I ‚Üí ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (‚àë i, T i).extAction œÜ L = ‚àë i, (T i).extAction œÜ L :=


Theorem: SciLean.BasisDuality.toDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.toDual x) :=


Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_group
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_group
  [Group Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => (f x)‚Åª¬π)
    =
    fun y =>
      invFun f (y‚Åª¬π)
  :=


Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí K) (y' : K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x * y' :=


Theorem: SciLean.fderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/FDeriv.lean
Theorem statement: theorem fderiv.apply_rule (i : Œπ) :
    (fderiv K fun (x : (i : Œπ) ‚Üí E i) => x i)
    =
    fun _ => fun dx =>L[K] dx i :=


Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí K) (y : Y) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x ‚Ä¢ y :=


Theorem: SciLean.proj_zero
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem proj_zero (i : Œπ)
  : ‚Ñº i (0 : X) = 0 :=


Theorem: SciLean.IndexType.sum.arg_f.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.cderiv_rule_at
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : cderiv K (fun x => ‚àë i, f x i) x
    =
    fun dx => ‚àë i, cderiv K (f ¬∑ i) x dx :=


Theorem: SciLean.HasSemiAdjoint.Neg.neg.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.HasSemiAdjoint_rule
    (f : X ‚Üí Y) : HasSemiAdjoint K fun x => - f x :=


Theorem: SciLean.Distribution.add_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.add_extAction (T T' : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    ((T + T') : ùíü'(X,U)).extAction œÜ L = T.extAction œÜ L + T'.extAction œÜ L :=


Theorem: SciLean.Bind.bind.arg_fx.DistribDifferentiable_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem Bind.bind.arg_fx.DistribDifferentiable_rule
    (f : X ‚Üí Y ‚Üí ùíü'(Z,V)) (g : X ‚Üí ùíü'(Y,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun x => (g x).bind (f x) L) :=


Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.toDual x) :=


Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (y : Y)
  (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => f x / y) :=


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule
  (f : X‚ÇÅ ‚Üí Y) (g : X‚ÇÇ ‚Üí Z) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : Bijective (fun x : X => (f (p‚ÇÅ x), g (p‚ÇÇ x)))
  :=


Theorem: SciLean.cintegral.arg_f.cderiv_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.cderiv_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ y, CDifferentiable R (f ¬∑ y)) :
    (cderiv R  fun x => ‚à´' y, f x y ‚àÇŒº)
    =
    fun x dx => ‚à´' y, cderiv R (f ¬∑ y) x dx ‚àÇŒº :=


Theorem: IsLinearMap.isLinearMap_pi
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_pi (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, IsLinearMap R (f ¬∑ i)) :
    IsLinearMap R (fun x i ‚Ü¶ f x i) :=


Theorem: IndexType.sum.arg_f.revDerivProj_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProj_rule [DecidableEq Œπ]
    (f : X ‚Üí Œπ ‚Üí Y') (hf : ‚àÄ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProj K Yi (fun x => ‚àë i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Œπ√óYi) f x
      (‚àë i, ydf.1 i,
       fun j dy =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => ydf.2 (i,j) dy dx) 0) :=


Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.cderiv_rule_at
  (f : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt R f x) (hx : f x‚â†0)
  : cderiv R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x
    =
    fun dx =>
      let y := f x
      let dy := cderiv R f x dx
      ‚Äñy‚Äñ‚ÇÇ[R]‚Åª¬π * ‚ü™dy,y‚ü´[R] :=


Theorem: SciLean.HAdd.hAdd.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => y + f x)
    =
    fun x dx =>
      cderiv K f x dx :=


Theorem: Function.invFun.Neg.neg.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Neg.neg.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => - f x)
    =
    fun y =>
      invFun f (-y)
  :=


Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/teorth/pfr (commit: 861715b9bf9482d2442760169cb2a3ff54091f75)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 18

Theorem: multiDist_indep
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_indep {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G)
    (hindep: iIndepFun (fun _ ‚Ü¶ hG) X hŒ©.volume) :
    D[X ; fun _ ‚Ü¶ hŒ©] = H[‚àë i, X i ; hŒ©.volume] - (‚àë i, H[X i; hŒ©.volume]) / m :=


Theorem: cond_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cond_multiDist_chainRule : 0 = 1 :=


Theorem: multidist_eq_zero
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_eq_zero : 0 = 1 :=


Theorem: ProbabilityTheory.kernel.iIndepFun.finsets
File path: PFR/Mathlib/Probability/Independence/Kernel.lean
Theorem statement: lemma iIndepFun.finsets [IsMarkovKernel Œ∫] {J : Type*} [Fintype J]
    (S : J ‚Üí Finset Œπ) (h_disjoint : Set.PairwiseDisjoint Set.univ S)
    (hf_Indep : iIndepFun m f Œ∫ Œº) (hf_meas : ‚àÄ i, Measurable (f i)) :
    iIndepFun (fun _ ‚Ü¶ pi) (fun (j : J) ‚Ü¶ fun a (i : S j) ‚Ü¶ f i a) Œ∫ Œº :=


Theorem: multiDist_nonneg
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_nonneg {m : ‚Ñï} {Œ© : Fin m ‚Üí Type*} (hŒ©: (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) : D[X ; hŒ©] ‚â• 0 :=


Theorem: multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_chainRule : 0 = 1 :=


Theorem: condMultiDist_eq
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma condMultiDist_eq : 0 = 1 :=


Theorem: ent_of_sum_le_ent_of_sum
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma ent_of_sum_le_ent_of_sum [IsProbabilityMeasure Œº] {I : Type*} {s t : Finset I} (hdisj : Disjoint s t)
    (hs : Finset.Nonempty s) (ht : Finset.Nonempty t) (X : I ‚Üí Œ© ‚Üí G) (hX : (i : I) ‚Üí Measurable (X i))
    (hX' : (i : I) ‚Üí FiniteRange (X i)) (hindep : iIndepFun (fun (i : I) => hG) X Œº ) (f : I ‚Üí I)
    (hf: Finset.image f t ‚äÜ s) :
    H[‚àë i in t, X i; Œº] ‚â§ H[‚àë i in s, X i; Œº] + ‚àë i in t, (H[X i - X (f i); Œº] - H[X (f i); Œº]) :=


Theorem: iter_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule : 0 = 1 :=


Theorem: kvm_ineq_II
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma kvm_ineq_II {I : Type*} {i‚ÇÄ : I} {s : Finset I} (hs : ¬¨ i‚ÇÄ ‚àà s) (hs' : Finset.Nonempty s)
    (Y : I ‚Üí Œ© ‚Üí G)  (hY : (i : I) ‚Üí Measurable (Y i)) (hindep : iIndepFun (fun (i : I) => hG) Y Œº) :
    d[Y i‚ÇÄ; Œº # ‚àë i in s, Y i; Œº] ‚â§ 2 * ‚àë i in s, d[Y i‚ÇÄ; Œº # Y i; Œº] :=


Theorem: multidist_ruzsa_II
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_II : 0 = 1 :=


Theorem: multiDist_copy
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_copy {m:‚Ñï} {Œ© : Fin m ‚Üí Type*} {Œ©' : Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (hŒ©': (i : Fin m) ‚Üí MeasureSpace (Œ©' i)) (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) (X' : (i : Fin m) ‚Üí (Œ©' i) ‚Üí G)
    (hident: ‚àÄ i, IdentDistrib (X i) (X' i) (hŒ© i).volume (hŒ©' i).volume) :
    D[X ; hŒ©] = D[X' ; hŒ©'] :=


Theorem: multidist_ruzsa_III
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_III : 0 = 1 :=


Theorem: multidist_ruzsa_IV
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_IV : 0 = 1 :=


Theorem: cor_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cor_multiDist_chainRule : 0 = 1 :=


Theorem: kvm_ineq_III
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma kvm_ineq_III {I : Type*} {i‚ÇÄ : I} {s : Finset I} (hs : ¬¨ i‚ÇÄ ‚àà s) (hs' : Finset.Nonempty s)
    (Y : I ‚Üí Œ© ‚Üí G) (hY : (i : I) ‚Üí Measurable (Y i)) (hindep : iIndepFun (fun (i : I) => hG) Y Œº)
    (i‚ÇÅ : I) : d[Y i‚ÇÄ; Œº # ‚àë i in s, Y i; Œº]
      ‚â§ d[Y i‚ÇÄ; Œº # Y i‚ÇÅ; Œº] + (2:‚Ñù)‚Åª¬π * ‚àë i in s, (H[Y i; Œº] - H[Y i‚ÇÅ; Œº]) :=


Theorem: iter_multiDist_chainRule'
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule' : 0 = 1 :=


Theorem: multidist_ruzsa_I
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_I : 0 = 1 :=


Common Unproved sorry theorems: 0
