import json
import math

def calculate_difficulty(proof_steps):
    return math.exp(len(proof_steps))

file_path = "/raid/adarsh/datasets/pfr_6a5082ee465f9e44cea479c7b741b3163162bb7e/random/train.json"
with open(file_path, 'r') as file:
    data = json.load(file)

print(json.dumps(data[100], indent=2))
# {'url': 'https://github.com/teorth/pfr', 'commit': '6a5082ee465f9e44cea479c7b741b3163162bb7e', 'file_path': '.lake/packages/mathlib/Mathlib/Algebra/Ring/Subring/Basic.lean', 'full_name': 'Subring.closure_sUnion', 'start': [1024, 1], 'end': [1025, 27], 'traced_tactics': []}
# {'url': 'https://github.com/teorth/pfr', 'commit': '6a5082ee465f9e44cea479c7b741b3163162bb7e', 'file_path': '.lake/packages/mathlib/Mathlib/Order/BooleanAlgebra.lean', 'full_name': 'Bool.inf_eq_band', 'start': [831, 1], 'end': [832, 6], 'traced_tactics': []}
# 100 (1)
# {'url': 'https://github.com/teorth/pfr', 'commit': '6a5082ee465f9e44cea479c7b741b3163162bb7e', 'file_path': '.lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean', 'full_name': 'one_div_mul_one_div', 'start': [752, 1], 'end': [752, 71], 'traced_tactics': [{'tactic': 'simp', 'annotated_tactic': ['simp', []], 'state_before': 'Î± : Type u_1\nÎ² : Type u_2\nG : Type u_3\nM : Type u_4\ninstâœ : DivisionCommMonoid Î±\na b c d : Î±\nâŠ¢ 1 / a * (1 / b) = 1 / (a * b)', 'state_after': 'no goals'}]}
# 300 (8)
# {'url': 'https://github.com/teorth/pfr', 'commit': '6a5082ee465f9e44cea479c7b741b3163162bb7e', 'file_path': '.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Mul.lean', 'full_name': 'ContinuousLinearMap.opNorm_lsmul', 'start': [281, 1], 'end': [290, 26], 'traced_tactics': [{'tactic': "refine' ContinuousLinearMap.opNorm_eq_of_bounds zero_le_one (fun x => _) fun N _ h => _", 'annotated_tactic': ["refine' <a>ContinuousLinearMap.opNorm_eq_of_bounds</a> <a>zero_le_one</a> (fun x => _) fun N _ h => _", [{'full_name': 'ContinuousLinearMap.opNorm_eq_of_bounds', 'def_path': './.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean', 'def_pos': [180, 9], 'def_end_pos': [180, 28]}, {'full_name': 'zero_le_one', 'def_path': './.lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean', 'def_pos': [26, 15], 'def_end_pos': [26, 26]}]], 'state_before': "ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nâŠ¢ â€–lsmul ğ•œ ğ•œ'â€– = 1", 'state_after': "case refine'_1\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nx : ğ•œ'\nâŠ¢ â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ 1 * â€–xâ€–\n\ncase refine'_2\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\nâŠ¢ 1 â‰¤ N"}, {'tactic': 'obtain âŸ¨y, hyâŸ© := exists_ne (0 : E)', 'annotated_tactic': ['obtain âŸ¨y, hyâŸ© := <a>exists_ne</a> (0 : E)', [{'full_name': 'exists_ne', 'def_path': './.lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean', 'def_pos': [53, 9], 'def_end_pos': [53, 18]}]], 'state_before': "case refine'_2\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\nâŠ¢ 1 â‰¤ N", 'state_after': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nâŠ¢ 1 â‰¤ N"}, {'tactic': 'have := le_of_opNorm_le _ (h 1) y', 'annotated_tactic': ['have := <a>le_of_opNorm_le</a> _ (h 1) y', [{'full_name': 'ContinuousLinearMap.le_of_opNorm_le', 'def_path': './.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean', 'def_pos': [243, 9], 'def_end_pos': [243, 24]}]], 'state_before': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nâŠ¢ 1 â‰¤ N", 'state_after': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nthis : â€–((lsmul ğ•œ ğ•œ') 1) yâ€– â‰¤ N * â€–1â€– * â€–yâ€–\nâŠ¢ 1 â‰¤ N"}, {'tactic': 'simp_rw [lsmul_apply, one_smul, norm_one, mul_one] at this', 'annotated_tactic': ['simp_rw [<a>lsmul_apply</a>, <a>one_smul</a>, <a>norm_one</a>, <a>mul_one</a>] at this', [{'full_name': 'ContinuousLinearMap.lsmul_apply', 'def_path': '.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Mul.lean', 'def_pos': [212, 9], 'def_end_pos': [212, 20]}, {'full_name': 'one_smul', 'def_path': './.lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean', 'def_pos': [483, 9], 'def_end_pos': [483, 17]}, {'full_name': 'NormOneClass.norm_one', 'def_path': './.lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean', 'def_pos': [165, 3], 'def_end_pos': [165, 11]}, {'full_name': 'mul_one', 'def_path': './.lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean', 'def_pos': [480, 9], 'def_end_pos': [480, 16]}]], 'state_before': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nthis : â€–((lsmul ğ•œ ğ•œ') 1) yâ€– â‰¤ N * â€–1â€– * â€–yâ€–\nâŠ¢ 1 â‰¤ N", 'state_after': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nthis : â€–yâ€– â‰¤ N * â€–yâ€–\nâŠ¢ 1 â‰¤ N"}, {'tactic': "refine' le_of_mul_le_mul_right _ (norm_pos_iff.mpr hy)", 'annotated_tactic': ["refine' <a>le_of_mul_le_mul_right</a> _ (norm_pos_iff.mpr hy)", [{'full_name': 'le_of_mul_le_mul_right', 'def_path': './.lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean', 'def_pos': [236, 9], 'def_end_pos': [236, 31]}]], 'state_before': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nthis : â€–yâ€– â‰¤ N * â€–yâ€–\nâŠ¢ 1 â‰¤ N", 'state_after': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nthis : â€–yâ€– â‰¤ N * â€–yâ€–\nâŠ¢ 1 * â€–yâ€– â‰¤ N * â€–yâ€–"}, {'tactic': 'simp_rw [one_mul, this]', 'annotated_tactic': ['simp_rw [<a>one_mul</a>, this]', [{'full_name': 'one_mul', 'def_path': './.lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean', 'def_pos': [474, 9], 'def_end_pos': [474, 16]}]], 'state_before': "case refine'_2.intro\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nN : â„\nxâœ : N â‰¥ 0\nh : âˆ€ (x : ğ•œ'), â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ N * â€–xâ€–\ny : E\nhy : y â‰  0\nthis : â€–yâ€– â‰¤ N * â€–yâ€–\nâŠ¢ 1 * â€–yâ€– â‰¤ N * â€–yâ€–", 'state_after': 'no goals'}, {'tactic': 'rw [one_mul]', 'annotated_tactic': ['rw [<a>one_mul</a>]', [{'full_name': 'one_mul', 'def_path': './.lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean', 'def_pos': [474, 9], 'def_end_pos': [474, 16]}]], 'state_before': "case refine'_1\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nx : ğ•œ'\nâŠ¢ â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ 1 * â€–xâ€–", 'state_after': "case refine'_1\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nx : ğ•œ'\nâŠ¢ â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ â€–xâ€–"}, {'tactic': 'apply opNorm_lsmul_apply_le', 'annotated_tactic': ['apply <a>opNorm_lsmul_apply_le</a>', [{'full_name': 'ContinuousLinearMap.opNorm_lsmul_apply_le', 'def_path': '.lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Mul.lean', 'def_pos': [228, 9], 'def_end_pos': [228, 30]}]], 'state_before': "case refine'_1\nğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nc : ğ•œ\nğ•œ' : Type u_3\ninstâœâ´ : NormedField ğ•œ'\ninstâœÂ³ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ² : NormedSpace ğ•œ' E\ninstâœÂ¹ : IsScalarTower ğ•œ ğ•œ' E\ninstâœ : Nontrivial E\nx : ğ•œ'\nâŠ¢ â€–(lsmul ğ•œ ğ•œ') xâ€– â‰¤ â€–xâ€–", 'state_after': 'no goals'}]}


for item in data[:5]:
    proof_steps = item['traced_tactics']
    difficulty = calculate_difficulty(proof_steps)
    print(f"Theorem: {item['full_name']}")
    print(f"Number of proof steps: {len(proof_steps)}")
    print(f"Difficulty: {difficulty:.2f}")
    print("---")

ranked_theorems = sorted(data, key=lambda x: calculate_difficulty(x['traced_tactics']), reverse=True)

print("Top 10 most difficult theorems:")
for i, theorem in enumerate(ranked_theorems[:10], 1):
    difficulty = calculate_difficulty(theorem['traced_tactics'])
    print(f"{i}. {theorem['file_path']} {theorem['full_name']} (Difficulty: {difficulty:.2f})")
