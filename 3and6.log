2024-09-20 15:39:56.662 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:39:56.664 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:40:04.624 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:40:04.624 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:40:14.222 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:40:14.222 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:40:24.496 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-20 15:40:24.497 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-20 15:40:37.493 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:40:37.494 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:40:39.281 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 15:40:39.281 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 15:40:52.382 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 15:40:52.382 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 15:40:52.538 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 15:40:52.539 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 15:40:54.266 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 15:40:54.267 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 15:40:56.299 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 15:40:56.299 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 15:40:56.678 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 15:40:56.678 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 15:41:10.287 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 15:41:10.287 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 15:41:10.442 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 15:41:10.442 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 15:41:10.537 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-20 15:41:10.537 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-20 15:41:11.314 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 15:41:11.314 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 15:41:11.630 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-20 15:41:11.630 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-20 15:42:07.152 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:42:07.152 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-20 15:42:09.155 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:42:09.156 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-20 15:42:11.218 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:42:11.219 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-20 15:42:30.219 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-20 15:42:30.219 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-20 15:42:34.099 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:42:34.100 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-20 15:42:35.990 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 15:42:35.991 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-20 15:42:58.118 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 15:42:58.119 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-20 15:42:58.272 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 15:42:58.273 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-20 15:43:00.066 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 15:43:00.066 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-20 15:43:02.041 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 15:43:02.041 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-20 15:43:02.684 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 15:43:02.684 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-20 15:43:03.058 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 15:43:03.059 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-20 15:43:03.208 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 15:43:03.209 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-20 15:43:03.950 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 15:43:03.950 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-20 15:43:04.274 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-20 15:43:04.274 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
================================================================================

Proved sorry theorems only in first database: 4

Theorem: SciLean.scalar_max_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_zero_one  : max (0 : R) (1 : R) = 1 :=
Proof:
  rw [max_comm]
  simp


Theorem: SciLean.normâ‚‚_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem normâ‚‚_scalar {R} [RealScalar R] (x : R) :
  â€–xâ€–â‚‚[R] = Scalar.abs x :=
Proof:
  rw [SciLean.scalar_norm]


Theorem: Function.invFun.id_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem id_rule
  : invFun (fun (x : X) => x)
    =
    fun x => x :=
Proof:
  apply Function.invFun_comp
  exact Function.injective_id


Theorem: SciLean.Distribution.action_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.action_iteD (A : Set X) (t e : ð’Ÿ'(X,Y)) (Ï† : ð’Ÿ X) :
   iteD A t e Ï† =
        t.extAction (fun x => if x âˆˆ A then Ï† x else 0) (fun y âŠ¸ fun r âŠ¸ r â€¢ y) +
        e.extAction (fun x => if x âˆ‰ A then Ï† x else 0) (fun y âŠ¸ fun r âŠ¸ r â€¢ y) :=
Proof:
  aesop


Proved sorry theorems only in second database: 4

Theorem: Function.Bijective.Equiv.invFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.invFun.arg_a0.Bijective_rule (f : Y â‰ƒ Z) (g : X â†’ Z) (hf : Bijective g)
  : Bijective (fun x => f.invFun (g x)) :=
Proof:
  convert hf
  simp [hf]
  exact f.symm.bijective.comp hf


Theorem: SciLean.CDifferentiable.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.id_rule
  : CDifferentiable K (fun x : X => x)
  :=
Proof:
  intro x
  rw [CDifferentiableAt]
  tauto


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple'
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple'
  : Bijective (fun xy : XÃ—Y => (xy.2, xy.1))
  :=
Proof:
  constructor <;> intro h
  all_goals aesop


Theorem: SciLean.CDifferentiable.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.comp_rule
  (f : Y â†’ Z) (g : X â†’ Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f (g x))
  :=
Proof:
  intro x
  dsimp [CDifferentiable] at *
  have := hg x
  fun_prop


Common Proved sorry theorems: 18

Theorem: SciLean.ite_pull_measureOf
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_measureOf {X} [MeasurableSpace X] (c : Prop) [Decidable c] (Î¼ Î½ : Measure X) (A : Set X) :
    (if c then Î¼ else Î½) A
    =
    (if c then Î¼ A else Î½ A) :=

Proof:
  split_ifs <;> rfl
Proofs are identical in both databases.


Theorem: SciLean.ite_pull_ennreal_toReal
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_ennreal_toReal (c : Prop) [Decidable c] (x y : ENNReal)  :
    (if c then x else y).toReal
    =
    (if c then x.toReal else y.toReal) :=

Proof:
  split_ifs <;> rfl
Proofs are identical in both databases.


Theorem: IsLinearMap.isLinearMap_const_zero
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_const_zero
  : IsLinearMap R (fun _ : X => (0 : Y))
  :=

Proof:
  constructor
  all_goals aesop
Proofs are identical in both databases.


Theorem: SciLean.SmoothLinearMap.zero_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.zero_apply : (0 : XâŠ¸[K]Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffAt.id_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.id_rule (x : X) :
    ContCDiffAt K n (fun x : X => x) x :=

Proof:
  unfold SciLean.ContCDiffAt
  tauto
Proofs differ:
Proof in second database:
  rw [ContCDiffAt]
  tauto


Theorem: SciLean.re_float
File path: SciLean/Core/FloatAsReal.lean
Theorem statement: theorem re_float  (a : Float)
  : RCLike.re a = a :=

Proof:
  exact RCLike.re_eq_self_of_le le_rfl
Proofs differ:
Proof in second database:
  rw [RCLike.ext_iff]
  exact âŸ¨rfl, rflâŸ©


Theorem: SciLean.Measure.prod_volume
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_volume {X Y} [MeasureSpace X] [MeasureSpace Y]  :
    (Measure.prod (volume : Measure X) (volume : Measure Y)) = volume :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.scalar_div_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_div_one (x : R) : x / 1 = x :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffMap.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap.zero_apply : (0 : X âŸ¿[K,n] Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: IsLinearMap.isLinearMap_apply
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_apply (i : Î¹) : IsLinearMap R (fun f : (i : Î¹) â†’ E i â†¦ f i) :=

Proof:
  constructor
  all_goals aesop
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffMapFD.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD.zero_apply : (0 : X âŸ¿FD[K,n] Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.scalar_min_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_zero_one  : min (0 : R) (1 : R) = 0 :=

Proof:
  rw [min_comm]
  simp
Proofs differ:
Proof in second database:
  symm
  rw [min_comm]
  simp


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple
  : Bijective (fun xy : XÃ—Y => (xy.1, xy.2))
  :=

Proof:
  simp
  exact Function.bijective_id
Proofs differ:
Proof in second database:
  constructor <;> intro h
  all_goals aesop


Theorem: SciLean.CDifferentiableAt.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.id_rule (x : X)
  : CDifferentiableAt K (fun x : X => x) x
  :=

Proof:
  unfold SciLean.CDifferentiableAt
  tauto
Proofs differ:
Proof in second database:
  rw [CDifferentiableAt]
  tauto


Theorem: IsAffineMap.IsAffineMap_apply
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_apply (i : Î¹) : IsAffineMap R (fun f : (i : Î¹) â†’ E i â†¦ f i) :=

Proof:
  constructor
  constructor
  simp
  simp
Proofs are identical in both databases.


Theorem: Function.Bijective.Equiv.toFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.toFun.arg_a0.Bijective_rule (f : Y â‰ƒ Z) (g : X â†’ Y) (hf : Bijective g)
  : Bijective (fun x => f (g x)) :=

Proof:
  inhabit Z
  exact f.bijective.comp hf
Proofs differ:
Proof in second database:
  convert hf
  constructor
  exact fun _ => hf
  intro
  exact f.bijective.comp hf


Theorem: SciLean.ContCDiffAt.comp_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.comp_rule (x : X)
    (f : Y â†’ Z) (g : X â†’ Y)
    (hf : ContCDiffAt K n f (g x)) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f (g x)) x :=

Proof:
  rw [ContCDiffAt] at *
  aesop
Proofs are identical in both databases.


Theorem: SciLean.CDifferentiableAt.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.comp_rule
  (f : Y â†’ Z) (g : X â†’ Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : CDifferentiableAt K (fun x => f (g x)) x
  :=

Proof:
  rw [CDifferentiableAt] at *
  aesop
Proofs are identical in both databases.


================================================================================
Comparing Proved sorry theorems for repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
================================================================================

Proved sorry theorems only in first database: 1

Theorem: condRho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_translate {Î© S : Type*} [MeasureSpace Î©] (X : Î© â†’ G) (Y : Î© â†’ S) (A : Finset G) (s:G) : condRho (fun Ï‰ â†¦ X Ï‰ + s) Y A = condRho X Y A :=
Proof:
  simp only [condRho, rho_of_translate]


Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
================================================================================

Proved sorry theorems only in first database: 4

Theorem: C03S05.MyAbs.neg_le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem neg_le_abs_self (x : â„) : -x â‰¤ |x| :=
Proof:
  simpa using C03S05.MyAbs.le_abs_self (-x)


Theorem: C03S05.MyAbs.abs_add
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem abs_add (x y : â„) : |x + y| â‰¤ |x| + |y| :=
Proof:
  apply abs_add_le


Theorem: MyRing.zero_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem zero_mul (a : R) : 0 * a = 0 :=
Proof:
  rw [MulZeroClass.zero_mul]


Theorem: MyRing.add_right_cancel
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_right_cancel {a b c : R} (h : a + b = c + b) : a = c :=
Proof:
  simpa using h


Proved sorry theorems only in second database: 2

Theorem: MyRing.self_sub
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem self_sub (a : R) : a - a = 0 :=
Proof:
  simp


Theorem: C03S04.aux
File path: MIL/C03_Logic/S04_Conjunction_and_Iff.lean
Theorem statement: None
Proof:
  contrapose! h
  positivity


Common Proved sorry theorems: 10

Theorem: absorb2
File path: MIL/C02_Basics/S05_Proving_Facts_about_Algebraic_Structures.lean
Theorem statement: theorem absorb2 : x âŠ” x âŠ“ y = x :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyRing.neg_neg
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem neg_neg (a : R) : - -a = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyGroup.mul_right_inv
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_right_inv (a : G) : a * aâ»Â¹ = 1 :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyRing.add_neg_cancel_right
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_neg_cancel_right (a b : R) : a + b + -b = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyRing.add_left_cancel
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_left_cancel {a b c : R} (h : a + b = a + c) : b = c :=

Proof:
  simpa using h
Proofs are identical in both databases.


Theorem: MyRing.neg_eq_of_add_eq_zero
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem neg_eq_of_add_eq_zero {a b : R} (h : a + b = 0) : -a = b :=

Proof:
  rw [add_eq_zero_iff_eq_neg] at h
  simp [h]
Proofs differ:
Proof in second database:
  rw [â† sub_eq_zero]
  rw [â† neg_zero, â† h]
  abel


Theorem: MyRing.eq_neg_of_add_eq_zero
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem eq_neg_of_add_eq_zero {a b : R} (h : a + b = 0) : a = -b :=

Proof:
  rwa [eq_neg_iff_add_eq_zero]
Proofs are identical in both databases.


Theorem: absorb1
File path: MIL/C02_Basics/S05_Proving_Facts_about_Algebraic_Structures.lean
Theorem statement: theorem absorb1 : x âŠ“ (x âŠ” y) = x :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyGroup.mul_one
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_one (a : G) : a * 1 = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyGroup.mul_inv_rev
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_inv_rev (a b : G) : (a * b)â»Â¹ = bâ»Â¹ * aâ»Â¹ :=

Proof:
  simp
Proofs are identical in both databases.


================================================================================
Comparing Proved sorry theorems for repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0
Repository https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab) not found in the second database.

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
================================================================================

Unproved sorry theorems only in first database: 4

Theorem: Function.Bijective.Equiv.invFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.invFun.arg_a0.Bijective_rule (f : Y â‰ƒ Z) (g : X â†’ Z) (hf : Bijective g)
  : Bijective (fun x => f.invFun (g x)) :=


Theorem: SciLean.CDifferentiable.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.id_rule
  : CDifferentiable K (fun x : X => x)
  :=


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple'
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple'
  : Bijective (fun xy : XÃ—Y => (xy.2, xy.1))
  :=


Theorem: SciLean.CDifferentiable.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.comp_rule
  (f : Y â†’ Z) (g : X â†’ Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f (g x))
  :=


Unproved sorry theorems only in second database: 4

Theorem: SciLean.scalar_max_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_zero_one  : max (0 : R) (1 : R) = 1 :=


Theorem: SciLean.normâ‚‚_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem normâ‚‚_scalar {R} [RealScalar R] (x : R) :
  â€–xâ€–â‚‚[R] = Scalar.abs x :=


Theorem: Function.invFun.id_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem id_rule
  : invFun (fun (x : X) => x)
    =
    fun x => x :=


Theorem: SciLean.Distribution.action_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.action_iteD (A : Set X) (t e : ð’Ÿ'(X,Y)) (Ï† : ð’Ÿ X) :
   iteD A t e Ï† =
        t.extAction (fun x => if x âˆˆ A then Ï† x else 0) (fun y âŠ¸ fun r âŠ¸ r â€¢ y) +
        e.extAction (fun x => if x âˆ‰ A then Ï† x else 0) (fun y âŠ¸ fun r âŠ¸ r â€¢ y) :=


Common Unproved sorry theorems: 268

Theorem: SciLean.Rand.add_as_flip_E
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem add_as_flip_E {x y : X} (Î¸ : R) (h : Î¸ âˆˆ Set.Ioo 0 1) :
    x + y = (flip Î¸).ð”¼ (fun b => if b then Î¸â»Â¹ â€¢ x else (1-Î¸)â»Â¹ â€¢ y) :=



Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.semiAdjoint_rule
  (c : K) (f : X â†’ K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => c * f x)
    =
    fun y => conj c â€¢ semiAdjoint K (fun x => f x) y :=



Theorem: IsAffineMap.IsAffineMap_comp
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_comp {f : Y â†’ Z} {g : X â†’ Y}
    (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R (fun x â†¦ f (g x)) :=



Theorem: SciLean.semiAdjoint.const_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem const_rule : semiAdjoint K (fun (_ : X) => (0 : Y)) = fun x => 0 :=



Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
    (c : â„•) (f : X â†’ Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c â€¢ f x) x :=



Theorem: IndexType.sum.arg_f.revDerivProjUpdate_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProjUpdate_rule [DecidableEq Î¹]
    (f : X â†’ Î¹ â†’ Y') (hf : âˆ€ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProjUpdate K Yi (fun x => âˆ‘ i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Î¹Ã—Yi) f x
      (âˆ‘ i, ydf.1 i,
       fun j dy dx =>
         Fold.fold (IndexType.univ Î¹) (fun dx i => ydf.2 (i,j) dy dx) dx) :=



Theorem: SciLean.cintegral.arg_f.parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem cintegral.arg_f.parDistribDeriv_rule (f : W â†’ X â†’ Y â†’ Z) :
    parDistribDeriv (fun w => (fun x => âˆ«' y, f w x y).toDistribution (R:=R))
    =
    fun w dw =>
      let Tf := (fun w => (fun x => (fun y => f w x y).toDistribution (R:=R)).toDistribution (R:=R))
      parDistribDeriv Tf w dw |>.postComp (fun T âŠ¸ T.extAction (fun _ => (1:R)) (fun z âŠ¸ fun r âŠ¸ r â€¢ z)) :=



Theorem: SciLean.parametric_inverse_affine
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine {n} (f : X â†’ R) (c : R) (hf : IsAffineMap R f)
    (hn : n + 1 = card Î¹ := by first | assumption | infer_var) :
    let u  := âˆ‡ f 0
    let dec := planeDecomposition (R:=R) u hn
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / â€–uâ€–â‚‚)
      (dom := fun _ => âŠ¤) :=



Theorem: SciLean.Basis.proj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => â„¼ i x) x :=



Theorem: SciLean.odeSolve.arg_xâ‚€.revCDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_xâ‚€.revCDeriv_rule
  (f : R â†’ X â†’ X) (tâ‚€ t : R) (xâ‚€ : W â†’ X)
  (hf : HasAdjDiff R (fun (t,x) => f t x))
  (hx : HasAdjDiff R xâ‚€)
  : revDeriv R (fun w => odeSolve f tâ‚€ t (xâ‚€ w))
    =
    fun w =>
      let xâ‚€dxâ‚€ := revDeriv R xâ‚€ w
      let x := fun s => odeSolve f tâ‚€ s xâ‚€dxâ‚€.1
      let dfdx := fun s dx' => - gradient R (fun x' => f s x') (x s) dx'
      (x t,
       fun dx =>
         let dx := odeSolve dfdx tâ‚€ t dx
         xâ‚€dxâ‚€.2 dx) :=



Theorem: SciLean.HSub.hSub.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a1.cderiv_rule
    (f : X â†’ Y) (y : Y) :
    (cderiv K fun x => y - f x)
    =
    fun x dx =>
      - cderiv K f x dx :=



Theorem: SciLean.Basis.proj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => â„¼ i x) :=



Theorem: SciLean.split_integral_over_set_of_ite
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem split_integral_over_set_of_ite (Ï† Ïˆ : X â†’ R) (f g : X â†’ Y) (A : Set X) :
    (âˆ«' x in A, if Ïˆ x â‰¤ Ï† x then f x else g x)
    =
    (âˆ«' x in {x' | 0 â‰¤ Ï† x' - Ïˆ x'} âˆ© A, f x)
    +
    (âˆ«' x in {x' | 0 â‰¤ Ïˆ x' - Ï† x'} âˆ© A, g x) :=



Theorem: SciLean.cintegral.arg_f.IsLinearMap_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.IsLinearMap_rule
    (f : X â†’ Î² â†’ Z) (Î¼ : Measure Î²) (hf : âˆ€ y, IsLinearMap R (f Â· y)) :
    IsLinearMap R (fun x => âˆ«' y, f x y âˆ‚Î¼) :=



Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule (f : X â†’ K) (g : X â†’ K)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) (hx : âˆ€ x, g x â‰  0) :
    (cderiv K fun x => f x / g x)
    =
    fun x =>
      let k := f x
      let k' := g x
      fun dx =>
        ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=



Theorem: SciLean.BasisDuality.toDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.ContCDiffAt.apply_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.apply_rule
    (i : Î¹) (x) : ContCDiffAt K n (fun x : (i : Î¹) â†’ E i => x i) x :=



Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
    (c : â„¤) (f : X â†’ Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c â€¢ f x) x :=



Theorem: SciLean.cintegral.arg_f.CDifferentiable_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.CDifferentiable_rule
    (f : X â†’ Î² â†’ Z) (Î¼ : Measure Î²) (hf : âˆ€ x, CDifferentiable R (f Â· x)) :
    CDifferentiable R (fun x => âˆ«' y, f x y âˆ‚Î¼) :=



Theorem: SciLean.Inner.inner.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Inner.inner.arg_a0a1.ContCDiffAt_rule
    (f : X â†’ Y) (g : X â†’ Y) (x : X)
    (hf : ContCDiffAt R n f x) (hg : ContCDiffAt R n g x) :
    ContCDiffAt R n (fun x => âŸªf x, g xâŸ«[R]) x :=



Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X â†’ Y) (y : Y)
  (hf : Bijective f)
  : Bijective (fun x => f x / y) :=



Theorem: SciLean.Prod.fst.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.fst.arg_self.CDifferentiable_rule
  (f : X â†’ YÃ—Z) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).1)  :=



Theorem: SciLean.cderiv.comp_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule_at
  (f : Y â†’ Z) (g : X â†’ Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : (cderiv K fun x : X => f (g x)) x
    =
    let y := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K f y dy
      dz :=



Theorem: SciLean.Rand.mean_add
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add  (x : Rand X) (x' : X) : x.mean + x' = (x  + x').mean :=



Theorem: SciLean.HasSemiAdjoint.const_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem const_rule : HasSemiAdjoint K (fun _ : X => (0:Y)) :=



Theorem: SciLean.scalar_sqrt_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_one  : Scalar.sqrt (1 : R) = 1 :=



Theorem: SciLean.HAdd.hAdd.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.cderiv_rule
    (f : X â†’ Y) (y : Y) :
    (cderiv K fun x => f x + y)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: SciLean.HasSemiAdjoint.HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule [ContinuousAdd Y]
    (f g : X â†’ Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x + g x :=



Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule_at (x : X) (f : X â†’ K) (g : X â†’ K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) (hx : g x â‰  0) :
    (cderiv K fun x => f x / g x) x
    =
    let k := f x
    let k' := g x
    fun dx =>
      ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=



Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_group
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_group
  [Group Y]
  (f : X â†’ Y) (hf : Bijective f)
  : invFun (fun x => (f x)â»Â¹)
    =
    fun y =>
      invFun f (yâ»Â¹)
  :=



Theorem: SciLean.Distribution.indextype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.indextype_sum_extAction {I} [IndexType I] (T : I â†’ ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W) :
    (âˆ‘ i, T i).extAction Ï† L = âˆ‘ i, (T i).extAction Ï† L :=



Theorem: SciLean.HasSemiAdjoint.apply_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem apply_rule (i : Î¹) :
    HasSemiAdjoint K (fun x : (i : Î¹) â†’ E i => x i) :=



Theorem: SciLean.SciLean.normâ‚‚.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem SciLean.normâ‚‚.arg_x.CDifferentiable_rule
  (f : X â†’ Y) (hf : CDifferentiable R f) (hx : f xâ‰ 0)
  : CDifferentiable R (fun x => â€–f xâ€–â‚‚[R]) :=



Theorem: Set.HSub.hSub.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' - x) (Ioo a b)
    =
    Ioo (x' - b) (x' - a) :=



Theorem: SciLean.ContCDiffMapFD_eta
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eta (f : X âŸ¿FD[K,n] Y) : (fun x âŸ¿FD[K,n] f x) = f :=



Theorem: SciLean.scalar_abs_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_zero : Scalar.abs (0 : R) = 0 :=



Theorem: SciLean.normâ‚‚_squared_nat
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem normâ‚‚_squared_nat {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : â€–xâ€–â‚‚[K] ^ 2 = â€–xâ€–â‚‚Â²[K] :=



Theorem: SciLean.normâ‚‚.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem normâ‚‚.arg_x.ContCDiffAt_rule
    (f : X â†’ Y) (x : X)
    (hf : ContCDiffAt R n f x) (hx : f xâ‰ 0) :
    ContCDiffAt R n (fun x => â€–f xâ€–â‚‚[R]) x :=



Theorem: SciLean.DualBasis.dualProj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => â„¼' i x) :=



Theorem: SciLean.Rand.E_smul
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem E_smul (r : Rand X) (Ï† : X â†’ â„) (y : Y) :
    r.ð”¼ (fun x' => Ï† x' â€¢ y) = r.ð”¼ Ï† â€¢ y :=



Theorem: SciLean.Distribution.neg_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.neg_extAction (T : ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W) :
    (- T).extAction Ï† L = - T.extAction Ï† L :=



Theorem: SciLean.Neg.neg.arg_a0.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiff_rule
    (f : X â†’ Y) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => - f x) :=



Theorem: SciLean.ContCDiffMap_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X âŸ¿[K,n] Y)Ã—X) => fx.1 fx.2) :=



Theorem: SciLean.BasisDuality.toDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.toDual x) :=



Theorem: IsLinearMap.sum_push
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_push
  {f : X â†’ Y} (hf : IsLinearMap K f)
  (Î¹ : Type) [IndexType.{_,u} Î¹] [IndexType.{_,v} Î¹] (x : Î¹ â†’ X)
  : (âˆ‘ i, f (x i)) = f (âˆ‘ i, x i) :=



Theorem: IsLinearMap.isLinearMap_pi
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_pi (f : X â†’ (i : Î¹) â†’ E i) (hf : âˆ€ i, IsLinearMap R (f Â· i)) :
    IsLinearMap R (fun x i â†¦ f x i) :=



Theorem: SciLean.Distribution.sub_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.sub_extAction (T T' : ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W) :
    (T - T').extAction Ï† L = T.extAction Ï† L - T'.extAction Ï† L :=



Theorem: SciLean.Distribution.extAction_iteD'
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD' (A B : Set X) (t e : ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W) :
    ((iteD A t e).restrict B).extAction Ï† L =
        (t.restrict B).extAction (fun x => if x âˆˆ A then Ï† x else 0) L +
        (e.restrict B).extAction (fun x => if x âˆ‰ A then Ï† x else 0) L :=



Theorem: SciLean.semiAdjoint.comp_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem comp_rule
  (f : Y â†’ Z) (g : X â†’ Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => f (g x))
    =
    fun z =>
      let y := semiAdjoint K f z
      let x := semiAdjoint K g y
      x :=



Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_group
  [Group Y]
  (y : Y) (f : X â†’ Y) (hf : Bijective f)
  : Bijective (fun x => y * f x)
  :=



Theorem: SciLean.Bind.bind.arg_fx.DistribDifferentiable_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem Bind.bind.arg_fx.DistribDifferentiable_rule
    (f : X â†’ Y â†’ ð’Ÿ'(Z,V)) (g : X â†’ ð’Ÿ'(Y,U)) (L : U âŠ¸ V âŠ¸ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun x => (g x).bind (f x) L) :=



Theorem: SciLean.HMul.hMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HMul.hMul.arg_a0a1.cderiv_rule_at (x : X) (f g : X â†’ K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x * g x) x
    =
    let fx := f x
    let gx := g x
    fun dx =>
      (cderiv K g x dx) * fx + (cderiv K f x dx) * gx :=



Theorem: SciLean.SciLean.normâ‚‚.arg_x.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.normâ‚‚.arg_x.cderiv_rule_at
  (f : X â†’ Y) (x : X)
  (hf : CDifferentiableAt R f x) (hx : f xâ‰ 0)
  : cderiv R (fun x => â€–f xâ€–â‚‚[R]) x
    =
    fun dx =>
      let y := f x
      let dy := cderiv R f x dx
      â€–yâ€–â‚‚[R]â»Â¹ * âŸªdy,yâŸ«[R] :=



Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => â„¼' i x) :=



Theorem: SciLean.CDifferentiable.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.pi_rule
  (f : X â†’ (i : Î¹) â†’ E i)
  (hf : âˆ€ i, CDifferentiable K (f Â· i))
  : CDifferentiable K (fun x i => f x i)
  :=



Theorem: Set.HAdd.hAdd.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' + x) (Ioo a b)
    =
    Ioo (a - x') (b - x') :=



Theorem: SciLean.semiAdjoint.Inner.inner.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X â†’ Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => âŸªy, f xâŸ«[K])
    =
    fun z => z â€¢ semiAdjoint K f y :=



Theorem: SciLean.decomposeSolution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decomposeSolution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys â†’ Zs â†’ Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs â†’ Prop)       (Qâ‚ : Ys â†’ Zs â†’ Prop) (Qâ‚‚ : Ys â†’ Zs â†’ Prop) (equiv : âˆ€ ys zs, (Qâ‚ ys zs âˆ§ Qâ‚‚ ys zs) â†” P (f ys zs))
  (unique : âˆ€ ys, HasUniqueSolution (Qâ‚ ys))
  : (solve xs, P xs)
    =
    let zs' := fun ys => (solve zs, Qâ‚ ys zs)
    let ys  := solve ys, Qâ‚‚ ys (zs' ys)
    let zs  := zs' ys
    f ys zs
  :=



Theorem: Function.invFun.comp_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem comp_rule
  (f : Y â†’ Z) (g : X â†’ Y)
  (hf : Bijective f) (hg : Bijective g)
  : invFun (fun x => f (g x))
    =
    fun z =>
      let y := invFun f z
      let x := invFun g y
      x :=



Theorem: SciLean.odeSolve.arg_ftâ‚€txâ‚€.fwdDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_ftâ‚€txâ‚€.fwdDeriv_rule
  (f : W â†’ R â†’ X â†’ X) (tâ‚€ t : W â†’ R) (xâ‚€ : W â†’ X)
  (hf : CDifferentiable R (fun (w,t,x) => f w t x))
  (htâ‚€ : CDifferentiable R tâ‚€) (ht : CDifferentiable R t)
  (hx : CDifferentiable R xâ‚€)
  : fwdDeriv R (fun w => odeSolve (f w) (tâ‚€ w) (t w) (xâ‚€ w))
    =
    fun w dw =>
      let tâ‚€dtâ‚€ := fwdDeriv R tâ‚€ w dw
      let tdt   := fwdDeriv R tâ‚€ w dw
      let xâ‚€dxâ‚€ := fwdDeriv R xâ‚€ w dw
      let Tf := fwdDeriv R (fun wkx : WÃ—RÃ—X => f wkx.1 wkx.2.1 wkx.2.2)

      let F := fun (t : R) (xdx : XÃ—X) =>
        let x  := xdx.1
        let dx := xdx.2
        Tf (w,t,x) (dw,tâ‚€dtâ‚€.2,dx)

      let xdx := odeSolve F (tâ‚€dtâ‚€.1) (tdt.1) xâ‚€dxâ‚€

      (xdx.1, xdx.2 + tdt.2 â€¢ f w tdt.1 xdx.1) :=



Theorem: SciLean.HasSemiAdjoint.HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
  (f : X â†’ K) (hf : HasSemiAdjoint K f) (y : K)
  : HasSemiAdjoint K fun x => f x / y :=



Theorem: SciLean.HasSemiAdjoint.pi_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem pi_rule
    (f : X â†’ (i : Î¹) â†’ E i) (hf : âˆ€ i, HasSemiAdjoint K (f Â· i)) :
    HasSemiAdjoint K (fun x i => f x i) :=



Theorem: SciLean.Prod.snd.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiffAt_rule (x : X)
    (f : X â†’ YÃ—Z) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).2) x :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.semiAdjoint.SciLean.semiAdjoint.arg_y.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.semiAdjoint_rule
  (f : X â†’ Y) (a3 : W â†’ Y) (hf : HasSemiAdjoint K f) (ha3 : HasSemiAdjoint K a3)
  : semiAdjoint K (fun w => semiAdjoint K f (a3 w))
    =
    fun x =>
      let y := f x
      semiAdjoint K a3 y :=



Theorem: SciLean.fderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/FDeriv.lean
Theorem statement: theorem fderiv.apply_rule (i : Î¹) :
    (fderiv K fun (x : (i : Î¹) â†’ E i) => x i)
    =
    fun _ => fun dx =>L[K] dx i :=



Theorem: SciLean.HasSemiAdjoint.Neg.neg.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.HasSemiAdjoint_rule
    (f : X â†’ Y) : HasSemiAdjoint K fun x => - f x :=



Theorem: Function.invFun.Neg.neg.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Neg.neg.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X â†’ Y) (hf : Bijective f)
  : invFun (fun x => - f x)
    =
    fun y =>
      invFun f (-y)
  :=



Theorem: SciLean.semiAdjoint.Prod.snd.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.semiAdjoint_rule
  (f : X â†’ YÃ—Z) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).2)
    =
    (fun z => semiAdjoint K f (0,z)) :=



Theorem: SciLean.odeSolve.arg_xâ‚€.semiAdjoint_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_xâ‚€.semiAdjoint_rule
  (f : R â†’ X â†’ X) (tâ‚€ t : R) (xâ‚€ : W â†’ X)
  (hf : âˆ€ t, HasSemiAdjoint R (f t)) (hxâ‚€ : HasSemiAdjoint R xâ‚€)
  : semiAdjoint R (fun w => odeSolve f tâ‚€ t (xâ‚€ w))
    =
    fun xâ‚€' =>
      let f' := (fun s y => - semiAdjoint R (f s) y)
      let y := odeSolve f' t tâ‚€ xâ‚€'
      semiAdjoint R xâ‚€ y :=



Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.HasSemiAdjoint_rule
  (f : X â†’ Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => âŸªf x, yâŸ«[K] :=



Theorem: SciLean.ContCDiffMap_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X âŸ¿[K,âˆž] Y)Ã—X) => fx.1 fx.2) :=



Theorem: SciLean.gaussian.arg_Î¼Ïƒx.CDifferentiableAt_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_Î¼Ïƒx.CDifferentiableAt_rule (w : W)
    (Î¼ : W â†’ U) (Ïƒ : W â†’ R) (x : W â†’ U)
    (hÎ¼ : CDifferentiableAt R Î¼ w) (hÏƒ : CDifferentiableAt R Ïƒ w) (hx : CDifferentiableAt R x w)
    (hÏƒ' : Ïƒ w â‰  0) :
    CDifferentiableAt R (fun w => gaussian (Î¼ w) (Ïƒ w) (x w)) w :=



Theorem: SciLean.revDerivUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X â†’ (i : I) â†’ EI i) (hf : âˆ€ i, HasAdjDiff K (f Â· i)) :
    (revDerivUpdate K fun (x : X) (i : I) => f x i)
    =
    fun x =>
      let xdf := fun i => revDerivUpdate K (f Â· i) x
      (fun i => (xdf i).1,
       fun dy dx =>
         Fold.fold (IndexType.univ I) (fun dx i => (xdf i).2 (dy i) dx) dx) :=



Theorem: SciLean.normâ‚‚_squared
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem normâ‚‚_squared {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : â€–xâ€–â‚‚[K] ^ (2:K) = â€–xâ€–â‚‚Â²[K] :=



Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_field
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_field
  [Field Y]
  (f : X â†’ Y) (hf : Bijective f) (hf' : âˆ€ x, f x â‰  0)
  : invFun (fun x => (f x)â»Â¹)
    =
    fun y =>
      invFun f (yâ»Â¹)
  :=



Theorem: SciLean.Rand.flip.integral
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.integral (Î¸ : R) (f : Bool â†’ X) :
    âˆ«' x, f x âˆ‚(flip Î¸).â„™ = Î¸ â€¢ f true + (1-Î¸) â€¢ f false :=



Theorem: Function.Bijective.HSub.hSub.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X â†’ Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x - y
  :=



Theorem: SciLean.Distribution.iteD_same
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.iteD_same (A : Set X) (u : ð’Ÿ'(X,Y)) :
   iteD A u u = u :=



Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule_at (x : X)
    (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, CDifferentiableAt K (f Â· i) x) :
    fwdDeriv K (fun x => âˆ‘ i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdDeriv K (f Â· i) x dx
      âˆ‘ i, ydy i :=



Theorem: SciLean.semiAdjoint.Finset.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.semiAdjoint_rule {Î¹ : Type _} [Fintype Î¹]
  (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, HasSemiAdjoint K (f Â· i))
  : semiAdjoint K (fun x => âˆ‘ i, f x i)
    =
    (fun y => âˆ‘ i, semiAdjoint K (f Â· i) y) :=



Theorem: SciLean.revDerivProjUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X â†’ Î¹ â†’ Y) (hf : âˆ€ i, HasAdjDiff K (f Â· i)) :
    (revDerivProjUpdate K Unit fun (x : X) (i : Î¹) => f x i)
    =
    fun x =>
      let ydf := fun i => revDerivUpdate K (f Â· i) x
      (fun i => (ydf i).1,
       fun _ df dx =>
         Fold.fold (IndexType.univ Î¹) (fun dx i => (ydf i).2 (df i) dx) dx) :=



Theorem: SciLean.scalar_max_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_one_zero  : max (1 : R) (0 : R) = 1 :=



Theorem: SciLean.HasSemiAdjoint.HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
    (f g : X â†’ Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x - g x :=



Theorem: SciLean.cderiv.pi_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule_at
  (f : X â†’ (i : Î¹) â†’ E i) (x : X) (hf : âˆ€ i, CDifferentiableAt K (f Â· i) x)
  : (cderiv K fun (x : X) (i : Î¹) => f x i) x
    =
    fun dx => fun i =>
      cderiv K (f Â· i) x dx
  :=



Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a0.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a0.IsContinuousLinearMap_rule
  (f : X â†’ Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ (f x) y :=



Theorem: Function.Bijective.HSub.hSub.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a1.Bijective_rule
  [AddGroup Y]
   (y : Y) (f : X â†’ Y) (hf : Bijective f)
  : Bijective fun x => y - f x
  :=



Theorem: Function.Bijective.HAdd.hAdd.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X â†’ Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x + y
  :=



Theorem: SciLean.Distribution.smul_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.smul_extAction (r : R) (T : ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W)  :
    (r â€¢ T).extAction Ï† L = r â€¢ T.extAction Ï† L :=



Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.DualBasis.dualProj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => â„¼' i x) :=



Theorem: SciLean.semiAdjoint.starRingEnd.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a0.semiAdjoint_rule
  (f : X â†’ K)
  : semiAdjoint K (fun x => conj (f x))
    =
    fun z => semiAdjoint K f z :=



Theorem: SciLean.scalar_abs_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_one : Scalar.abs (1 : R) = 1 :=



Theorem: SciLean.ArrayType.ext
File path: SciLean/Data/ArrayType/Basic.lean
Theorem statement: theorem ext (x y : Cont) : (âˆ€ i, x[i] = y[i]) â†’ x = y :=



Theorem: SciLean.scalar_min_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_one_zero  : min (1 : R) (0 : R) = 0 :=



Theorem: SciLean.semiAdjoint.IndexType.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem IndexType.sum.arg_f.semiAdjoint_rule
  (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, HasSemiAdjoint K (f Â· i))
  : semiAdjoint K (fun x => âˆ‘ i, f x i)
    =
    (fun y => âˆ‘ i, semiAdjoint K (f Â· i) y) :=



Theorem: SciLean.Prod.mk.arg_fstsnd.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.ContCDiffAt_rule (x : X)
  (g : X â†’ Y) (hg : ContCDiffAt K n g x)
  (f : X â†’ Z) (hf : ContCDiffAt K n f x)
  : ContCDiffAt K n (fun x => (g x, f x)) x
  :=



Theorem: Function.invFun.HAdd.hAdd.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.invFun_rule
  [AddGroup Y]
  (y : Y)  (f : X â†’ Y) (hf : Bijective f)
  : invFun (fun x => y + f x)
    =
    fun y' =>
      invFun f (-y + y')
  :=



Theorem: SciLean.semiAdjoint.Prod.mk.arg_fstsnd.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.semiAdjoint_rule
  (g : X â†’ Y) (f : X â†’ Z)
  (hg : HasSemiAdjoint K g) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (g x, f x))
    =
    fun yz =>
      let xâ‚ := semiAdjoint K g yz.1
      let xâ‚‚ := semiAdjoint K f yz.2
      xâ‚ + xâ‚‚ :=



Theorem: SciLean.parametric_inverse_affine'
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine' (f : X â†’ R) (c : R) (hf : IsAffineMap R f) :
    let u  := âˆ‡ f 0
    let dec := planeDecomposition (n:=card Î¹ - 1) (R:=R) u sorry_proof
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / â€–uâ€–â‚‚)
      (dom := fun _ => âŠ¤) :=



Theorem: SciLean.BasisDuality.toDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => â„¼' i x) x :=



Theorem: SciLean.cderiv.let_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule
  (f : X â†’ Y â†’ Z) (g : X â†’ Y)
  (hf : CDifferentiable K fun xy : XÃ—Y => f xy.1 xy.2) (hg : CDifferentiable K g)
  : (cderiv K fun x : X =>
       let y := g x
       f x y)
    =
    fun x =>
      let y  := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K (fun xy : XÃ—Y => f xy.1 xy.2) (x,y) (dx, dy)
        dz :=



Theorem: SciLean.Neg.neg.arg_a0.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Neg.neg.arg_a0.CDifferentiable_rule
  (f : X â†’ Y) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => - f x)  :=



Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X â†’ Y) (y : Y) (hf : Bijective f) (hy : y â‰  0)
  : Bijective (fun x => f x * y)
  :=



Theorem: SciLean.jacobian.comp_rule
File path: SciLean/Core/Integral/Jacobian.lean
Theorem statement: theorem jacobian.comp_rule (f : U â†’ V) (g : U â†’ U)
    (hf : HasAdjDiff R f) (hg : HasAdjDiff R g) :
    jacobian R (fun x => f (g x))
    =
    fun x => jacobian R f x * jacobian R g x :=



Theorem: SciLean.CDifferentiableAt.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.pi_rule
  (f : X â†’ (i : Î¹) â†’ E i) (x : X)
  (hf : âˆ€ i, CDifferentiableAt K (f Â· i) x)
  : CDifferentiableAt K (fun x i => f x i) x
  :=



Theorem: Function.invFun.HSub.hSub.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a1.invFun_rule
  [AddGroup Y]
   (y : Y) (f : X â†’ Y) (hf : Bijective f)
  : invFun (fun x => y - f x )
    =
    fun y' =>
      invFun f (y - y')
  :=



Theorem: SciLean.CDifferentiable.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.const_rule (y : Y)
  : CDifferentiable K (fun _ : X => y)
  :=



Theorem: SciLean.IndexType.sum.arg_f.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem IndexType.sum.arg_f.ContCDiffAt_rule
  (f : X â†’ Î¹ â†’ Y) (x : X) (hf : âˆ€ i, ContCDiffAt K n (fun x => f x i) x)
  : ContCDiffAt K n (fun x => âˆ‘ i, f x i) x :=



Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X âŸ¿FD[K,âˆž] Y)Ã—X) => fx.1 fx.2) :=



Theorem: SciLean.norm2_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm2_scalar {R} [RealScalar R] (x : R) :
  â€–xâ€–â‚‚Â²[R] = x^2 :=



Theorem: SciLean.Function.invFun.arg_f.cderiv_rule'
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f.cderiv_rule'
  (f : X â†’ Y â†’ Z) (z : Z)
  (hf : âˆ€ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : XÃ—Y => f xy.1 xy.2))
  : cderiv K (fun x => invFun (f x) z)
    =
    fun x dx =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=



Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X âŸ¿FD[K,n] Y)Ã—X) => fx.1 fx.2) :=



Theorem: SciLean.HasSemiAdjoint.Prod.snd.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.HasSemiAdjoint_rule
    (f : X â†’ YÃ—Z) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).snd :=



Theorem: SciLean.Diffeomorphism.id_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem id_rule
  : Diffeomorphism K (fun x : X => x)
  :=



Theorem: IndexType.sum.arg_f.revDerivProj_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProj_rule [DecidableEq Î¹]
    (f : X â†’ Î¹ â†’ Y') (hf : âˆ€ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProj K Yi (fun x => âˆ‘ i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Î¹Ã—Yi) f x
      (âˆ‘ i, ydf.1 i,
       fun j dy =>
         Fold.fold (IndexType.univ Î¹) (fun dx i => ydf.2 (i,j) dy dx) 0) :=



Theorem: SciLean.cderiv.let_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule_at
  (f : X â†’ Y â†’ Z) (g : X â†’ Y) (x : X)
  (hf : CDifferentiableAt K â†¿f (x, g x))
  (hg : CDifferentiableAt K g x)
  : (cderiv K
      fun x : X =>
        let y := g x
        f x y) x
    =
    let y  := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K (fun xy : XÃ—Y => f xy.1 xy.2) (x,y) (dx, dy)
      dz :=



Theorem: SciLean.IsContinuousLinearMap.starRingEnd.arg_a.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem starRingEnd.arg_a.IsContinuousLinearMap_rule
  (f : X â†’ K) (_ : IsContinuousLinearMap K f)
  : IsContinuousLinearMap K fun x => conj (f x) :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiff_rule
    (f g : X â†’ Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x + g x) :=



Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.toDual x) x :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X â†’ Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x + g x) x :=



Theorem: SciLean.ContCDiffAt.pi_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.pi_rule (x : X)
    (f : X â†’ (i : Î¹) â†’ E i)
    (hf : âˆ€ i, ContCDiffAt K n (f Â· i) x) :
    ContCDiffAt K n (fun x i => f x i) x :=



Theorem: SciLean.Rand.pull_E_affine
File path: SciLean/Core/Rand/PushPullExpectation.lean
Theorem statement: theorem pull_E_affine (r : Rand X) (Ï† : X â†’ Y)
    (f : Y â†’ Z) (hf : IsAffineMap â„ f := by fun_prop) :
    (f (r.ð”¼ Ï†)) = r.ð”¼ (fun x => f (Ï† x)) :=



Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiableAt (f : W â†’ X âŸ¿FD[K,âˆž] Y) (g : W â†’ X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=



Theorem: SciLean.Function.invFun.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_a1.cderiv_rule
  (f : Y â†’ Z) (g : X â†’ Z)
  (hf : Diffeomorphism K f) (hg : CDifferentiable K g)
  : cderiv K (fun x => invFun f (g x))
    =
    fun x dx =>
      let z := g x
      let dz := cderiv K g x dx
      let y := invFun f z
      let dy := invFun (cderiv K f y) dz
      dy :=



Theorem: LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple (idx : Idx) :
    IsLinearMap R (fun ((cont,elem) : ContÃ—Elem) => Indexed.set cont idx elem) :=



Theorem: SciLean.Prod.fst.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.fst.arg_self.ContCDiffAt_rule (x : X)
    (f : X â†’ YÃ—Z) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).1) x :=



Theorem: SciLean.cderiv.comp_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule
  (f : Y â†’ Z) (g : X â†’ Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : (cderiv K fun x : X => f (g x))
    =
    fun x =>
      let y := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K f y dy
        dz :=



Theorem: LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
    (cont : X â†’ Cont) (idx : Idx) (elem : X â†’ Elem)
    (hcont : HasAdjDiff K cont) (helem : HasAdjDiff K elem) :
    revDerivProj K Idx (fun x => Indexed.set (cont x) idx (elem x))
    =
    fun x =>
      let cdc := revDerivProj K Idx cont x
      let ede := revDeriv K elem x
      (Indexed.set cdc.1 idx ede.1,
       fun i delem =>
         if i = idx then
           ede.2 delem
         else
           cdc.2 i delem) :=



Theorem: IsAffineMap.IsAffineMap_pi
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_pi (f : X â†’ (i : Î¹) â†’ E i) (hf : âˆ€ i, IsAffineMap R (f Â· i)) :
    IsAffineMap R (fun x i â†¦ f x i) :=



Theorem: SciLean.Inner.inner.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Inner.inner.arg_a0a1.CDifferentiable_rule
    (f : X â†’ Y) (g : X â†’ Y)
    (hf : CDifferentiable R f) (hg : CDifferentiable R g) :
    CDifferentiable R (fun x => âŸªf x, g xâŸ«[R]) :=



Theorem: SciLean.Basis.proj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Basis.proj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => â„¼ i x) :=



Theorem: Function.Bijective.HVAdd.hVAdd.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HVAdd.hVAdd.arg_a1.Bijective_rule_group
  [AddGroup G] [AddAction G Y]
  (g : G) (f : X â†’ Y) (hf : Bijective f)
  : Bijective (fun x => g +áµ¥ f x)
  :=



Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.HasSemiAdjoint_rule
  (f : X â†’ K) (y' : K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x * y' :=



Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_group
  [Group G] [MulAction G Y]
  (g : G) (f : X â†’ Y) (hf : Bijective f)
  : Bijective (fun x => g â€¢ f x)
  :=



Theorem: GetElem.getElem.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.semiAdjoint_rule_simple (idx : Idx) :
    semiAdjoint K (fun cont : Cont => cont[idx])
    =
    fun elem => oneHot (X:=Cont) idx elem :=



Theorem: SciLean.toDistribution.linear_parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem toDistribution.linear_parDistribDeriv_rule (f : W â†’ X â†’ Y) (L : Y â†’ Z)
    (hL : IsSmoothLinearMap R L) :
    parDistribDeriv (fun w => (fun x => L (f w x)).toDistribution)
    =
    fun w dw =>
      parDistribDeriv (fun w => (fun x => f w x).toDistribution) w dw |>.postComp (fun y âŠ¸ L y) :=



Theorem: Function.invFun.HAdd.hAdd.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X â†’ Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x + y)
    =
    fun y' =>
      invFun f (y' - y)
  :=



Theorem: SciLean.CDifferentiable.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.apply_rule (i : Î¹)
  : CDifferentiable K (fun x : (i : Î¹) â†’ E i => x i) :=



Theorem: SciLean.proj_zero
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem proj_zero (i : Î¹)
  : â„¼ i (0 : X) = 0 :=



Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.HasSemiAdjoint_rule
  (y' : K) (f : X â†’ K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => y' * f x :=



Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule
    (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, CDifferentiable K (f Â· i)) :
    fwdDeriv K (fun x => âˆ‘ i, f x i)
    =
    fun x dx =>
      let ydy := fun i => fwdDeriv K (f Â· i) x dx
      âˆ‘ i, ydy i :=



Theorem: SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.postComp.arg_T.IsSmoothLinarMap_rule (T : W â†’ ð’Ÿ'(X,Y)) (f : Y âŠ¸ Z)
    (hT : IsSmoothLinearMap R T) :
    IsSmoothLinearMap R (fun w => (T w).postComp f) :=



Theorem: Function.Bijective.HAdd.hAdd.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.Bijective_rule
  [AddGroup Y]
  (y : Y)  (f : X â†’ Y) (hf : Bijective f)
  : Bijective fun x => y + f x
  :=



Theorem: SciLean.gaussian.arg_Î¼x.cderiv_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_Î¼x.cderiv_rule
    (Î¼ : W â†’ U) (Ïƒ : R) (x : W â†’ U)
    (hÎ¼ : CDifferentiable R Î¼) (hx : CDifferentiable R x) :
    fwdDeriv R (fun w => gaussian (Î¼ w) Ïƒ (x w))
    =
    fun w dw =>
      let Î¼dÎ¼ := fwdDeriv R Î¼ w dw
      let xdx := fwdDeriv R x w dw
      let xdx' := Ïƒâ»Â¹ â€¢ (xdx - Î¼dÎ¼)
      let g := gaussian Î¼dÎ¼.1 Ïƒ xdx.1
      (g, - âŸªxdx'.1, xdx'.2âŸ« * g) :=



Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X â†’ Y) (hf : Bijective f)
  : Bijective fun x => (f x)â»Â¹
  :=



Theorem: SciLean.HasSemiAdjoint.starRingEnd.arg_a.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a.HasSemiAdjoint_rule
  (f : X â†’ K) (_ : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => conj (f x) :=



Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.semiAdjoint_rule
  (c : K) (g : X â†’ Y) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => c â€¢ g x)
    =
    fun y => (conj c) â€¢ semiAdjoint K g y :=



Theorem: SciLean.semiAdjoint.Inner.inner.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X â†’ Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => âŸªf x, yâŸ«[K])
    =
    fun z => (conj z) â€¢ semiAdjoint K f y :=



Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule
  (f : Xâ‚ â†’ Y) (g : Xâ‚‚ â†’ Z) (pâ‚ : X â†’ Xâ‚) (pâ‚‚ : X â†’ Xâ‚‚)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (pâ‚ x, pâ‚‚ x)))
  : Bijective (fun x : X => (f (pâ‚ x), g (pâ‚‚ x)))
  :=



Theorem: SciLean.SciLean.normâ‚‚.arg_x.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.normâ‚‚.arg_x.HasAdjDiffAt_rule (x : X)
    (f : X â†’ Y) (hf : HasAdjDiffAt R f x) (hfz : f x â‰  0) :
    HasAdjDiffAt R (fun x => â€–f xâ€–â‚‚[R]) x :=



Theorem: LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple :
    semiAdjoint K (fun f : Idx â†’ Elem => Indexed.ofFn (C:=Cont) f)
    =
    fun (cont : Cont) idx => cont[idx] :=



Theorem: Function.invFun.HSub.hSub.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X â†’ Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x - y)
    =
    fun y' =>
      invFun f (y' + y)
  :=



Theorem: SciLean.Basis.proj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => â„¼ i x) :=



Theorem: SciLean.scalar_abs_neg
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_neg (r : R) : Scalar.abs (- r) = Scalar.abs r :=



Theorem: SciLean.inner_basis_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_basis_dualProj (i : Î¹) (x : X)
  : âŸªx, â…‡ iâŸ«[K] = â„¼' i x :=



Theorem: SciLean.Measure.prod_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_restrict {X Y} [MeasurableSpace X] [MeasurableSpace Y]
    (Î¼ : Measure X) (Î½ : Measure Y) (A : Set X) (B : Set Y) :
    (Measure.prod (Î¼.restrict A) (Î½.restrict B)) = (Î¼.prod Î½).restrict (A Ã—Ë¢ B) :=



Theorem: SciLean.semiAdjoint.HAdd.hAdd.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.semiAdjoint_rule
  (f g : X â†’ Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x + g x)
    =
    fun y =>
      let xâ‚ := semiAdjoint K f y
      let xâ‚‚ := semiAdjoint K g y
      xâ‚ + xâ‚‚ :=



Theorem: SciLean.HasSemiAdjoint.comp_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem comp_rule
    (f : Y â†’ Z) (g : X â†’ Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K (fun x => f (g x)) :=



Theorem: SciLean.HasSemiAdjoint.SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
  (f : X â†’ Y) (a0 : W â†’ Y) (ha0 : HasSemiAdjoint K a0)
  : HasSemiAdjoint K (fun w => semiAdjoint K f (a0 w)) :=



Theorem: SciLean.inner_proj_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_proj_dualProj {Î¹ K X} {_ : IndexType Î¹} [LawfulIndexType Î¹] [DecidableEq Î¹] [RCLike K] [FinVec Î¹ K X] (x y : X)
  : âŸªx, yâŸ«[K] = âˆ‘ i, â„¼ i x * â„¼' i y :=



Theorem: SciLean.DualBasis.dualProj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => â„¼' i x) :=



Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
    (c : K) (f : X â†’ Y) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun x => c â€¢ f x :=



Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.HasSemiAdjoint_rule
  (f : X â†’ Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => âŸªy, f xâŸ«[K] :=



Theorem: SciLean.Rand.flip.pdf
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf (x : R) :
    (flip x).pdf R .count
    =
    fun b =>
      let x := (x âŠ” 0) âŠ“ 1
      if b then x else (1-x) :=



Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_field
  [Field Y]
  (y : Y) (f : X â†’ Y) (hf : Bijective f) (hy : y â‰  0)
  : Bijective (fun x => y * f x)
  :=



Theorem: SciLean.HSub.hSub.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a0.cderiv_rule
    (f : X â†’ Y) (y : Y) :
    (cderiv K fun x => f x - y)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X â†’ Y) (y : Y)
  (hf : Bijective f) (hy : y â‰  0)
  : Bijective (fun x => f x / y) :=



Theorem: SciLean.Prod.snd.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.snd.arg_self.CDifferentiable_rule
  (f : X â†’ YÃ—Z) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).2)  :=



Theorem: SciLean.inner_dualBasis_basis
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_basis  (i j : Î¹)
  : âŸªâ…‡'[X] i, â…‡ jâŸ«[K] = if i=j then 1 else 0 :=



Theorem: SciLean.parDistribDeriv.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem parDistribDeriv.comp_rule
    (f : Y â†’ ð’Ÿ'(Z,U)) (g : X â†’ Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    parDistribDeriv (fun x => f (g x))
    =
    fun x dx =>
      let ydy := fwdDeriv R g x dx
      parDistribDeriv f ydy.1 ydy.2 :=



Theorem: SciLean.SmoothLinearMap.fintype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.fintype_sum_apply {I} [Fintype I] (f : I â†’ XâŠ¸[K] Y) (x : X) :
    (âˆ‘ i, f i) x = âˆ‘ i, f i x  :=



Theorem: SciLean.decompose_has_unique_solution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decompose_has_unique_solution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys â†’ Zs â†’ Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs â†’ Prop)       (Qâ‚ : Ys â†’ Zs â†’ Prop) (Qâ‚‚ : Ys â†’ Zs â†’ Prop) (equiv : âˆ€ ys zs, (Qâ‚ ys zs âˆ§ Qâ‚‚ ys zs) â†” P (f ys zs))
  (unique : âˆ€ ys, HasUniqueSolution (Qâ‚ ys))
  : HasUniqueSolution P
    â†”
    HasUniqueSolution fun ys => Qâ‚‚ ys (solve zs, Qâ‚ ys zs)
  :=



Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_field
  [Field R] [MulAction R Y]
  (r : R) (f : X â†’ Y) (hf : Bijective f) (hr : r â‰  0)
  : Bijective (fun x => r â€¢ f x)
  :=



Theorem: SciLean.ite.arg_chte.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem ite.arg_chte.cderiv_rule
  (c : X â†’ Prop) [dec : âˆ€ x, Decidable (c x)] (t e : X â†’ Y)
  (ht : âˆ€ x âˆˆ closure c, CDifferentiableAt K t x) (he : âˆ€ x âˆˆ (interior c)á¶œ, CDifferentiableAt K e x)
  (hc : (âˆ€ x, x âˆˆ frontier c â†’ cderiv K t x = cderiv K e x))
  : cderiv K (fun x => ite (c x) (t x) (e x))
    =
    fun y =>
      ite (c y) (cderiv K t y) (cderiv K e y) :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.ContCDiffAt.const_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.const_rule (y : Y) (x : X) :
    ContCDiffAt K n (fun _ : X => y) x :=



Theorem: SciLean.Rand.mean_add'
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add' (x : Rand X) (x' : X) : x' + x.mean = (x' +  x).mean :=



Theorem: SciLean.HasSemiAdjoint.SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
  (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, HasSemiAdjoint K fun x : X => f x i)
  : HasSemiAdjoint K fun x => âˆ‘ i, f x i :=



Theorem: SciLean.CDifferentiableAt.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.apply_rule
  (i : Î¹) (x)
  : CDifferentiableAt K (fun x : (i : Î¹) â†’ E i => x i) x :=



Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_int
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_int
    (c : â„¤) (f : X â†’ Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c â€¢ f x :=



Theorem: SciLean.Prod.snd.arg_self.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiff_rule
    (f : X â†’ YÃ—Z) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => (f x).2) :=



Theorem: SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule (w : W)
    (f : X â†’ Y) (a0 : W â†’ Y) (hf : CDifferentiable K f) (ha0 : HasAdjDiffAt K a0 w) :
    HasAdjDiffAt K (fun w => semiAdjoint K f (a0 w)) w :=



Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (y' : Y) (f : X â†’ K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x â€¢ y')
    =
    fun y => semiAdjoint K (fun x => f x) âŸªy',yâŸ«[K] :=



Theorem: IndexType.sum.arg_f.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsLinearMap_rule
  (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, IsLinearMap R (f Â· i))
  : IsLinearMap R fun x => âˆ‘ i, f x i :=



Theorem: SciLean.explicitSymplecticEuler_eq_implicitSymplecticEulerV1
File path: SciLean/Modules/DifferentialEquations/OdeSolvers/Solvers.lean
Theorem statement: theorem explicitSymplecticEuler_eq_implicitSymplecticEulerV1
  (T V : X â†’ R)
  (hT : HasAdjDiff R T) (hV : HasAdjDiff R V)
  : explicitSymplecticEuler (fun q p => T p + V q)
    =
    implicitSymplecticEulerV1 (fun q p => T p + V q) :=



Theorem: SciLean.Rand.bind_pdf
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_pdf (Î½ : Measure Y) (x : Rand X) (f : X â†’ Rand Y) :
    (x >>= f).pdf R Î½ = fun y => âˆ« x', ((f x').pdf R Î½ y) âˆ‚x.â„™ :=



Theorem: SciLean.cintegral.arg_f.cderiv_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.cderiv_rule
    (f : X â†’ Î² â†’ Z) (Î¼ : Measure Î²) (hf : âˆ€ y, CDifferentiable R (f Â· y)) :
    (cderiv R  fun x => âˆ«' y, f x y âˆ‚Î¼)
    =
    fun x dx => âˆ«' y, cderiv R (f Â· y) x dx âˆ‚Î¼ :=



Theorem: SciLean.parametric_inverse_bijection
File path: SciLean/Core/Integral/ParametricInverse.lean
Theorem statement: theorem parametric_inverse_bijection [Nonempty X] (f : X â†’ Y) (hf : f.Bijective) (y : Y) :
    ParametricInverseAt f y
      (I := Unit) (Xâ‚ := fun _ => Unit)
      (p := fun _ _ x => x)
      (g := fun _ _ => f.invFun y)
      (dom := fun _ => Set.univ) :=



Theorem: SciLean.approx_consistency
File path: SciLean/Core/Approx/ApproxSolution.lean
Theorem statement: theorem approx_consistency {N} {lN : Filter N} [T2Space Î±] {spec : Î± â†’ Prop}
  (approx : ApproxSolution lN spec)
  : âˆ€ a, a = (limit n âˆˆ lN, approx.val n) â†’ spec a :=



Theorem: SciLean.IndexType.sum.arg_f.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.cderiv_rule_at
  (f : X â†’ Î¹ â†’ Y) (x : X) (hf : âˆ€ i, CDifferentiableAt K (f Â· i) x)
  : cderiv K (fun x => âˆ‘ i, f x i) x
    =
    fun dx => âˆ‘ i, cderiv K (f Â· i) x dx :=



Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X â†’ K) (y : Y) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x â€¢ y :=



Theorem: SciLean.scalar_norm
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem scalar_norm {R} [RealScalar R] (r : R) : â€–râ€–â‚‚[R] = Scalar.abs r :=



Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X â†’ Y) (hf : Bijective f) (hf' : âˆ€ x, f x â‰  0)
  : Bijective fun x => (f x)â»Â¹
  :=



Theorem: SciLean.SciLean.cderiv.arg_dx.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.cderiv_rule_at
  (f : Y â†’ Z) (g : X â†’ Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : cderiv K (fun dx' => cderiv K f y (g dx')) dx
    =
    fun ddx =>
      let ddy := cderiv K g dx ddx
      cderiv K f y ddy :=



Theorem: Function.invFun.let_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem let_rule
  (f : Xâ‚‚ â†’ Y â†’ Z) (g : Xâ‚ â†’ Y) (pâ‚ : X â†’ Xâ‚) (pâ‚‚ : X â†’ Xâ‚‚)
  (hf : Bijective (fun xy : Xâ‚‚Ã—Y => f xy.1 xy.2)) (hg : Bijective g) (hp : Bijective (fun x => (pâ‚ x, pâ‚‚ x)))
  : invFun (fun x => let y := g (pâ‚ x); f (pâ‚‚ x) y)
    =
    fun z =>
      let xâ‚‚y := invFun (fun xy : Xâ‚‚Ã—Y => f xy.1 xy.2) z
      let xâ‚ := invFun g xâ‚‚y.2
      let x := invFun (fun x => (pâ‚ x, pâ‚‚ x)) (xâ‚,xâ‚‚y.1)
      x :=



Theorem: SciLean.semiAdjoint.id_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem id_rule : semiAdjoint K (fun (x : X) => x) = fun x => x :=



Theorem: SciLean.Distribution.add_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.add_extAction (T T' : ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W) :
    ((T + T') : ð’Ÿ'(X,U)).extAction Ï† L = T.extAction Ï† L + T'.extAction Ï† L :=



Theorem: Set.HSub.hSub.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x - x') (Ioo a b)
    =
    Ioo (a + x') (b + x') :=



Theorem: SciLean.semiAdjoint.let_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem let_rule
    (f : X â†’ Y â†’ Z) (g : X â†’ Y)
    (hf : HasSemiAdjoint K â†¿f) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => let y := g x; f x y)
    =
    fun z =>
      let xy := semiAdjoint K (fun xy : XÃ—Y => f xy.1 xy.2) z
      let x' := semiAdjoint K g xy.2
      xy.1 + x' :=



Theorem: SciLean.SmoothLinearMap.indextype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.indextype_sum_apply {I} [IndexType I] (f : I â†’ XâŠ¸[K] Y) (x : X) :
    (âˆ‘ i, f i) x = âˆ‘ i, f i x  :=



Theorem: Function.invFun.Equiv.toFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.toFun.arg_a0.invFun_rule (f : Y â‰ƒ Z) (g : X â†’ Y) (hf : Bijective g)
  : Function.invFun (fun x => f (g x))
    =
    fun z => Function.invFun g (f.invFun z) :=



Theorem: SciLean.Diffeomorphism.comp_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem comp_rule
  (f : Y â†’ Z) (g : X â†’ Y)
  (hf : Diffeomorphism K f) (hg : Diffeomorphism K g)
  : Diffeomorphism K (fun x => f (g x))
  :=



Theorem: SciLean.DistribDiffrentiable.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem DistribDiffrentiable.comp_rule
    (f : Y â†’ ð’Ÿ'(Z,U)) (g : X â†’ Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    DistribDifferentiable (fun x => f (g x)) :=



Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
    (c : â„•) (f : X â†’ Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c â€¢ f x :=



Theorem: SciLean.IsContinuousLinearMap.isContinuousLinearMap_differentiable
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem isContinuousLinearMap_differentiable (f : X â†’ Y) (hf : IsContinuousLinearMap K f) :
    Differentiable K f :=



Theorem: SciLean.semiAdjoint.HDiv.hDiv.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.semiAdjoint_rule
  (f : X â†’ K) (c : K)
  (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x / c)
    =
    fun y => (conj c)â»Â¹ â€¢ semiAdjoint K f y :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.Function.toDistribution_zero
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Function.toDistribution_zero  :
    Function.toDistribution (fun (_ : X) => 0) = (0 : ð’Ÿ'(X,Y)) :=



Theorem: SciLean.HAdd.hAdd.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.cderiv_rule
    (f : X â†’ Y) (y : Y) :
    (cderiv K fun x => y + f x)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a1.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a1.IsContinuousLinearMap_rule
  (f : X â†’ Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ y (f x) :=



Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiff_rule
    (f g : X â†’ Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x - g x) :=



Theorem: SciLean.SmoothLinearMap.apply_zero
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.apply_zero (f : X âŠ¸[K] Y) : f 0 = 0 :=



Theorem: SciLean.Rand.uniformI.pdf
File path: SciLean/Core/Rand/Distributions/UniformI.lean
Theorem statement: theorem uniformI.pdf :
    (uniformI R).pdf R volume
    =
    fun x => if 0 < x âˆ§ x < 1 then 1 else 0 :=



Theorem: SciLean.Rand.flip.pdf_wrt_flip
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf_wrt_flip (Î¸ Î¸' : R) :
    (flip Î¸).pdf R (flip Î¸').â„™
    =
    fun b => if b then Î¸ / Î¸' else (1-Î¸) / (1-Î¸') :=



Theorem: SciLean.Rand.bind_E
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_E (r : Rand X) (f : X â†’ Rand Y) (Ï† : Y â†’ Z) :
    (r >>= f).ð”¼ Ï† = r.ð”¼ (fun x' => (f x').ð”¼ Ï†) :=



Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.semiAdjoint_rule
  (c : K) (f : X â†’ K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x * c)
    =
    fun y => conj c â€¢ semiAdjoint K (fun x => f x) y :=



Theorem: SciLean.Rand.swap_bind
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem swap_bind (f : X â†’ Y â†’ Z) (x : Rand X) (y : Rand Y) :
    (do let x' â† x; let y' â† y; pure (f x' y'))
    =
    (do let y' â† y; let x' â† x; pure (f x' y')) :=



Theorem: SciLean.cderiv.arg_f.IsSmoothLinearMap_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.arg_f.IsSmoothLinearMap_rule
    (f : X â†’ Y â†’ Z) (hf : CDifferentiable K (fun (x,y) => f x y)) (hf' : âˆ€ y, IsLinearMap K (fun x => f x y)) :
    IsSmoothLinearMap K (fun x => cderiv K (f x Â·)) :=



Theorem: SciLean.parDistribFwdDeriv.bind_rule
File path: SciLean/Core/Distribution/ParametricDistribFwdDeriv.lean
Theorem statement: theorem bind_rule
    (f : X â†’ Y â†’ ð’Ÿ'(Z,V)) (g : X â†’ ð’Ÿ'(Y,U)) (L : U âŠ¸ V âŠ¸ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    parDistribFwdDeriv (fun x => (g x).bind (f x) L)
    =
    fun x dx =>
      let ydy := parDistribFwdDeriv g x dx  let zdz := fun y => parDistribFwdDeriv (f Â· y) x dx ydy.bind zdz (fun (r,dr) âŠ¸ fun (s,ds) âŠ¸ (L r s, L r ds + L dr s)) :=



Theorem: SciLean.Measure.restrict_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.restrict_restrict {X} [MeasurableSpace X] (Î¼ : Measure X) (A B : Set X) :
    (Î¼.restrict A).restrict B = Î¼.restrict (A âˆ© B) :=



Theorem: SciLean.FwdFDeriv.HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at (x : X)
    (f : X â†’ K) (g : X â†’ K)
    (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) (hx : g x â‰  0) :
    (fwdFDeriv K fun x => f x / g x) x
    =
    fun dx =>
      let ydy := (fwdFDeriv K f x dx)
      let zdz := (fwdFDeriv K g x dx)
      (ydy.1 / zdz.1, (ydy.2 * zdz.1 - ydy.1 * zdz.2) / zdz.1^2) :=



Theorem: SciLean.HSub.hSub.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.CDifferentiable_rule
  (f g : X â†’ Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x - g x)  :=



Theorem: SciLean.normâ‚‚_prod
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem normâ‚‚_prod {R K X Y} [Scalar R K] [AddCommMonoid K] [Inner K X] [Inner K Y] (x : X) (y : Y) :
  â€–(x,y)â€–â‚‚[K] = Scalar.sqrt (â€–xâ€–â‚‚Â²[K] + â€–yâ€–â‚‚Â²[K]) :=



Theorem: LeanColls.Range.fold_def
File path: .lake/packages/leancolls/LeanColls/Data/Range.lean
Theorem statement: theorem fold_def (r : Range) (f : Î² â†’ Nat â†’ Î²)
    : fold r f init =
      Fin.foldl (r.size) (fun acc i => f acc (r.get i)) init
  :=



Theorem: SciLean.FwdFDeriv.FinType.sum.arg_f.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem FinType.sum.arg_f.fwdFDeriv_rule_at (x : X)
    (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, DifferentiableAt K (f Â· i) x) :
    fwdFDeriv K (fun x => âˆ‘ i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdFDeriv K (f Â· i) x dx
      âˆ‘ i, ydy i :=



Theorem: SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSMul.hSMul.arg_a0a1.cderiv_rule_at (x : X) (f : X â†’ K) (g : X â†’ Y)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x â€¢ g x) x
    =
    let k := f x
    let y := g x
    fun dx =>
      k â€¢ (cderiv K g x dx) + (cderiv K f x dx) â€¢ y :=



Theorem: SciLean.Inner.inner.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Inner.inner.arg_a0a1.cderiv_rule_at
  (f : X â†’ Y) (g : X â†’ Y) (x : X)
  (hf : CDifferentiableAt R f x) (hg : CDifferentiableAt R g x)
  : cderiv R (fun x => âŸªf x, g xâŸ«[R]) x
    =
    fun dx =>
      let yâ‚ := f x
      let dyâ‚ := cderiv R f x dx
      let yâ‚‚ := g x
      let dyâ‚‚ := cderiv R g x dx
      âŸªdyâ‚, yâ‚‚âŸ«[R] + âŸªyâ‚, dyâ‚‚âŸ«[R] :=



Theorem: GetElem.getElem.arg_cont.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.revCDerivProj_rule
  {J ElemJ} [StructType Elem J ElemJ] [IndexType J] [LawfulIndexType J] [DecidableEq J]
  [âˆ€ j, SemiInnerProductSpace K (ElemJ j)] [SemiInnerProductSpaceStruct K Elem J ElemJ]
  (f : X â†’ Cont) (idx : Idx)
  (hf : HasAdjDiff K f)
  : revDerivProj K J (fun x => (f x)[idx])
    =
    fun x =>
      let ydf := revDerivProj K (IdxÃ—J) f x
      (ydf.1[idx],
       fun j delem => ydf.2 (idx,j) delem) :=



Theorem: SciLean.cderiv.const_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.const_rule (x : X) :
    (cderiv K fun _ : Y => x) = fun _ => fun dx => 0 :=



Theorem: SciLean.IndexType.sum.arg_f.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiableAt_rule
  (f : X â†’ Î¹ â†’ Y) (x : X) (hf : âˆ€ i, CDifferentiableAt K (fun x => f x i) x)
  : CDifferentiableAt K (fun x => âˆ‘ i, f x i) x :=



Theorem: SciLean.semiAdjoint.HSub.hSub.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.semiAdjoint_rule
  (f g : X â†’ Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x - g x)
    =
    fun y =>
      let xâ‚ := semiAdjoint K f y
      let xâ‚‚ := semiAdjoint K g y
      xâ‚ - xâ‚‚ :=



Theorem: SciLean.IndexType.sum.arg_f.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiable_rule
  (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, CDifferentiable K (fun x => f x i))
  : CDifferentiable K (fun x => âˆ‘ i, f x i) :=



Theorem: IsLinearMap.sum_pull
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_pull
  {f : X â†’ Y} (hf : IsLinearMap K f)
  (Î¹ : Type) [IndexType.{_,u} Î¹] [IndexType.{_,v} Î¹] (x : Î¹ â†’ X)
  : f (âˆ‘ i, x i) = âˆ‘ i, f (x i) :=



Theorem: Set.HAdd.hAdd.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x + x') (Ioo a b)
    =
    Ioo (a - x') (b - x') :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.HasSemiAdjoint.Finset.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.HasSemiAdjoint_rule {Î¹ : Type _} [Fintype Î¹]
  (f : X â†’ Î¹ â†’ Y) (_ : âˆ€ i, HasSemiAdjoint K fun x : X => f x i) (A : Finset Î¹)
  : HasSemiAdjoint K fun x => âˆ‘ i in A, f x i :=



Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiable (f : W â†’ X âŸ¿FD[K,âˆž] Y) (g : W â†’ X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=



Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X â†’ Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x - g x) x :=



Theorem: SciLean.Neg.neg.arg_a0.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiffAt_rule
    (x : X) (f : X â†’ Y) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => - f x) x :=



Theorem: Function.invFun.Prod.mk.arg_fstsnd.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.invFun_rule
  (f : Xâ‚ â†’ Y) (g : Xâ‚‚ â†’ Z) (pâ‚ : X â†’ Xâ‚) (pâ‚‚ : X â†’ Xâ‚‚)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (pâ‚ x, pâ‚‚ x)))
  : invFun (fun x : X => (f (pâ‚ x), g (pâ‚‚ x)))
    =
    fun yz =>
      let xâ‚ := invFun f yz.1
      let xâ‚‚ := invFun g yz.2
      let x  := invFun (fun x => (pâ‚ x, pâ‚‚ x)) (xâ‚,xâ‚‚)
      x :=



Theorem: SciLean.HasSemiAdjoint.Prod.fst.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.HasSemiAdjoint_rule
    (f : X â†’ YÃ—Z) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).fst :=



Theorem: SciLean.Neg.neg.arg_a0.cderiv_rule'
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Neg.neg.arg_a0.cderiv_rule' (x : X) (f : X â†’ Y) :
    (cderiv K fun x => - f x) x
    =
    fun dx => - cderiv K f x dx :=



Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X â†’ Y) (y : Y) (hf : Bijective f)
  : Bijective (fun x => f x * y)
  :=



Theorem: SciLean.ContCDiffMap_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiable (f : W â†’ X âŸ¿[K,âˆž] Y) (g : W â†’ X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=



Theorem: SciLean.inner_dualBasis_proj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_proj  (i : Î¹) (x : X)
  : âŸªx, â…‡' iâŸ«[K] = â„¼ i x :=



Theorem: SciLean.cderiv.id_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.id_rule :
    (cderiv K fun x : X => x) = fun _ => fun dx => dx :=



Theorem: SciLean.Distribution.extAction_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD (A : Set X) (t e : ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W) :
    (iteD A t e).extAction Ï† L =
        t.extAction (fun x => if x âˆˆ A then Ï† x else 0) L +
        e.extAction (fun x => if x âˆ‰ A then Ï† x else 0) L :=



Theorem: SciLean.Prod.mk.arg_fstsnd.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.cderiv_rule_at (x : X)
    (g : X â†’ Y) (hg : CDifferentiableAt K g x)
    (f : X â†’ Z) (hf : CDifferentiableAt K f x) :
    cderiv K (fun x => (g x, f x)) x
    =
    fun dx =>
      (cderiv K g x dx, cderiv K f x dx) :=



Theorem: SciLean.Function.invFun.arg_f_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f_a1.cderiv_rule
  (f : X â†’ Y â†’ Z)
  (hf : âˆ€ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : XÃ—Y => f xy.1 xy.2))
  : cderiv K (fun x z => invFun (f x) z)
    =
    fun x dx z =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=



Theorem: SciLean.CDifferentiableAt.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.const_rule (y : Y) (x : X)
  : CDifferentiableAt K (fun _ : X => y) x
  :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.CDifferentiable_rule
  (f g : X â†’ Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x + g x)  :=



Theorem: SciLean.Prod.mk.arg_fstsnd.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.CDifferentiableAt_rule
  (x : X)
  (g : X â†’ Y) (hg : CDifferentiableAt K g x)
  (f : X â†’ Z) (hf : CDifferentiableAt K f x)
  : CDifferentiableAt K (fun x => (g x, f x)) x
  :=



Theorem: IndexType.sum.arg_f.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsAffineMap_rule
  (f : X â†’ Î¹ â†’ Y) (hf : âˆ€ i, IsAffineMap R (f Â· i))
  : IsAffineMap R fun x => âˆ‘ i, f x i :=



Theorem: SciLean.cderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.apply_rule (i : Î¹) :
    (cderiv K fun (x : (i : Î¹) â†’ E i) => x i)
    =
    fun _ => fun dx => dx i :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.fromDual x) x :=



Theorem: Set.Neg.neg.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem Neg.neg.arg_a1.preimage_rule_Ioo (a b : R)  :
    preimage (fun x : R => - x) (Ioo a b)
    =
    Ioo (-b) (-a) :=



Theorem: Function.invFun.Equiv.invFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.invFun.arg_a0.invFun_rule (f : Y â‰ƒ Z) (g : X â†’ Z) (hf : Bijective g)
  : Function.invFun (fun x => f.invFun (g x))
    =
    fun z => Function.invFun g (f z) :=



Theorem: SciLean.semiAdjoint.Neg.neg.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.semiAdjoint_rule
  (f : X â†’ Y)
  : semiAdjoint K (fun x => - f x)
    =
    fun y => - semiAdjoint K f y :=



Theorem: SciLean.Basis.proj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => â„¼ i x) :=



Theorem: SciLean.cderiv.pi_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule
  (f : X â†’ (i : Î¹) â†’ E i) (hf : âˆ€ i, CDifferentiable K (f Â· i))
  : (cderiv K fun (x : X) (i : Î¹) => f x i)
    =
    fun x => fun dx => fun i =>
      cderiv K (f Â· i) x dx
  :=



Theorem: SciLean.scalar_sqrt_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_zero  : Scalar.sqrt (0 : R) = 0 :=



Theorem: SciLean.ContCDiffMap_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiableAt (f : W â†’ X âŸ¿[K,âˆž] Y) (g : W â†’ X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=



Theorem: SciLean.semiAdjoint.Prod.fst.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.semiAdjoint_rule
  (f : X â†’ YÃ—Z) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).1)
    =
    (fun y => semiAdjoint K (fun x => f x) (y,0)) :=



Theorem: Function.Bijective.Neg.neg.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Neg.neg.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X â†’ Y) (hf : Bijective f)
  : Bijective fun x => - f x
  :=



Theorem: SciLean.SciLean.cderiv.arg_dx.CDifferentiableAt_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.CDifferentiableAt_rule
  (f : Y â†’ Z) (g : X â†’ Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : CDifferentiableAt K (fun dx' => cderiv K f y (g dx')) dx :=



Theorem: SciLean.Distribution.fintype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.fintype_sum_extAction {I} [Fintype I] (T : I â†’ ð’Ÿ'(X,U)) (Ï† : X â†’ V) (L : U âŠ¸ V âŠ¸ W) :
    (âˆ‘ i, T i).extAction Ï† L = âˆ‘ i, (T i).extAction Ï† L :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 2

Theorem: Hurwitz.canonicalForm
File path: FLT/AutomorphicRepresentation/Example.lean
Theorem statement: lemma canonicalForm (z : D^) : âˆƒ (N : â„•+) (z' : ð“ž^), z = jâ‚ ((Nâ»Â¹ : â„š) âŠ—â‚œ 1 : D) * jâ‚‚ z' :=



Theorem: Hurwitz.exists_near
File path: FLT/AutomorphicRepresentation/Example.lean
Theorem statement: lemma exists_near (z : â„) : âˆƒ q : ð“ž, dist z (toQuaternion q) < 1 :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 1

Theorem: condRho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_translate {Î© S : Type*} [MeasureSpace Î©] (X : Î© â†’ G) (Y : Î© â†’ S) (A : Finset G) (s:G) : condRho (fun Ï‰ â†¦ X Ï‰ + s) Y A = condRho X Y A :=


Common Unproved sorry theorems: 36

Theorem: phi_min_exists
File path: PFR/RhoFunctional.lean
Theorem statement: lemma phi_min_exists : âˆƒ (Î©: Type uG) (_:MeasureSpace Î©) (X Y : Î© â†’ G), phiMinimizes X Y Î· A :=



Theorem: condRho_of_injective
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_injective {Î© S T : Type*} [MeasureSpace Î©] (X : Î© â†’ G) (Y : Î© â†’ S) (A : Finset G) (f: S â†’ T) (hf: Function.Injective f) : condRho X (f âˆ˜ Y) A = condRho X Y A :=



Theorem: multidist_ruzsa_IV
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_IV {m:â„•} (hm: m â‰¥ 2) {Î© : Type*} (hÎ© : MeasureSpace Î©) (X : Fin m â†’ Î© â†’ G)
    (hindep : iIndepFun (fun _ â†¦ hG) X ) : d[ âˆ‘ i, X i # âˆ‘ i, X i ] â‰¤ 2 * D[X; fun _ â†¦ hÎ©] :=



Theorem: condRho_plus_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_plus_le {Î© S : Type*} [MeasureSpace Î©] [MeasurableSpace S] (X : Î© â†’ G) (Z : Î© â†’ S) (A : Finset G) : condRho_plus X Z A â‰¤ rho_plus X A :=



Theorem: multiTau_continuous
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_continuous {G Î©â‚€ : Type u} [MeasureableFinGroup G] [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] [MeasureSpace Î©â‚€] (p : multiRefPackage G Î©â‚€) : Continuous
      (fun (Î¼ : Fin p.m â†’ ProbabilityMeasure G) â†¦ multiTau p (fun _ â†¦ G) (fun i â†¦ âŸ¨ Î¼ i âŸ©) (fun _ â†¦ id)) :=



Theorem: condRho_of_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_sum_le {Î© : Type*} [MeasureSpace Î©] (X Y : Î© â†’ G) (A : Finset G) (hindep: IndepFun X Y) : condRho X (X + Y) A â‰¤ (rho X A + rho Y A + d[ X # Y ]) / 2 :=



Theorem: I_two_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma I_two_le : Iâ‚‚ â‰¤ 2 * Î· * d[ Xâ‚ # Xâ‚‚ ] + (Î· / (1 - Î·)) * (2 * Î· * d[ Xâ‚ # Xâ‚‚ ] - Iâ‚) :=



Theorem: dist_add_dist_eq
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_add_dist_eq : d[ Xâ‚ # Xâ‚ ] + d[ Xâ‚‚ # Xâ‚‚ ] = 2 * d[ Xâ‚ # Xâ‚‚ ] + (Iâ‚‚ - Iâ‚) :=



Theorem: multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_chainRule (G H: Type*) [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G] [MeasurableSubâ‚‚ G] [MeasurableAddâ‚‚ G] [Countable G] [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H] [MeasurableSubâ‚‚ H] [MeasurableAddâ‚‚ H] [Fintype H] (Ï€: G â†’+ H) {m : â„•} {Î© : Type*} (hÎ© : MeasureSpace Î©) (X : Fin m â†’ Î© â†’ G) (hindep : iIndepFun (fun _ â†¦ hG) X ) : D[X; fun _ â†¦ hÎ©] = D[X | fun i â†¦ Ï€ âˆ˜ (X i); fun _ â†¦ hÎ©] + D[ fun i â†¦ Ï€ âˆ˜ (X i); fun _ â†¦ hÎ©] + I[ âˆ‘ i, X i : fun Ï‰ â†¦ (fun i â†¦ Ï€ (X i Ï‰)) | Ï€ âˆ˜ (âˆ‘ i, X i)] :=



Theorem: rho_of_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_sum_le {Î© : Type*} [MeasureSpace Î©] (X Y : Î© â†’ G) (A : Finset G) (hindep: IndepFun X Y) : rho (X + Y) A â‰¤ (rho X A + rho Y A + d[ X # Y ]) / 2 :=



Theorem: condRho_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_sum_le {Î©': Type uG} [MeasureSpace Î©'] (Yâ‚ Yâ‚‚ Yâ‚ƒ Yâ‚„ : Î©' â†’ G) (hindep: iIndepFun (fun _ â†¦ hGm) ![Yâ‚, Yâ‚‚, Yâ‚ƒ, Yâ‚„]) :
  let S := Yâ‚ + Yâ‚‚ + Yâ‚ƒ + Yâ‚„
  let Tâ‚ := Yâ‚ + Yâ‚‚
  let Tâ‚‚ := Yâ‚ + Yâ‚ƒ
  condRho Tâ‚ Tâ‚‚ A + condRho Tâ‚‚ Tâ‚ A - (rho Yâ‚ A + rho Yâ‚‚ A + rho Yâ‚ƒ A + rho Yâ‚„ A)/2 â‰¤ (d[ Yâ‚ # Yâ‚‚ ] + d[ Yâ‚ƒ # Yâ‚„ ] + d[ Yâ‚ # Yâ‚ƒ ] + d[ Yâ‚‚ # Yâ‚„ ]) / 2 :=



Theorem: I_one_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma I_one_le : Iâ‚ â‰¤ 2 * Î· * d[ Xâ‚ # Xâ‚‚ ] :=



Theorem: multiDist_indep
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_indep {m : â„•} {Î© : Type*} (hÎ© : MeasureSpace Î©) (X : Fin m â†’ Î© â†’ G)
    (hindep : iIndepFun (fun _ â†¦ hG) X ) :
    D[X ; fun _ â†¦ hÎ©] = H[âˆ‘ i, X i] - (âˆ‘ i, H[X i]) / m :=



Theorem: rho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_translate {Î© : Type*} [MeasureSpace Î©]
    (X : Î© â†’ G) (A : Finset G) (s:G) : rho (fun Ï‰ â†¦ X Ï‰ + s) A = rho X A :=



Theorem: rho_minus_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_minus_of_sum  {Î© : Type*} [MeasureSpace Î©] (X Y : Î© â†’ G) (A : Finset G) (hindep: IndepFun X Y) : rho_minus (X+Y) A â‰¤ rho_minus X A :=



Theorem: iter_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule {m:â„•} (G : Fin (m+1) â†’ Type*) (hG: âˆ€ i, MeasurableSpace (G i)) (hGs: âˆ€ i, MeasurableSingletonClass (G i)) (hGa: âˆ€ i, AddCommGroup (G i)) (hGsub: âˆ€ i, MeasurableSubâ‚‚ (G i)) (hGadd: âˆ€ i, MeasurableAddâ‚‚ (G i)) (hGcount: âˆ€ i, Fintype (G i)) (Ï†: âˆ€ i, G (i+1) â†’+ G i) (Ï€: âˆ€ d, G m â†’+ G d) (hcomp: âˆ€ i, i < m â†’ Ï€ i = (Ï† i) âˆ˜ (Ï€ (i+1))) {Î© : Type*} (hÎ© : MeasureSpace Î©) (X : Fin m â†’ Î© â†’ (G m)) (hindep : iIndepFun (fun _ â†¦ (hG m)) X ) : D[X; fun _ â†¦ hÎ©] = âˆ‘ d âˆˆ Finset.Iio m, D[ fun i â†¦ (Ï€ (d+1)) âˆ˜ (X i) | fun i â†¦ (Ï€ d) âˆ˜ (X i); fun _ â†¦ hÎ©] + âˆ‘ d âˆˆ Finset.Iio m, I[ âˆ‘ i, X i : fun Ï‰ â†¦ (fun i â†¦ (Ï€ (d+1)) (X i Ï‰)) | âŸ¨ (Ï€ (d+1)) âˆ˜ âˆ‘ i, X i, fun Ï‰ â†¦ (fun i â†¦ (Ï€ d) (X i Ï‰))âŸ© ] :=



Theorem: rho_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_sum {Î© : Type*} [MeasureSpace Î©] (X Y : Î© â†’ G) (A : Finset G) (hindep: IndepFun X Y) : rho (X+Y) A â‰¤ rho X A + (H[X+Y] - H[X])/2 :=



Theorem: multiDist_nonneg
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_nonneg {m : â„•} {Î© : Fin m â†’ Type*} (hÎ© : (i : Fin m) â†’ MeasureSpace (Î© i))
    (X : (i : Fin m) â†’ (Î© i) â†’ G) : D[X ; hÎ©] â‰¥ 0 :=



Theorem: rho_continuous
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_continuous [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] : Continuous
      (fun (Î¼: ProbabilityMeasure G) â†¦ @rho G _ hGm G âŸ¨ Î¼ âŸ© id A) :=



Theorem: multiTau_min_exists
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_min_exists {G Î©â‚€ : Type u} [MeasureableFinGroup G] [MeasureSpace Î©â‚€] (p : multiRefPackage G Î©â‚€) : âˆƒ (Î© : Fin p.m â†’ Type u) (hÎ© : âˆ€ i, MeasureSpace (Î© i)) (X : âˆ€ i, Î© i â†’ G), multiTauMinimizes p Î© hÎ© X :=



Theorem: condMultiDist_eq
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma condMultiDist_eq {m : â„•} {Î© : Type*} (hÎ© : MeasureSpace Î©) (hprob: IsProbabilityMeasure hÎ©.volume) {S: Type*} [Fintype S] [hS: MeasurableSpace S] [MeasurableSingletonClass S]
    (X : (i : Fin m) â†’ Î© â†’ G) (Y : (i : Fin m) â†’ Î© â†’ S) (hY : (i:Fin m) â†’  Measurable (Y i)) (hindep: ProbabilityTheory.iIndepFun (fun _ â†¦ hG.prod hS) (fun i â†¦ âŸ¨ X i, Y i âŸ©) ): D[ X | Y ; fun _ â†¦ hÎ©] =  H[ fun Ï‰ â†¦ âˆ‘ i, X i Ï‰ | fun Ï‰ â†¦ (fun i â†¦ Y i Ï‰)] - (m:â„)â»Â¹ * âˆ‘ i, H[X i | Y i] :=



Theorem: multidist_ruzsa_I
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_I {m:â„•} (hm: m â‰¥ 2) {Î©: Fin m â†’ Type*} (hÎ© : (i : Fin m) â†’ MeasureSpace (Î© i))
    (X : (i : Fin m) â†’ (Î© i) â†’ G): âˆ‘ j, âˆ‘ k, (if j = k then (0:â„) else d[X j # X k]) â‰¤ m * (m-1) * D[X; hÎ©] :=



Theorem: iter_multiDist_chainRule'
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule'  {m:â„•} (G : Fin (m+1) â†’ Type*) (hG: âˆ€ i, MeasurableSpace (G i)) (hGs: âˆ€ i, MeasurableSingletonClass (G i)) (hGa: âˆ€ i, AddCommGroup (G i)) (hGsub: âˆ€ i, MeasurableSubâ‚‚ (G i)) (hGadd: âˆ€ i, MeasurableAddâ‚‚ (G i)) (hGcount: âˆ€ i, Fintype (G i)) (Ï†: âˆ€ i, G (i+1) â†’+ G i) (Ï€: âˆ€ d, G m â†’+ G d) (hcomp: âˆ€ i, i < m â†’ Ï€ i = (Ï† i) âˆ˜ (Ï€ (i+1))) {Î© : Type*} (hÎ© : MeasureSpace Î©) (X : Fin m â†’ Î© â†’ (G m)) (hindep : iIndepFun (fun _ â†¦ (hG m)) X ) : D[X; fun _ â†¦ hÎ©] â‰¥ âˆ‘ d âˆˆ Finset.Iio m, D[ fun i â†¦ (Ï€ (d+1)) âˆ˜ (X i) | fun i â†¦ (Ï€ d) âˆ˜ (X i); fun _ â†¦ hÎ©]  :=



Theorem: multidist_ruzsa_III
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_III {m:â„•} (hm: m â‰¥ 2) {Î©: Fin m â†’ Type*} (hÎ© : (i : Fin m) â†’ MeasureSpace (Î© i))
    (X : (i : Fin m) â†’ (Î© i) â†’ G) (hident: âˆ€ j k, IdentDistrib (X j) (X k)): âˆ€ i, D[X; hÎ©] â‰¤ m * d[X i # X i] :=



Theorem: rho_of_subgroup
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_subgroup (H: AddSubgroup G)  {Î© : Type*} [MeasureSpace Î©] (U : Î© â†’ G) (hunif: IsUniform H U) (A : Finset G) (r:â„) (hr: rho U A â‰¤ r) : âˆƒ t:G, Nat.card ((A:Set G) âˆ© ((t +áµ¥ H.carrier)) : Set G) â‰¤ 2^(-r) * (Nat.card A * Nat.card H)^(1/2) âˆ§ Nat.card A â‰¤ 2^(2*r) * Nat.card H âˆ§ Nat.card H â‰¤ 2^(2*r) * Nat.card A :=



Theorem: ent_of_sum_le_ent_of_sum
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma ent_of_sum_le_ent_of_sum [IsProbabilityMeasure Î¼] {I : Type*} {s t : Finset I} (hdisj : Disjoint s t)
    (hs : Finset.Nonempty s) (ht : Finset.Nonempty t) (X : I â†’ Î© â†’ G) (hX : (i : I) â†’ Measurable (X i))
    (hX' : (i : I) â†’ FiniteRange (X i)) (hindep : iIndepFun (fun (i : I) â†¦ hG) X Î¼ ) (f : I â†’ I)
    (hf : Finset.image f t âŠ† s) :
    H[âˆ‘ i in t, X i; Î¼] â‰¤ H[âˆ‘ i in s, X i; Î¼] + âˆ‘ i in t, (H[X i - X (f i); Î¼] - H[X (f i); Î¼]) :=



Theorem: multidist_ruzsa_II
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_II {m:â„•} (hm: m â‰¥ 2) {Î©: Fin m â†’ Type*} (hÎ© : (i : Fin m) â†’ MeasureSpace (Î© i))
    (X : (i : Fin m) â†’ (Î© i) â†’ G): âˆ‘ j, d[X j # X j] â‰¤ 2 * m * D[X; hÎ©] :=



Theorem: condRho_sum_le'
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_sum_le' {Î©': Type uG} [MeasureSpace Î©'] (Yâ‚ Yâ‚‚ Yâ‚ƒ Yâ‚„ : Î©' â†’ G) (hindep: iIndepFun (fun _ â†¦ hGm) ![Yâ‚, Yâ‚‚, Yâ‚ƒ, Yâ‚„]) :
  let S := Yâ‚ + Yâ‚‚ + Yâ‚ƒ + Yâ‚„
  let Tâ‚ := Yâ‚ + Yâ‚‚
  let Tâ‚‚ := Yâ‚ + Yâ‚ƒ
  let Tâ‚ƒ := Yâ‚‚ + Yâ‚ƒ
  condRho Tâ‚ Tâ‚‚ A + condRho Tâ‚‚ Tâ‚ A + condRho Tâ‚ Tâ‚ƒ A + condRho Tâ‚ƒ Tâ‚ A + condRho Tâ‚‚ Tâ‚ƒ A + condRho Tâ‚ƒ Tâ‚‚ A - 3*(rho Yâ‚ A + rho Yâ‚‚ A + rho Yâ‚ƒ A + rho Yâ‚„ A)/2 â‰¤ d[ Yâ‚ # Yâ‚‚ ] + d[ Yâ‚ # Yâ‚ƒ ] + d[ Yâ‚ # Yâ‚„ ] + d[ Yâ‚‚ # Yâ‚ƒ ] + d[ Yâ‚‚ # Yâ‚„ ] + d[ Yâ‚ƒ # Yâ‚„ ] :=



Theorem: rho_plus_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_plus_of_sum  {Î© : Type*} [MeasureSpace Î©] (X Y : Î© â†’ G) (A : Finset G) (hindep: IndepFun X Y) : rho_plus (X+Y) A â‰¤ rho_plus X A + H[X+Y] - H[X] :=



Theorem: dist_of_min_eq_zero
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_of_min_eq_zero (hÎ·': Î· < 1/8) : d[ Xâ‚ # Xâ‚‚ ] = 0 :=



Theorem: multidist_eq_zero
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_eq_zero {m:â„•} (hm: m â‰¥ 2) {Î©: Fin m â†’ Type*} (hÎ© : (i : Fin m) â†’ MeasureSpace (Î© i)) (X : (i : Fin m) â†’ (Î© i) â†’ G) (hvanish: D[X; hÎ©] = 0) : âˆ€ i, âˆƒ H : AddSubgroup G, âˆƒ U : (Î© i) â†’ G, Measurable U âˆ§ IsUniform H U âˆ§ d[X i # U] = 0  :=



Theorem: condRho_minus_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_minus_le {Î© S : Type*} [MeasureSpace Î©] [MeasurableSpace S] (X : Î© â†’ G) (Z : Î© â†’ S) (A : Finset G) : condRho_minus X Z A â‰¤ rho_minus X A + H[ X ] - H[ X | Z ] :=



Theorem: dist_le_of_sum_zero
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_le_of_sum_zero {Î©': Type uG} [MeasureSpace Î©'] (Tâ‚ Tâ‚‚ Tâ‚ƒ : Î©' â†’ G) (hsum: Tâ‚ + Tâ‚‚ + Tâ‚ƒ = 0) : d[ Xâ‚ # Xâ‚‚ ] â‰¤ 3 * I[Tâ‚ : Tâ‚‚ | Tâ‚ƒ] + (2 * H[Tâ‚ƒ] - H[Tâ‚] - H[Tâ‚‚]) + Î· * (condRho Tâ‚ Tâ‚ƒ A + condRho Tâ‚‚ Tâ‚ƒ A - rho Xâ‚ A - rho Xâ‚‚ A) :=



Theorem: cond_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cond_multiDist_chainRule (G H: Type*) [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G] [MeasurableSubâ‚‚ G] [MeasurableAddâ‚‚ G] [Countable G] [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H] [MeasurableSubâ‚‚ H] [MeasurableAddâ‚‚ H] [Fintype H] (Ï€: G â†’+ H) {S : Type*} [Fintype S] [hS: MeasurableSpace S] {m : â„•} {Î© : Type*} (hÎ© : MeasureSpace Î©) (X : Fin m â†’ Î© â†’ G) (Y : Fin m â†’ Î© â†’ S) (hindep : iIndepFun (fun _ â†¦ (hG.prod hS)) (fun i â†¦ âŸ¨ X i, Y i âŸ©) ) : D[X | Y; fun _ â†¦ hÎ©] = D[X | fun i â†¦ âŸ¨ Ï€ âˆ˜ (X i), Y i âŸ©; fun _ â†¦ hÎ©] + D[ fun i â†¦ Ï€ âˆ˜ (X i) | Y; fun _ â†¦ hÎ©] + I[ âˆ‘ i, X i : fun Ï‰ â†¦ (fun i â†¦ Ï€ (X i Ï‰)) | âŸ¨ Ï€ âˆ˜ (âˆ‘ i, X i), fun Ï‰ â†¦ (fun i â†¦ Y i Ï‰)âŸ©] :=



Theorem: condRho_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_le {Î© S : Type*} [MeasureSpace Î©] [MeasurableSpace S] (X : Î© â†’ G) (Z : Î© â†’ S) (A : Finset G) : condRho X Z A â‰¤ rho X A + (H[ X ] - H[ X | Z ]) / 2 :=



Theorem: cor_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cor_multiDist_chainRule [Fintype G] {m:â„•} (hm: m â‰¥ 1) {Î© : Type*} (hÎ© : MeasureSpace Î©) (X : Fin (m+1) Ã— Fin (m+1) â†’ Î© â†’ G) (hindep : iIndepFun (fun _ â†¦ hG) X) : I[ fun Ï‰ â†¦ (fun j â†¦ âˆ‘ i, X (i, j) Ï‰) : fun Ï‰ â†¦ (fun i â†¦ âˆ‘ j, X (i, j) Ï‰) | âˆ‘ p, X p] â‰¤ âˆ‘ j, (D[ fun i â†¦ X (i, j); fun _ â†¦ hÎ©] -  D[ fun i â†¦ X (i, j) | fun i â†¦ âˆ‘ k âˆˆ Finset.Ici j, X (i, k); fun _ â†¦ hÎ©]) + D[ fun i â†¦ X (i, m); fun _ â†¦ hÎ©] - D[ fun i â†¦ âˆ‘ j, X (i, j); fun _ â†¦ hÎ©] :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 27

Theorem: MellinInversion_aux1
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux1 {f : â„ â†’ â„‚} {s : â„‚} (s_ne_zero : s â‰  0)
    (fDiff : DifferentiableOn â„ f (Ioi 0))
    (hfs : Tendsto (fun x â†¦ f x * x ^ s) (ð“[>]0) (ð“ 0))
    (hfinf : Tendsto (fun x â†¦ f x * x ^ s) atTop (ð“ 0)) :
    âˆ« x in Ioi 0, f x * x ^ s / x = - âˆ« x in Ioi 0, (deriv f x) * x ^ s / s :=



Theorem: pi_alt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pi_alt : âˆƒ c : â„ â†’ â„, c =o[atTop] (fun _ â†¦ (1:â„)) âˆ§
    âˆ€ x : â„, Nat.primeCounting âŒŠxâŒ‹â‚Š = (1 + c x) * x / log x :=



Theorem: auto_cheby
File path: PrimeNumberTheoremAnd/Wiener.lean
Theorem statement: lemma auto_cheby (hpos: 0 â‰¤ f) (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ'))
    (hG: ContinuousOn G {s | 1 â‰¤ s.re})
    (hG' : Set.EqOn G (fun s â†¦ LSeries f s - A / (s - 1)) {s | 1 < s.re}) : cheby f :=



Theorem: MellinInversion_aux3
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux3 {f : â„ â†’ â„‚} (Ïƒ : â„) (Ïƒ_ne_zero : Ïƒ â‰  0) (Ïƒ_ne_negOne : Ïƒ â‰  -1)
    (fInt : IntegrableOn (fun x â†¦ f x * (x : â„‚) ^ (Ïƒ : â„‚)) (Ioi 0)) :
    IntegrableOn (fun (âŸ¨x, tâŸ© : â„ Ã— â„) â†¦ f x * x ^ (Ïƒ + t * I) / ((Ïƒ + t * I) * ((Ïƒ + t * I) + 1)))
      ((Ioi 0).prod (univ : Set â„)) :=



Theorem: integrable_x_mul_Smooth1
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma integrable_x_mul_Smooth1 {Ïˆ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Ïˆ) (Ïˆpos : âˆ€ (x : â„), 0 â‰¤ Ïˆ x)
    (suppÎ¨ : support Ïˆ âŠ† Icc (1 / 2) 2) (mass_one : âˆ« (x : â„) in Ioi 0, Ïˆ x / x = 1)
    (Îµ : â„) (Îµpos : 0 < Îµ) :
    MeasureTheory.IntegrableOn (fun x â†¦ x * Smooth1 Ïˆ Îµ x) (Ioi 0) :=



Theorem: MediumPNT
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: theorem MediumPNT : âˆƒ (c : â„) (hc : c > 0),
    (ChebyshevPsi - id) =O[atTop] (fun (x : â„) â†¦ x * Real.exp (-c * (Real.log x) ^ ((1 : â„) / 18))) :=



Theorem: chebyshev_asymptotic_finsum
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem chebyshev_asymptotic_finsum :
    (fun x â†¦ âˆ‘á¶  (p:â„•) (_: p â‰¤ x) (_: Nat.Prime p), log p) ~[atTop] (fun x â†¦ x) :=



Theorem: ZetaDerivUpperBnd''
File path: PrimeNumberTheoremAnd/ZetaBounds.lean
Theorem statement: lemma ZetaDerivUpperBnd'' {A Ïƒ : â„} (hA : A âˆˆ Ioc 0 (1 / 2))
    (Ïƒ_le : Ïƒ â‰¤ 2) :
    (fun (t : â„) â†¦
    â€–âˆ‘ n in Finset.range (âŒŠ|t|âŒ‹â‚Š + 1), -1 / (n : â„‚) ^ (Ïƒ + t * I) * (Real.log n)â€– +
      â€–-(âŒŠ|t|âŒ‹â‚Š : â„‚) ^ (1 - (Ïƒ + t * I)) / (1 - (Ïƒ + t * I)) ^ 2â€– +
      â€–(Real.log âŒŠ|t|âŒ‹â‚Š) * (âŒŠ|t|âŒ‹â‚Š : â„‚) ^ (1 - (Ïƒ + t * I)) / (1 - (Ïƒ + t * I))â€– +
      â€–(Real.log âŒŠ|t|âŒ‹â‚Š) * (âŒŠ|t|âŒ‹â‚Š : â„‚) ^ (-(Ïƒ + t * I)) / 2â€– +
      â€–(1 * âˆ« (x : â„) in Ioi (âŒŠ|t|âŒ‹â‚Š : â„), (âŒŠxâŒ‹ + 1 / 2 - x) * (x : â„‚) ^ (-(Ïƒ + t * I) - 1))â€– +
      â€–(Ïƒ + t * I) * âˆ« (x : â„) in Ioi (âŒŠ|t|âŒ‹â‚Š : â„),
        (âŒŠxâŒ‹ + 1 / 2 - x) * (x : â„‚) ^ (-(Ïƒ + t * I) - 1) * -(Real.log x)â€–)
        =O[atTop âŠ“ Filter.principal {t : â„ | |t| < Real.exp (A / (1 - Ïƒ))}] fun t â†¦ Real.log |t| ^ 2 :=



Theorem: pn_pn_plus_one
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pn_pn_plus_one : âˆƒ c : â„• â†’ â„, c =o[atTop] (fun _ â†¦ (1:â„)) âˆ§
    âˆ€ n : â„•, Nat.nth Nat.Prime (n+1) - Nat.nth Nat.Prime n = (c n) * Nat.nth Nat.Prime n :=



Theorem: chebyshev_asymptotic
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem chebyshev_asymptotic :
    (fun x â†¦ âˆ‘ p in (filter Nat.Prime (range âŒˆxâŒ‰â‚Š)), log p) ~[atTop] (fun x â†¦ x) :=



Theorem: MellinInversion_aux2
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux2 {f : â„ â†’ â„‚} (s : â„‚) (fDiff : DifferentiableOn â„ f (Ioi 0))
    (fDiff2 : DifferentiableOn â„ (deriv f) (Ioi 0))
    (hfs : Tendsto (fun x â†¦ deriv f x * x ^ s) (ð“[>]0) (ð“ 0))
    (hfinf : Tendsto (fun x â†¦ deriv f x * x ^ s) atTop (ð“ 0)) :
    âˆ« x in Ioi 0, (deriv f x) * x ^ s =
      -âˆ« x in Ioi 0, (deriv (deriv f) x) * x ^ (s + 1) / (s + 1) :=



Theorem: lambda_pnt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem lambda_pnt : (fun x:â„ â†¦ âˆ‘ n in range âŒŠ x âŒ‹â‚Š, (-1)^(Î© n)) =o[atTop] (fun x â†¦ x) :=



Theorem: SmoothedChebyshevClose
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma SmoothedChebyshevClose {Ïˆ : â„ â†’ â„} (Îµ : â„) (Îµ_pos: 0 < Îµ)
    (suppÎ¨ : Function.support Ïˆ âŠ† Icc (1 / 2) 2) (Î¨nonneg : âˆ€ x > 0, 0 â‰¤ Ïˆ x)
    (mass_one : âˆ« x in Ioi 0, Ïˆ x / x = 1) (X : â„) :
    (fun X â†¦ â€–SmoothedChebyshev Ïˆ Îµ X - ChebyshevPsi Xâ€–) =O[atTop]
      (fun X â†¦ Îµ * X * Real.log X) :=



Theorem: prime_between
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem prime_between {Îµ:â„} (hÎµ: 0 < Îµ): âˆ€á¶  x:â„ in atTop, âˆƒ p:â„•, Nat.Prime p âˆ§
    x < p âˆ§ p < (1+Îµ)* x :=



Theorem: crude_upper_bound
File path: PrimeNumberTheoremAnd/Wiener.lean
Theorem statement: lemma crude_upper_bound
    (hpos: 0 â‰¤ f)
    (hG: ContinuousOn G {s | 1 â‰¤ s.re})
    (hG' : Set.EqOn G (fun s â†¦ LSeries f s - A / (s - 1)) {s | 1 < s.re})
    (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ'))
    (Ïˆ : CS 2 â„‚)
    (hÏˆpos : âˆ€ y, 0 â‰¤ (ð“• Ïˆ y).re âˆ§ (ð“• Ïˆ y).im = 0) :
    âˆƒ B : â„, âˆ€ x : â„, 0 < x â†’ â€–âˆ‘' n, f n / n * ð“• Ïˆ (1 / (2 * Ï€) * log (n / x))â€– â‰¤ B :=



Theorem: mu_pnt_alt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem mu_pnt_alt : (fun x:â„ â†¦ âˆ‘ n in range âŒŠ x âŒ‹â‚Š, (Î¼ n: â„) / n) =o[atTop] (fun x â†¦ (1:â„)) :=



Theorem: vertical_integrable_Smooth1
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma vertical_integrable_Smooth1 {Ïˆ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Ïˆ) (Ïˆpos : âˆ€ (x : â„), 0 â‰¤ Ïˆ x)
    (suppÎ¨ : support Ïˆ âŠ† Icc (1 / 2) 2) (mass_one : âˆ« (x : â„) in Ioi 0, Ïˆ x / x = 1)
    (Îµ : â„) (Îµpos : 0 < Îµ) :
    MeasureTheory.Integrable
      (fun (y : â„) â†¦ âˆ« (t : â„) in Ioi 0, (t : â„‚) ^ (1 + y * I) * (Smooth1 Ïˆ Îµ t : â„‚)) :=



Theorem: continuousAt_Smooth1
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma continuousAt_Smooth1 {Ïˆ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Ïˆ) (Ïˆpos : âˆ€ (x : â„), 0 â‰¤ Ïˆ x)
    (suppÎ¨ : support Ïˆ âŠ† Icc (1 / 2) 2) (mass_one : âˆ« (x : â„) in Ioi 0, Ïˆ x / x = 1)
    (Îµ : â„) (Îµpos : 0 < Îµ) (y : â„) (ypos : 0 < y) :
    ContinuousAt (fun x â†¦ Smooth1 Ïˆ Îµ x) y :=



Theorem: SmoothedChebyshevDirichlet
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: theorem SmoothedChebyshevDirichlet {Ïˆ : â„ â†’ â„} (diffÎ¨ : ContDiff â„ 1 Ïˆ) (Ïˆpos : âˆ€ x, 0 â‰¤ Ïˆ x)
    (suppÎ¨ : Function.support Ïˆ âŠ† Icc (1 / 2) 2) (mass_one: âˆ« x in Ioi (0 : â„), Ïˆ x / x = 1)
    (X : â„) (X_pos : 0 < X) (Îµ : â„) (Îµpos: 0 < Îµ) :
    SmoothedChebyshev Ïˆ Îµ X = âˆ‘' n, Î› n * Smooth1 Ïˆ Îµ (n / X) :=



Theorem: DerivUpperBnd_aux7
File path: PrimeNumberTheoremAnd/ZetaBounds.lean
Theorem statement: theorem DerivUpperBnd_aux7 {A Ïƒ t : â„} (t_gt : 3 < |t|) (hÏƒ : Ïƒ âˆˆ Icc (1 - A / |t|.log) 2) :
    let N := âŒŠ|t|âŒ‹â‚Š;
    let s := â†‘Ïƒ + â†‘t * I;
    0 < N â†’ â†‘N â‰¤ |t| â†’ s â‰  1 â†’ 1 / 2 < Ïƒ â†’
    â€–s * âˆ« (x : â„) in Ioi (N : â„), (â†‘âŒŠxâŒ‹ + 1 / 2 - â†‘x) * (x : â„‚) ^ (-s - 1) * -â†‘x.logâ€– â‰¤
      2 * |t| * â†‘N ^ (-Ïƒ) / Ïƒ * |t|.log :=



Theorem: limiting_fourier_variant
File path: PrimeNumberTheoremAnd/Wiener.lean
Theorem statement: lemma limiting_fourier_variant
    (hpos: 0 â‰¤ f)
    (hG: ContinuousOn G {s | 1 â‰¤ s.re})
    (hG' : Set.EqOn G (fun s â†¦ LSeries f s - A / (s - 1)) {s | 1 < s.re})
    (hf : âˆ€ (Ïƒ' : â„), 1 < Ïƒ' â†’ Summable (nterm f Ïƒ'))
    (Ïˆ : CS 2 â„‚)
    (hÏˆpos : âˆ€ y, 0 â‰¤ (ð“• Ïˆ y).re âˆ§ (ð“• Ïˆ y).im = 0)
    (hx : 1 â‰¤ x) :
    âˆ‘' n, f n / n * ð“• Ïˆ (1 / (2 * Ï€) * log (n / x)) -
      A * âˆ« u in Set.Ici (-log x), ð“• Ïˆ (u / (2 * Ï€)) =
      âˆ« (t : â„), (G (1 + t * I)) * (Ïˆ t) * x ^ (t * I) :=



Theorem: mu_pnt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem mu_pnt : (fun x:â„ â†¦ âˆ‘ n in range âŒŠ x âŒ‹â‚Š, Î¼ n) =o[atTop] (fun x â†¦ x) :=



Theorem: primorial_bounds_finprod
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem primorial_bounds_finprod :
    âˆƒ E : â„ â†’ â„, E =o[atTop] (fun x â†¦ x) âˆ§
    âˆ€ x : â„, âˆá¶  (p:â„•) (_:p â‰¤ x) (_:Nat.Prime p), p = exp ( x + E x ) :=



Theorem: MellinInversion_aux4
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux4 {f : â„ â†’ â„‚} (Ïƒ : â„) (Ïƒ_ne_zero : Ïƒ â‰  0) (Ïƒ_ne_negOne : Ïƒ â‰  -1)
    (fInt : IntegrableOn (fun x â†¦ f x * (x : â„‚) ^ (Ïƒ : â„‚)) (Ioi 0)) :
    VerticalIntegral (fun s â†¦ âˆ« x in Ioi 0, f x * (x : â„‚) ^ (s + 1) / (s * (s + 1))) Ïƒ =
      âˆ« x in Ioi 0, VerticalIntegral (fun s â†¦ f x * (x : â„‚) ^ (s + 1) / (s * (s + 1))) Ïƒ :=



Theorem: pi_asymp
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pi_asymp :
    âˆƒ c : â„ â†’ â„, c =o[atTop] (fun _ â†¦ (1:â„)) âˆ§
    âˆ€ x : â„, Nat.primeCounting âŒŠxâŒ‹â‚Š = (1 + c x) * âˆ« t in Set.Icc 2 x, 1 / (log t) âˆ‚ volume :=



Theorem: primorial_bounds
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem primorial_bounds :
    âˆƒ E : â„ â†’ â„, E =o[atTop] (fun x â†¦ x) âˆ§
    âˆ€ x : â„, âˆ p in (filter Nat.Prime (range âŒŠxâŒ‹â‚Š)), p = exp ( x + E x ) :=



Theorem: pn_asymptotic
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pn_asymptotic : âˆƒ c : â„• â†’ â„, c =o[atTop] (fun _ â†¦ (1:â„)) âˆ§
    âˆ€ n : â„•, Nat.nth Nat.Prime n = (1 + c n) * n * log n :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 5

Theorem: Imo2001P1.lemma1
File path: Compfiles/Imo2001P1.lean
Theorem statement: lemma lemma1
    (t : Affine.Triangle â„ (EuclideanSpace â„ (Fin 2)))
    : âˆ¡ t.circumcenter (t.points 2) (t.points 1) =
      Real.pi - âˆ¡ (t.points 1) (t.points 0) (t.points 2) :=



Theorem: Bulgaria1998P6.lemma_1'
File path: Compfiles/Bulgaria1998P6.lean
Theorem statement: lemma lemma_1'
    (a b c : â„•)
    (ha : 0 < a)
    (hb : 0 < b)
    (hc : 0 < c)
    (h : a^4 = b^4 + c^2) : False :=



Theorem: Imo2008P5.claim
File path: Compfiles/Imo2008P5.lean
Theorem statement: lemma claim (n k : â„•) (hn : 0 < n) (hnk : n â‰¤ k) (he : Even (k - n))
    (f : {b : Sequence n k // MSequence n k b }) :
    Set.ncard {g | Ïˆ n k g = f} = 2^(k - n) :=



Theorem: Imo2008P5.even_subsets_card
File path: Compfiles/Imo2008P5.lean
Theorem statement: lemma even_subsets_card {Î± : Type} [Fintype Î±] :
    Fintype.card {s : Finset Î± // Even (Finset.card s) } = 2^(Fintype.card Î± - 1) :=



Theorem: Imo2009P6.imo2009_p6_aux1
File path: Compfiles/Imo2009P6.lean
Theorem statement: theorem imo2009_p6_aux1 (n : â„•) (hn : 0 < n)
    (a : Fin n â†’ â„¤)
    (ainj : a.Injective)
    (apos : âˆ€ i, 0 < a i)
    (asorted : âˆ€ i j, i < j â†’ a i < a j)
    (M : Finset â„¤)
    (Mpos : âˆ€ m âˆˆ M, 0 < m)
    (Mcard : M.card â‰¤ n - 1)
    (hM : âˆ‘ i, a i âˆ‰ M)
    : âˆƒ p : Equiv.Perm (Fin n),
          âˆ€ i : Fin n, âˆ‘ j âˆˆ Finset.filter (Â· â‰¤ i) Finset.univ, a (p j) âˆ‰ M :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
================================================================================

Unproved sorry theorems only in first database: 2

Theorem: MyRing.self_sub
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem self_sub (a : R) : a - a = 0 :=


Theorem: C03S04.aux
File path: MIL/C03_Logic/S04_Conjunction_and_Iff.lean
Theorem statement: None


Unproved sorry theorems only in second database: 4

Theorem: MyRing.add_right_cancel
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_right_cancel {a b c : R} (h : a + b = c + b) : a = c :=


Theorem: C03S05.MyAbs.neg_le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem neg_le_abs_self (x : â„) : -x â‰¤ |x| :=


Theorem: C03S05.MyAbs.abs_add
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem abs_add (x y : â„) : |x + y| â‰¤ |x| + |y| :=


Theorem: MyRing.zero_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem zero_mul (a : R) : 0 * a = 0 :=


Common Unproved sorry theorems: 13

Theorem: C03S05.MyAbs.abs_lt
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem abs_lt : |x| < y â†” -y < x âˆ§ x < y :=



Theorem: C03S05.MyAbs.lt_abs
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem lt_abs : x < |y| â†” x < y âˆ¨ x < -y :=



Theorem: C03S01.my_lemma3
File path: MIL/C03_Logic/S01_Implication_and_the_Universal_Quantifier.lean
Theorem statement: theorem my_lemma3 :
    âˆ€ {x y Îµ : â„}, 0 < Îµ â†’ Îµ â‰¤ 1 â†’ |x| < Îµ â†’ |y| < Îµ â†’ |x * y| < Îµ :=



Theorem: C03S06.convergesTo_add
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_add {s t : â„• â†’ â„} {a b : â„}
      (cs : ConvergesTo s a) (ct : ConvergesTo t b) :
    ConvergesTo (fun n â†¦ s n + t n) (a + b) :=



Theorem: C03S01.Subset.trans
File path: MIL/C03_Logic/S01_Implication_and_the_Universal_Quantifier.lean
Theorem statement: theorem Subset.trans : r âŠ† s â†’ s âŠ† t â†’ r âŠ† t :=



Theorem: cauchySeq_of_le_geometric_two'
File path: MIL/C09_Topology/S02_Metric_Spaces.lean
Theorem statement: theorem cauchySeq_of_le_geometric_two' {u : â„• â†’ X}
    (hu : âˆ€ n : â„•, dist (u n) (u (n + 1)) â‰¤ (1 / 2) ^ n) : CauchySeq u :=



Theorem: C03S06.exists_abs_le_of_convergesTo
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem exists_abs_le_of_convergesTo {s : â„• â†’ â„} {a : â„} (cs : ConvergesTo s a) :
    âˆƒ N b, âˆ€ n, N â‰¤ n â†’ |s n| < b :=



Theorem: MyRing.two_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem two_mul (a : R) : 2 * a = a + a :=



Theorem: C03S05.MyAbs.le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem le_abs_self (x : â„) : x â‰¤ |x| :=



Theorem: Cantor
File path: MIL/C04_Sets_and_Functions/S02_Functions.lean
Theorem statement: theorem Cantor : âˆ€ f : Î± â†’ Set Î±, Â¬Surjective f :=



Theorem: C03S06.convergesTo_mul_const
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_mul_const {s : â„• â†’ â„} {a : â„} (c : â„) (cs : ConvergesTo s a) :
    ConvergesTo (fun n â†¦ c * s n) (c * a) :=



Theorem: C03S06.convergesTo_unique
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_unique {s : â„• â†’ â„} {a b : â„}
      (sa : ConvergesTo s a) (sb : ConvergesTo s b) :
    a = b :=



Theorem: C03S06.aux
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem aux {s t : â„• â†’ â„} {a : â„} (cs : ConvergesTo s a) (ct : ConvergesTo t 0) :
    ConvergesTo (fun n â†¦ s n * t n) 0 :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 4

Theorem: Lean4Lean.NormalEq.trans
File path: Lean4Lean/Theory/Typing/ParallelReduction.lean
Theorem statement: theorem NormalEq.trans
    (H1 : NormalEq TY Î“ e1 e2) (H2 : NormalEq TY Î“ e2 e3) :
    NormalEq TY Î“ e1 e3 :=



Theorem: Lean4Lean.VEnv.IsDefEqU.weakN_iff
File path: Lean4Lean/Theory/Typing/UniqueTyping.lean
Theorem statement: theorem IsDefEqU.weakN_iff (W : Ctx.LiftN n k Î“ Î“') :
    env.IsDefEqU U Î“' (e1.liftN n k) (e2.liftN n k) â†” env.IsDefEqU U Î“ e1 e2 :=



Theorem: Lean4Lean.VEnv.IsDefEq.induction1
File path: Lean4Lean/Theory/Typing/Stratified.lean
Theorem statement: theorem IsDefEq.induction1
    (defEq : List VExpr â†’ VExpr â†’ VExpr â†’ VExpr â†’ Prop)
    (hasType : List VExpr â†’ VExpr â†’ VExpr â†’ Prop)
    (hty : âˆ€ {Î“ e A}, HasType1 env U defEq Î“ e A â†’ hasType Î“ e A)
    (hdf : âˆ€ {Î“ e1 e2 A}, IsDefEq1 env U hasType defEq Î“ e1 e2 A â†’ defEq Î“ e1 e2 A)
    (H : env.IsDefEq U Î“ e1 e2 A) :
    HasType1 env U defEq Î“ e1 A âˆ§
    HasType1 env U defEq Î“ e2 A âˆ§
    IsDefEq1 env U hasType defEq Î“ e1 e2 A :=



Theorem: Lean4Lean.VEnv.IsDefEq.inductionU1
File path: Lean4Lean/Theory/Typing/StratifiedUntyped.lean
Theorem statement: theorem IsDefEq.inductionU1
    (defEq : List VExpr â†’ VExpr â†’ VExpr â†’ Prop)
    (hasType : List VExpr â†’ VExpr â†’ VExpr â†’ Prop)
    (hty : âˆ€ {Î“ e A}, HasTypeU1 env U defEq Î“ e A â†’ hasType Î“ e A)
    (hdf : âˆ€ {Î“ e1 e2 A1 A2},
      HasTypeU1 env U defEq Î“ e1 A1 â†’ HasTypeU1 env U defEq Î“ e2 A2 â†’
      IsDefEqU1 env U hasType Î“ e1 e2 â†’ defEq Î“ e1 e2)
    (H : env.IsDefEq U Î“ e1 e2 A) :
    HasTypeU1 env U defEq Î“ e1 A âˆ§
    HasTypeU1 env U defEq Î“ e2 A âˆ§
    IsDefEqU1 env U hasType Î“ e1 e2 :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 7

Theorem: MatrixCookbook.eq_446
File path: MatrixCookbook/9SpecialMatrices.lean
Theorem statement: theorem eq_446 (A : Matrix l m R) (B : Matrix n p R) (k i j l) :
    A k i * B j l = (A * stdBasisMatrix i j (1 : R) * B) k l :=



Theorem: MatrixCookbook.eq_258
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_258 (h : IsUnit E) :
    (A.map (â†‘) + B.map (Â· â€¢ I))â»Â¹ =
      (E + F * Eâ»Â¹ * F)â»Â¹.map (â†‘) *
        ((1 - t â€¢ (F * Eâ»Â¹).map (â†‘)) - (t â€¢ 1 + (F * Eâ»Â¹)).map (Â· â€¢ I)) :=



Theorem: MatrixCookbook.eq_533
File path: MatrixCookbook/10FunctionsAndOperators.lean
Theorem statement: lemma eq_533 (A : Matrix m n â„) : â€–Aâ€– = sSup { â€–A.mulVec xâ€– | (x) (hx : â€–xâ€– = 1)} :=



Theorem: MatrixCookbook.eq_257
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_257 (h : IsUnit E)  :
    (A.map (â†‘) + B.map (Â· â€¢ I))â»Â¹ =
      (1 - t â€¢ I : â„‚) â€¢ ((E + F * Eâ»Â¹ * F)â»Â¹.map (â†‘) * (1 - (F * Eâ»Â¹).map (Â· â€¢ I))) :=



Theorem: MatrixCookbook.eq_256
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_256 (h : IsUnit E)  :
    (A.map (â†‘) + B.map (Â· â€¢ I))â»Â¹ =
      (1 - t â€¢ I : â„‚) â€¢ ((E + F * Eâ»Â¹ * F)â»Â¹.map (â†‘) - ((E + F * Eâ»Â¹ * F)â»Â¹ * F * E).map (Â· â€¢ I))â»Â¹ :=



Theorem: MatrixCookbook.eq_160
File path: MatrixCookbook/3Inverses.lean
Theorem statement: theorem eq_160 (b c : n â†’ â„‚) :
    (A + col b * row c)â»Â¹ = Aâ»Â¹ - (1 + c â¬áµ¥ Aâ»Â¹.mulVec b)â»Â¹ â€¢ Aâ»Â¹ * (col b * row c) * Aâ»Â¹ :=



Theorem: MatrixCookbook.eq_259
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_259 (h : IsUnit E) :
    (A.map (â†‘) + B.map (Â· â€¢ I))â»Â¹ =
      ((E + F * Eâ»Â¹ * F)â»Â¹ * (1 - t â€¢ (F * Eâ»Â¹))).map (â†‘) -
       ((E + F * Eâ»Â¹ * F)â»Â¹ * (t â€¢ 1 + (F * Eâ»Â¹))).map (Â· â€¢ I) :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0
Repository https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab) not found in the second database.

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0
