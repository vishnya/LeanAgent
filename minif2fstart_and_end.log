2024-09-22 03:45:22.527 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-22 03:45:22.527 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-22 03:45:35.412 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-22 03:45:35.412 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-22 03:45:37.352 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-22 03:45:37.352 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-22 03:45:52.374 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-22 03:45:52.375 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-22 03:46:10.527 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-22 03:46:10.527 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-22 03:46:12.201 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-22 03:46:12.202 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-22 03:46:30.859 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-22 03:46:30.859 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-22 03:46:31.006 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-22 03:46:31.006 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-22 03:46:32.660 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-22 03:46:32.660 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-22 03:46:53.893 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-22 03:46:53.893 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-22 03:46:54.266 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-22 03:46:54.267 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-22 03:46:54.906 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-22 03:46:54.906 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-22 03:46:55.056 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-22 03:46:55.057 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-22 03:46:55.147 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-22 03:46:55.148 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-22 03:46:55.894 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-22 03:46:55.895 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-22 03:46:56.197 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-22 03:46:56.198 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-22 03:47:22.399 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/flt-regular (commit: 359ab563c7ba5d775c1878ac7b3d0c4095b37ec4)
2024-09-22 03:47:22.400 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/flt-regular (commit: 359ab563c7ba5d775c1878ac7b3d0c4095b37ec4)
2024-09-22 03:47:24.225 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/rami3l/plfl (commit: 1a25fc310d8fb0c6e21ab9e385cc7dac0c31f77a)
2024-09-22 03:47:24.225 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/rami3l/plfl (commit: 1a25fc310d8fb0c6e21ab9e385cc7dac0c31f77a)
2024-09-22 03:47:26.040 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yangky11/miniF2F-lean4 (commit: 9e445f5435407f014b88b44a98436d50dd7abd00)
2024-09-22 03:47:26.040 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yangky11/miniF2F-lean4 (commit: 9e445f5435407f014b88b44a98436d50dd7abd00)
2024-09-22 03:48:52.095 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-22 03:48:52.095 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
2024-09-22 03:48:54.032 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-22 03:48:54.032 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
2024-09-22 03:49:24.281 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-22 03:49:24.281 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
2024-09-22 03:49:26.458 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-22 03:49:26.458 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
2024-09-22 03:49:30.166 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-22 03:49:30.166 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
2024-09-22 03:49:31.878 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-22 03:49:31.878 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
2024-09-22 03:50:07.942 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-22 03:50:07.942 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
2024-09-22 03:50:08.090 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-22 03:50:08.090 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
2024-09-22 03:50:09.767 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-22 03:50:09.768 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
2024-09-22 03:50:11.750 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-22 03:50:11.750 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
2024-09-22 03:50:12.129 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-22 03:50:12.130 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
2024-09-22 03:50:12.779 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-22 03:50:12.779 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
2024-09-22 03:50:12.931 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-22 03:50:12.931 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
2024-09-22 03:50:13.022 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-22 03:50:13.023 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
2024-09-22 03:50:13.785 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-22 03:50:13.786 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
2024-09-22 03:50:14.091 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-22 03:50:14.092 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
2024-09-22 03:50:17.792 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/leanprover-community/flt-regular (commit: 359ab563c7ba5d775c1878ac7b3d0c4095b37ec4)
2024-09-22 03:50:17.793 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/leanprover-community/flt-regular (commit: 359ab563c7ba5d775c1878ac7b3d0c4095b37ec4)
2024-09-22 03:50:19.626 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/rami3l/plfl (commit: 1a25fc310d8fb0c6e21ab9e385cc7dac0c31f77a)
2024-09-22 03:50:19.626 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/rami3l/plfl (commit: 1a25fc310d8fb0c6e21ab9e385cc7dac0c31f77a)
2024-09-22 03:51:02.044 | INFO     | dynamic_database:add_repository:600 - Attempting to add repository: https://github.com/yangky11/miniF2F-lean4 (commit: 9e445f5435407f014b88b44a98436d50dd7abd00)
2024-09-22 03:51:02.045 | INFO     | dynamic_database:add_repository:603 - Added new repository: https://github.com/yangky11/miniF2F-lean4 (commit: 9e445f5435407f014b88b44a98436d50dd7abd00)

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 22

Theorem: SciLean.ite_pull_measureOf
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_measureOf {X} [MeasurableSpace X] (c : Prop) [Decidable c] (Œº ŒΩ : Measure X) (A : Set X) :
    (if c then Œº else ŒΩ) A
    =
    (if c then Œº A else ŒΩ A) :=

Proof:
  split_ifs <;> rfl
Proofs are identical in both databases.


Theorem: IsLinearMap.isLinearMap_apply
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_apply (i : Œπ) : IsLinearMap R (fun f : (i : Œπ) ‚Üí E i ‚Ü¶ f i) :=

Proof:
  constructor
  all_goals aesop
Proofs are identical in both databases.


Theorem: SciLean.scalar_max_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_zero_one  : max (0 : R) (1 : R) = 1 :=

Proof:
  rw [max_comm]
  simp
Proofs are identical in both databases.


Theorem: SciLean.scalar_min_zero_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_zero_one  : min (0 : R) (1 : R) = 0 :=

Proof:
  rw [min_comm]
  simp
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffAt.id_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.id_rule (x : X) :
    ContCDiffAt K n (fun x : X => x) x :=

Proof:
  unfold SciLean.ContCDiffAt
  tauto
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffAt.comp_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.comp_rule (x : X)
    (f : Y ‚Üí Z) (g : X ‚Üí Y)
    (hf : ContCDiffAt K n f (g x)) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f (g x)) x :=

Proof:
  rw [ContCDiffAt] at *
  aesop
Proofs are identical in both databases.


Theorem: IsLinearMap.isLinearMap_const_zero
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_const_zero
  : IsLinearMap R (fun _ : X => (0 : Y))
  :=

Proof:
  constructor
  all_goals aesop
Proofs are identical in both databases.


Theorem: SciLean.Measure.prod_volume
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_volume {X Y} [MeasureSpace X] [MeasureSpace Y]  :
    (Measure.prod (volume : Measure X) (volume : Measure Y)) = volume :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: Function.Bijective.Equiv.toFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.toFun.arg_a0.Bijective_rule (f : Y ‚âÉ Z) (g : X ‚Üí Y) (hf : Bijective g)
  : Bijective (fun x => f (g x)) :=

Proof:
  inhabit Z
  exact f.bijective.comp hf
Proofs are identical in both databases.


Theorem: SciLean.ite_pull_ennreal_toReal
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem ite_pull_ennreal_toReal (c : Prop) [Decidable c] (x y : ENNReal)  :
    (if c then x else y).toReal
    =
    (if c then x.toReal else y.toReal) :=

Proof:
  split_ifs <;> rfl
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffMapFD.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD.zero_apply : (0 : X ‚üøFD[K,n] Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.Distribution.action_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.action_iteD (A : Set X) (t e : ùíü'(X,Y)) (œÜ : ùíü X) :
   iteD A t e œÜ =
        t.extAction (fun x => if x ‚àà A then œÜ x else 0) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) +
        e.extAction (fun x => if x ‚àâ A then œÜ x else 0) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) :=

Proof:
  aesop
Proofs are identical in both databases.


Theorem: SciLean.SmoothLinearMap.zero_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.zero_apply : (0 : X‚ä∏[K]Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.CDifferentiableAt.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.id_rule (x : X)
  : CDifferentiableAt K (fun x : X => x) x
  :=

Proof:
  unfold SciLean.CDifferentiableAt
  tauto
Proofs are identical in both databases.


Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple
  : Bijective (fun xy : X√óY => (xy.1, xy.2))
  :=

Proof:
  simp
  exact Function.bijective_id
Proofs are identical in both databases.


Theorem: SciLean.ContCDiffMap.zero_apply
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap.zero_apply : (0 : X ‚üø[K,n] Y) x = 0 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: SciLean.norm‚ÇÇ_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_scalar {R} [RealScalar R] (x : R) :
  ‚Äñx‚Äñ‚ÇÇ[R] = Scalar.abs x :=

Proof:
  rw [SciLean.scalar_norm]
Proofs are identical in both databases.


Theorem: SciLean.CDifferentiableAt.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : CDifferentiableAt K (fun x => f (g x)) x
  :=

Proof:
  rw [CDifferentiableAt] at *
  aesop
Proofs are identical in both databases.


Theorem: SciLean.re_float
File path: SciLean/Core/FloatAsReal.lean
Theorem statement: theorem re_float  (a : Float)
  : RCLike.re a = a :=

Proof:
  exact RCLike.re_eq_self_of_le le_rfl
Proofs are identical in both databases.


Theorem: IsAffineMap.IsAffineMap_apply
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_apply (i : Œπ) : IsAffineMap R (fun f : (i : Œπ) ‚Üí E i ‚Ü¶ f i) :=

Proof:
  constructor
  constructor
  simp
  simp
Proofs are identical in both databases.


Theorem: Function.invFun.id_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem id_rule
  : invFun (fun (x : X) => x)
    =
    fun x => x :=

Proof:
  apply Function.invFun_comp
  exact Function.injective_id
Proofs are identical in both databases.


Theorem: SciLean.scalar_div_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_div_one (x : R) : x / 1 = x :=

Proof:
  simp
Proofs are identical in both databases.


================================================================================
Comparing Proved sorry theorems for repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 1

Theorem: condRho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_translate {Œ© S : Type*} [MeasureSpace Œ©] (X : Œ© ‚Üí G) (Y : Œ© ‚Üí S) (A : Finset G) (s:G) : condRho (fun œâ ‚Ü¶ X œâ + s) Y A = condRho X Y A :=

Proof:
  simp only [condRho, rho_of_translate]
Proofs are identical in both databases.


================================================================================
Comparing Proved sorry theorems for repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 20

Theorem: MyRing.add_left_cancel
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_left_cancel {a b c : R} (h : a + b = a + c) : b = c :=

Proof:
  simpa using h
Proofs are identical in both databases.


Theorem: MyRing.zero_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem zero_mul (a : R) : 0 * a = 0 :=

Proof:
  rw [MulZeroClass.zero_mul]
Proofs are identical in both databases.


Theorem: MyRing.two_mul
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem two_mul (a : R) : 2 * a = a + a :=

Proof:
  nontriviality R
  abel
  simp
Proofs are identical in both databases.


Theorem: MyRing.neg_eq_of_add_eq_zero
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem neg_eq_of_add_eq_zero {a b : R} (h : a + b = 0) : -a = b :=

Proof:
  rw [add_eq_zero_iff_eq_neg] at h
  simp [h]
Proofs are identical in both databases.


Theorem: C03S05.MyAbs.neg_le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem neg_le_abs_self (x : ‚Ñù) : -x ‚â§ |x| :=

Proof:
  simpa using C03S05.MyAbs.le_abs_self (-x)
Proofs are identical in both databases.


Theorem: MyGroup.mul_right_inv
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_right_inv (a : G) : a * a‚Åª¬π = 1 :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: absorb1
File path: MIL/C02_Basics/S05_Proving_Facts_about_Algebraic_Structures.lean
Theorem statement: theorem absorb1 : x ‚äì (x ‚äî y) = x :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyGroup.mul_one
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_one (a : G) : a * 1 = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: C03S05.MyAbs.abs_add
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem abs_add (x y : ‚Ñù) : |x + y| ‚â§ |x| + |y| :=

Proof:
  apply abs_add_le
Proofs are identical in both databases.


Theorem: MyGroup.mul_inv_rev
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem mul_inv_rev (a b : G) : (a * b)‚Åª¬π = b‚Åª¬π * a‚Åª¬π :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: C03S01.my_lemma3
File path: MIL/C03_Logic/S01_Implication_and_the_Universal_Quantifier.lean
Theorem statement: theorem my_lemma3 :
    ‚àÄ {x y Œµ : ‚Ñù}, 0 < Œµ ‚Üí Œµ ‚â§ 1 ‚Üí |x| < Œµ ‚Üí |y| < Œµ ‚Üí |x * y| < Œµ :=

Proof:
  apply C03S01.my_lemma
Proofs are identical in both databases.


Theorem: C03S04.aux
File path: MIL/C03_Logic/S04_Conjunction_and_Iff.lean
Theorem statement: None

Proof:
  contrapose! h
  positivity
Proofs are identical in both databases.


Theorem: MyRing.add_neg_cancel_right
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_neg_cancel_right (a b : R) : a + b + -b = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: C03S05.MyAbs.le_abs_self
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem le_abs_self (x : ‚Ñù) : x ‚â§ |x| :=

Proof:
  rw [le_abs]
  simp
Proofs are identical in both databases.


Theorem: MyRing.self_sub
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem self_sub (a : R) : a - a = 0 :=

Proof:
  simp [sub_eq_add_neg]
Proofs are identical in both databases.


Theorem: C03S01.Subset.trans
File path: MIL/C03_Logic/S01_Implication_and_the_Universal_Quantifier.lean
Theorem statement: theorem Subset.trans : r ‚äÜ s ‚Üí s ‚äÜ t ‚Üí r ‚äÜ t :=

Proof:
  exact Set.Subset.trans
Proofs are identical in both databases.


Theorem: MyRing.neg_neg
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem neg_neg (a : R) : - -a = a :=

Proof:
  simp
Proofs are identical in both databases.


Theorem: MyRing.add_right_cancel
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem add_right_cancel {a b c : R} (h : a + b = c + b) : a = c :=

Proof:
  simpa using h
Proofs are identical in both databases.


Theorem: MyRing.eq_neg_of_add_eq_zero
File path: MIL/C02_Basics/S02_Proving_Identities_in_Algebraic_Structures.lean
Theorem statement: theorem eq_neg_of_add_eq_zero {a b : R} (h : a + b = 0) : a = -b :=

Proof:
  rwa [eq_neg_iff_add_eq_zero]
Proofs are identical in both databases.


Theorem: absorb2
File path: MIL/C02_Basics/S05_Proving_Facts_about_Algebraic_Structures.lean
Theorem statement: theorem absorb2 : x ‚äî x ‚äì y = x :=

Proof:
  simp
Proofs are identical in both databases.


================================================================================
Comparing Proved sorry theorems for repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/leanprover-community/flt-regular (commit: 359ab563c7ba5d775c1878ac7b3d0c4095b37ec4)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/rami3l/plfl (commit: 1a25fc310d8fb0c6e21ab9e385cc7dac0c31f77a)
================================================================================

Proved sorry theorems only in first database: 0

Proved sorry theorems only in second database: 0

Common Proved sorry theorems: 0

================================================================================
Comparing Proved sorry theorems for repository: https://github.com/yangky11/miniF2F-lean4 (commit: 9e445f5435407f014b88b44a98436d50dd7abd00)
================================================================================

Proved sorry theorems only in first database: 19

Theorem: mathd_numbertheory_12
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_12 :
  Finset.card (Finset.filter (Œª x => 20‚à£x) (Finset.Icc 15 85)) = 4 :=
Proof:
  decide


Theorem: mathd_algebra_148
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_148
  (c : ‚Ñù)
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = c * x^3 - 9 * x + 3)
  (h‚ÇÅ : f 2 = 9) :
  c = 3 :=
Proof:
  linarith [h‚ÇÄ 2]


Theorem: mathd_numbertheory_233
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_233
  (b :  ZMod (11^2))
  (h‚ÇÄ : b = 24‚Åª¬π) :
  b = 116 :=
Proof:
  exact h‚ÇÄ


Theorem: mathd_algebra_513
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_513
  (a b : ‚Ñù)
  (h‚ÇÄ : 3 * a + 2 * b = 5)
  (h‚ÇÅ : a + b = 2) :
  a = 1 ‚àß b = 1 :=
Proof:
  constructor <;> linarith


Theorem: mathd_algebra_234
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_234 (d : ‚Ñù) (h‚ÇÄ : 27 / 125 * d = 9 / 25) : 3 / 5 * d ^ 3 = 25 / 9 :=
Proof:
  field_simp
  noncomm_ring
  norm_num
  nlinarith


Theorem: mathd_algebra_270
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_270
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, x ‚â† -2 -> f x = 1 / (x + 2)) :
  f (f 1) = 3/7 :=
Proof:
  set_option tactic.skipAssignedInstances false in norm_num [h‚ÇÄ]


Theorem: mathd_algebra_160
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_160
  (n x : ‚Ñù)
  (h‚ÇÄ : n + x = 97)
  (h‚ÇÅ : n + 5 * x = 265) :
  n + 2 * x = 139 :=
Proof:
  linarith


Theorem: mathd_algebra_209
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_209
  (œÉ : Equiv ‚Ñù ‚Ñù)
  (h‚ÇÄ : œÉ.2 2 = 10)
  (h‚ÇÅ : œÉ.2 10 = 1)
  (h‚ÇÇ : œÉ.2 1 = 2) :
  œÉ.1 (œÉ.1 10) = 1 :=
Proof:
  rw [Equiv.invFun_as_coe] at h‚ÇÅ
  rw [‚Üê h‚ÇÄ, ‚Üê h‚ÇÇ]
  simp


Theorem: mathd_numbertheory_293
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_293
  (n : ‚Ñï)
  (h‚ÇÄ : n ‚â§ 9)
  (h‚ÇÅ : 11‚à£20 * 100 + 10 * n + 7) :
  n = 5 :=
Proof:
  omega


Theorem: mathd_algebra_432
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_432
  (x : ‚Ñù) :
  (x + 3) * (2 * x - 6) = 2 * x^2 - 18 :=
Proof:
  ring


Theorem: mathd_algebra_24
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_24
  (x : ‚Ñù)
  (h‚ÇÄ : x / 50 = 40) :
  x = 2000 :=
Proof:
  linarith


Theorem: amc12b_2020_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2020_p2 :
  ((100 ^ 2 - 7 ^ 2):‚Ñù) / (70 ^ 2 - 11 ^ 2) * ((70 - 11) * (70 + 11) / ((100 - 7) * (100 + 7))) = 1 :=
Proof:
  ring


Theorem: induction_12dvd4expnp1p20
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_12dvd4expnp1p20
  (n : ‚Ñï) :
  12 ‚à£ 4^(n+1) + 20 :=
Proof:
  norm_num
  induction' n with n hn
  simp
  omega


Theorem: mathd_numbertheory_35
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_35 (S : Finset ‚Ñï) (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚à£ Nat.sqrt 196) :
    (‚àë k in S, k) = 24 :=
Proof:
  contrapose! h‚ÇÄ
  exact ‚ü®18, by norm_num1‚ü©


Theorem: mathd_algebra_123
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_123 (a b : ‚Ñï) (h‚ÇÄ : 0 < a ‚àß 0 < b) (h‚ÇÅ : a + b = 20) (h‚ÇÇ : a = 3 * b) :
  a - b = 10 :=
Proof:
  omega


Theorem: amc12a_2002_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2002_p6
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n) :
  ‚àÉ m, (m > n ‚àß ‚àÉ p, m * p ‚â§ m + p) :=
Proof:
  lift n to ‚Ñï+ using h‚ÇÄ
  cases' n with n
  exact ‚ü®_, lt_add_of_pos_right _ zero_lt_one, 1, by simp‚ü©


Theorem: mathd_numbertheory_728
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_728 :
  (29^13 - 5^13) % 7 = 3 :=
Proof:
  norm_num


Theorem: mathd_numbertheory_284
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_284 (a b : ‚Ñï) (h‚ÇÄ : 1 ‚â§ a ‚àß a ‚â§ 9 ‚àß b ‚â§ 9)
  (h‚ÇÅ : 10 * a + b = 2 * (a + b)) : 10 * a + b = 18 :=
Proof:
  omega


Theorem: mathd_algebra_346
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_346
  (f g : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = 2 * x - 3)
  (h‚ÇÅ : ‚àÄ x, g x = x + 1) :
  g (f 5 - 1) = 7 :=
Proof:
  simp [h‚ÇÅ]
  norm_num [h‚ÇÄ]


Proved sorry theorems only in second database: 15

Theorem: aime_1989_p8
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1989_p8
  (a b c d e f g : ‚Ñù)
  (h‚ÇÄ : a + 4 * b + 9 * c + 16 * d + 25 * e + 36 * f + 49 * g = 1)
  (h‚ÇÅ : 4 * a + 9 * b + 16 * c + 25 * d + 36 * e + 49 * f + 64 * g = 12)
  (h‚ÇÇ : 9 * a + 16 * b + 25 * c + 36 * d + 49 * e + 64 * f + 81 * g = 123) :
  16 * a + 25 * b + 36 * c + 49 * d + 64 * e + 81 * f + 100 * g = 334 :=
Proof:
  linarith


Theorem: mathd_algebra_141
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_141
  (a b : ‚Ñù)
  (h‚ÇÅ : (a * b)=180)
  (h‚ÇÇ : 2 * (a + b)=54) :
  (a^2 + b^2) = 369 :=
Proof:
  nlinarith


Theorem: induction_1pxpownlt1pnx
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_1pxpownlt1pnx
  (x : ‚Ñù)
  (n : ‚Ñï)
  (h‚ÇÄ : -1 < x)
  (h‚ÇÅ : 0 < n) :
  (1 + ‚Üën*x) ‚â§ (1 + x)^(n:‚Ñï) :=
Proof:
  apply one_add_mul_le_pow
  linarith


Theorem: mathd_algebra_329
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_329
  (x y : ‚Ñù)
  (h‚ÇÄ : 3 * y = x)
  (h‚ÇÅ : 2 * x + 5 * y = 11) :
  x + y = 4 :=
Proof:
  linarith


Theorem: mathd_algebra_547
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_547 (x y : ‚Ñù) (h‚ÇÄ : x = 5) (h‚ÇÅ : y = 2) : Real.sqrt (x ^ 3 - 2 ^ y) = 11 :=
Proof:
  simp [h‚ÇÄ, h‚ÇÅ, sq]
  rw [Real.sqrt_eq_iff_sq_eq] <;> norm_num


Theorem: mathd_algebra_441
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_441
  (x : ‚Ñù)
  (h‚ÇÄ : x ‚â† 0) :
  12 / (x * x) * (x^4 / (14 * x)) * (35 / (3 * x)) = 10 :=
Proof:
  field_simp
  ring


Theorem: mathd_algebra_484
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_484 :
  Real.log 27 / Real.log 3 = 3 :=
Proof:
  field_simp
  rw [‚Üê Real.log_rpow]
  all_goals norm_num


Theorem: mathd_numbertheory_254
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_254 :
  (239 + 174 + 83) % 10 = 6 :=
Proof:
  norm_num


Theorem: mathd_algebra_304
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_304 :
  91^2 = 8281 :=
Proof:
  norm_num


Theorem: mathd_numbertheory_110
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_110 (a b : ‚Ñï) (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß b ‚â§ a) (h‚ÇÅ : (a + b) % 10 = 2)
  (h‚ÇÇ : (2 * a + b) % 10 = 1) : (a - b) % 10 = 6 :=
Proof:
  omega


Theorem: mathd_algebra_143
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_143
  (f g : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = x + 1)
  (h‚ÇÅ : ‚àÄ x, g x = x^2 + 3) :
  f (g 2) = 8 :=
Proof:
  simp [h‚ÇÄ, h‚ÇÅ, h‚ÇÅ]
  norm_num


Theorem: amc12a_2009_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2009_p5 (x : ‚Ñù) (h‚ÇÄ : x ^ 3 - (x + 1) * (x - 1) * x = 5) : x ^ 3 = 125 :=
Proof:
  ring_nf at h‚ÇÄ ‚ä¢
  norm_num [h‚ÇÄ]


Theorem: mathd_numbertheory_342
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_342 :
  54 % 6 = 0 :=
Proof:
  norm_num


Theorem: mathd_numbertheory_328
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_328 :
  (5^999999) % 7 = 6 :=
Proof:
  norm_num


Theorem: mathd_numbertheory_447
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_447 :
  ‚àë k in Finset.filter (Œª x => 3‚à£x) (Finset.Icc 1 49), (k % 10) = 78 :=
Proof:
  decide


Common Proved sorry theorems: 80

Theorem: mathd_algebra_359
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_359
  (y : ‚Ñù)
  (h‚ÇÄ : y + 6 + y = 2 * 12) :
  y = 9 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_algebra_176
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_176
  (x : ‚Ñù) :
  (x + 1)^2 * x = x^3 + 2 * x^2 + x :=

Proof:
  ring
Proofs are identical in both databases.


Theorem: amc12b_2002_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2002_p2
  (x : ‚Ñ§)
  (h‚ÇÄ : x = 4) :
  (3 * x - 2) * (4 * x + 1) - (3 * x - 2) * (4 * x) + 1 = 11 :=

Proof:
  norm_num [h‚ÇÄ]
Proofs are identical in both databases.


Theorem: mathd_numbertheory_370
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_370 (n : ‚Ñï) (h‚ÇÄ : n % 7 = 3) : (2 * n + 1) % 7 = 0 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_algebra_188
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_188
  (œÉ : Equiv ‚Ñù ‚Ñù)
  (h : œÉ.1 2 = œÉ.2 2) :
  œÉ.1 (œÉ.1 2) = 2 :=

Proof:
  simp [h]
Proofs are identical in both databases.


Theorem: mathd_algebra_478
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_478
  (b h v : ‚Ñù)
  (h‚ÇÄ : 0 < b ‚àß 0 < h ‚àß 0 < v)
  (h‚ÇÅ : v = 1 / 3 * (b * h))
  (h‚ÇÇ : b = 30)
  (h‚ÇÉ : h = 13 / 2) :
  v = 65 :=

Proof:
  nlinarith
Proofs are identical in both databases.


Theorem: mathd_algebra_245
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_245 (x : ‚Ñù) (h‚ÇÄ : x ‚â† 0) :
  (4 / x)‚Åª¬π * (3 * x ^ 3 / x) ^ 2 * (1 / (2 * x))‚Åª¬π ^ 3 = 18 * x ^ 8 :=

Proof:
  field_simp
  ring
Proofs are identical in both databases.


Theorem: amc12a_2021_p9
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p9 :
  ‚àè k in Finset.range 7, (2^(2^k) + 3^(2^k)) = 3^128 - 2^128 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_345
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_345 :
  (2000 + 2001 + 2002 + 2003 + 2004 + 2005 + 2006) % 7 = 0 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_125
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_125
  (x y : ‚Ñï)
  (h‚ÇÄ : 0 < x ‚àß 0 < y)
  (h‚ÇÅ : 5 * x = y)
  (h‚ÇÇ : (‚Üëx - (3:‚Ñ§)) + (y - (3:‚Ñ§)) = 30) :
  x = 6 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_100
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_100
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n)
  (h‚ÇÅ : Nat.gcd n 40 = 10)
  (h‚ÇÇ : Nat.lcm n 40 = 280) :
  n = 70 :=

Proof:
  rw [Nat.lcm, h‚ÇÅ] at h‚ÇÇ
  omega
Proofs differ:
Proof in second database:
  delta Nat.lcm at h‚ÇÇ
  rw [h‚ÇÅ] at h‚ÇÇ
  omega


Theorem: mathd_numbertheory_1124
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_1124
  (n : ‚Ñï)
  (h‚ÇÄ : n ‚â§ 9)
  (h‚ÇÅ : 18‚à£374 * 10 + n) :
  n = 4 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_207
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_207 :
  8 * 9^2 + 5 * 9 + 2 = 695 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_239
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_239 :
  (‚àë k in Finset.Icc 1 12, k) % 4 = 2 :=

Proof:
  rfl
Proofs are identical in both databases.


Theorem: mathd_algebra_129
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_129
  (a : ‚Ñù)
  (h‚ÇÄ : a ‚â† 0)
  (h‚ÇÅ : 8‚Åª¬π / 4‚Åª¬π - a‚Åª¬π = 1) :
  a = -2 :=

Proof:
  field_simp at h‚ÇÅ
  linarith
Proofs are identical in both databases.


Theorem: mathd_algebra_412
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_412
  (x y : ‚Ñù)
  (h‚ÇÄ : x + y = 25)
  (h‚ÇÅ : x - y = 11) :
  x = 18 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_321
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_321
  (n :  ZMod 1399)
  (h‚ÇÅ : n = 160‚Åª¬π) :
  n = 1058 :=

Proof:
  exact h‚ÇÅ
Proofs differ:
Proof in second database:
  simpa using h‚ÇÅ


Theorem: mathd_algebra_296
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_296 :
  abs (((3491 - 60) * (3491 + 60) - 3491^2):‚Ñ§) = 3600 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_66
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_66 :
  194 % 11 = 7 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_127
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_127 :
  (‚àë k in (Finset.range 101), 2^k) % 7 = 3 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_302
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_302 :
  (Complex.I / 2)^2 = -(1 / 4) :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_440
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_440
  (x : ‚Ñù)
  (h‚ÇÄ : 3 / 2 / 3 = x / 10) :
  x = 5 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_algebra_33
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_33
  (x y z : ‚Ñù)
  (h‚ÇÄ : x ‚â† 0)
  (h‚ÇÅ : 2 * x = 5 * y)
  (h‚ÇÇ : 7 * y = 10 * z) :
  z / x = 7 / 25 :=

Proof:
  field_simp [h‚ÇÅ, h‚ÇÇ]
  linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_237
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_237 :
  (‚àë k in (Finset.range 101), k) % 6 = 4 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_3
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_3 :
  (‚àë x in Finset.range 10, ((x + 1)^2)) % 10 = 5 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: amc12b_2002_p19
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2002_p19
  (a b c: ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c)
  (h‚ÇÅ : a * (b + c) = 152)
  (h‚ÇÇ : b * (c + a) = 162)
  (h‚ÇÉ : c * (a + b) = 170) :
  a * b * c = 720 :=

Proof:
  nlinarith
Proofs are identical in both databases.


Theorem: mathd_algebra_110
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_110 (q e : ‚ÑÇ) (h‚ÇÄ : q = 2 - 2 * Complex.I) (h‚ÇÅ : e = 5 + 5 * Complex.I) :
    q * e = 20 :=

Proof:
  rw [h‚ÇÄ, h‚ÇÅ]
  ring
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_275
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_275
  (x : ‚Ñù)
  (h : ((11:‚Ñù)^(1 / 4))^(3 * x - 3) = 1 / 5) :
  ((11:‚Ñù)^(1 / 4))^(6 * x + 2) = 121 / 25 :=

Proof:
  norm_num at h
Proofs are identical in both databases.


Theorem: mathd_algebra_289
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_289
  (k t m n : ‚Ñï)
  (h‚ÇÄ : Nat.Prime m ‚àß Nat.Prime n)
  (h‚ÇÅ : t < k)
  (h‚ÇÇ : k^2 - m * k + n = 0)
  (h‚ÇÉ : t^2 - m * t + n = 0) :
  m^n + n^m + k^t + t^k = 20 :=

Proof:
  cases m
  all_goals aesop
Proofs are identical in both databases.


Theorem: mathd_numbertheory_582
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_582
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n)
  (h‚ÇÅ : 3‚à£n) :
  ((n + 4) + (n + 6) + (n + 8)) % 9 = 0 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_algebra_419
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_419
  (a b : ‚Ñù)
  (h‚ÇÄ : a = -1)
  (h‚ÇÅ : b = 5) :
  -a - b^2 + 3 * (a * b) = -39 :=

Proof:
  norm_num [h‚ÇÄ, h‚ÇÅ]
Proofs are identical in both databases.


Theorem: algebra_cubrtrp1oncubrtreq3_rcubp1onrcubeq5778
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_cubrtrp1oncubrtreq3_rcubp1onrcubeq5778
  (r : ‚Ñù)
  (h‚ÇÄ : r^(1 / 3) + 1 / r^(1 / 3) = 3) :
  r^3 + 1 / r^3 = 5778 :=

Proof:
  norm_num at h‚ÇÄ
Proofs are identical in both databases.


Theorem: mathd_algebra_388
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_388
  (x y z : ‚Ñù)
  (h‚ÇÄ : 3 * x + 4 * y - 12 * z = 10)
  (h‚ÇÅ : -2 * x - 3 * y + 9 * z = -4) :
  x = 14 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_algebra_139
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_139
  (s : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, ‚àÄ y, x‚â†0 -> y‚â†0 -> s x y = (1/y - 1/x) / (x-y)) :
  s 3 11 = 1/33 :=

Proof:
  norm_num [h‚ÇÄ]
Proofs are identical in both databases.


Theorem: mathd_numbertheory_99
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_99
  (n : ‚Ñï)
  (h‚ÇÄ : (2 * n) % 47 = 15) :
  n % 47 = 31 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_algebra_158
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_158
  (a : ‚Ñï)
  (h‚ÇÄ : Even a)
  (h‚ÇÅ : ‚àë k in Finset.range 8, (2 * k + 1) - ‚àë k in Finset.range 5, (a + 2 * k) = (4:‚Ñ§)) :
  a = 8 :=

Proof:
  simp only [Finset.sum_range_succ] at h‚ÇÅ
  dsimp at h‚ÇÅ
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_85
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_85 :
  1 * 3^3 + 2 * 3^2 + 2*3 + 2 = 53 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_354
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_354
  (a d : ‚Ñù)
  (h‚ÇÄ : a + 6 * d = 30)
  (h‚ÇÅ : a + 10 * d = 60) :
  a + 20 * d = 135 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_algebra_171
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_171
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄx, f x = 5 * x + 4) :
  f 1 = 9 :=

Proof:
  norm_num [h‚ÇÄ]
Proofs are identical in both databases.


Theorem: mathd_numbertheory_559
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_559
  (x y : ‚Ñï)
  (h‚ÇÄ : x % 3 = 2)
  (h‚ÇÅ : y % 5 = 4)
  (h‚ÇÇ : x % 10 = y % 10) :
  14 ‚â§ x :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_92
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_92 (n : ‚Ñï) (h‚ÇÄ : 5 * n % 17 = 8) : n % 17 = 5 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_algebra_76
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_76
  (f : ‚Ñ§ ‚Üí ‚Ñ§)
  (h‚ÇÄ : ‚àÄn, Odd n ‚Üí f n = n^2)
  (h‚ÇÅ : ‚àÄ n, Even n ‚Üí f n = n^2 - 4*n -1) :
  f 4 = -1 :=

Proof:
  contrapose! h‚ÇÅ
  refine' ‚ü®4, _, _‚ü©
  decide
  exact h‚ÇÅ
Proofs differ:
Proof in second database:
  delta Odd at h‚ÇÄ
  apply h‚ÇÅ
  decide


Theorem: amc12a_2021_p3
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p3
  (x y : ‚Ñï)
  (h‚ÇÄ : x + y = 17402)
  (h‚ÇÅ : 10‚à£x)
  (h‚ÇÇ : x / 10 = y) :
  ‚Üëx - ‚Üëy = (14238:‚Ñ§) :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_229
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_229 :
  (5^30) % 7 = 1 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_33
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_33 (n : ‚Ñï) (h‚ÇÄ : n < 398) (h‚ÇÅ : n * 7 % 398 = 1) : n = 57 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_769
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_769 :
  (129^34 + 96^38) % 11 = 9 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_175
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_175 :
  (2^2010) % 10 = 4 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_80
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_80
  (x : ‚Ñù)
  (h‚ÇÄ : x ‚â† -1)
  (h‚ÇÅ : (x - 9) / (x + 1) = 2) :
  x = -11 :=

Proof:
  rw [div_eq_iff] at h‚ÇÅ
  linarith
  contrapose! h‚ÇÄ
  linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_517
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_517 :
  (121 * 122 * 123) % 4 = 2 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_44
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_44
  (s t : ‚Ñù)
  (h‚ÇÄ : s = 9 - 2 * t)
  (h‚ÇÅ : t = 3 * s + 1) :
  s = 1 ‚àß t = 4 :=

Proof:
  constructor <;> linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_212
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_212 :
  (16^17 * 17^18 * 18^19) % 10 = 8 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_246
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_246
  (a b : ‚Ñù)
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = a * x^4 - b * x^2 + x + 5)
  (h‚ÇÇ : f (-3) = 2) :
  f 3 = 8 :=

Proof:
  rw [h‚ÇÄ] at h‚ÇÇ
  linarith [h‚ÇÄ 3]
Proofs are identical in both databases.


Theorem: mathd_numbertheory_765
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_765
  (x : ‚Ñ§)
  (h‚ÇÄ : x < 0)
  (h‚ÇÅ : (24 * x) % 1199 = 15) :
  x ‚â§ -449 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_185
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_185
  (n : ‚Ñï)
  (h‚ÇÄ : n % 5 = 3) :
  (2 * n) % 5 = 1 :=

Proof:
  rw [Nat.mul_mod, h‚ÇÄ]
Proofs are identical in both databases.


Theorem: amc12a_2016_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2016_p3 (f : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, ‚àÄ (y) (_ : y ‚â† 0), f x y = x - y * Int.floor (x / y)) :
  f (3 / 8) (-(2 / 5)) = -(1 / 40) :=

Proof:
  norm_num [h‚ÇÄ]
  field_simp
  norm_cast
Proofs are identical in both databases.


Theorem: mathd_algebra_427
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_427
  (x y z : ‚Ñù)
  (h‚ÇÄ : 3 * x + y = 17)
  (h‚ÇÅ : 5 * y + z = 14)
  (h‚ÇÇ : 3 * x + 5 * z = 41) :
  x + y + z = 12 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_algebra_142
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_142
  (m b : ‚Ñù)
  (h‚ÇÄ : m * 7 + b = -1)
  (h‚ÇÅ : m * (-1) + b = 7) :
  m + b = 5 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_343
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_343 :
  (‚àè k in Finset.range 6, (2 * k + 1)) % 10 = 5 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_37
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_37 (x y : ‚Ñù) (h‚ÇÄ : x + y = 7) (h‚ÇÅ : 3 * x + y = 45) : x ^ 2 - y ^ 2 = 217 :=

Proof:
  nlinarith
Proofs are identical in both databases.


Theorem: mathd_algebra_314
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_314
  (n : ‚Ñï)
  (h‚ÇÄ : n = 11) :
  (1 / 4)^(n + 1) * 2^(2 * n) = 1 / 4 :=

Proof:
  simp [h‚ÇÄ]
Proofs are identical in both databases.


Theorem: mathd_numbertheory_150
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_150
  (n : ‚Ñï)
  (h‚ÇÄ : ¬¨ Nat.Prime (7 + 30 * n)) :
  6 ‚â§ n :=

Proof:
  contrapose! h‚ÇÄ
  revert n
  decide
Proofs are identical in both databases.


Theorem: mathd_algebra_107
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_107
  (x y : ‚Ñù)
  (h‚ÇÄ : x^2 + 8 * x + y^2 - 6 * y = 0) :
  (x + 4)^2 + (y-3)^2 = 5^2 :=

Proof:
  linear_combination h‚ÇÄ
Proofs differ:
Proof in second database:
  linarith


Theorem: amc12a_2003_p5
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2003_p5
  (A M C : ‚Ñï)
  (h‚ÇÄ : A ‚â§ 9 ‚àß M ‚â§ 9 ‚àß C ‚â§ 9)
  (h‚ÇÅ : Nat.ofDigits 10 [0,1,C,M,A] + Nat.ofDigits 10 [2,1,C,M,A] = 123422) :
  A + M + C = 14 :=

Proof:
  dsimp [Nat.ofDigits] at h‚ÇÅ
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_222
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_222
  (b : ‚Ñï)
  (h‚ÇÄ : Nat.lcm 120 b = 3720)
  (h‚ÇÅ : Nat.gcd 120 b = 8) :
  b = 248 :=

Proof:
  delta Nat.lcm at h‚ÇÄ
  rw [h‚ÇÅ] at h‚ÇÄ
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_135
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_135
  (n A B C : ‚Ñï)
  (h‚ÇÄ : n = 3^17 + 3^10)
  (h‚ÇÅ : 11 ‚à£ (n + 1))
  (h‚ÇÇ : [A,B,C].Pairwise (¬∑‚â†¬∑))
  (h‚ÇÉ : {A,B,C} ‚äÇ Finset.Icc 0 9)
  (h‚ÇÑ : Odd A ‚àß Odd C)
  (h‚ÇÖ : ¬¨ 3 ‚à£ B)
  (h‚ÇÜ : Nat.digits 10 n = [B,A,B,C,C,A,C,B,A]) :
  100 * A + 10 * B + C = 129 :=

Proof:
  apply le_antisymm
  all_goals aesop
Proofs are identical in both databases.


Theorem: mathd_algebra_137
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_137
  (x : ‚Ñï)
  (h‚ÇÄ : ‚Üëx + (4:‚Ñù) / (100:‚Ñù) * ‚Üëx = 598) :
  x = 575 :=

Proof:
  field_simp at h‚ÇÄ
  norm_cast at h‚ÇÄ ‚ä¢
  linarith
Proofs differ:
Proof in second database:
  field_simp at h‚ÇÄ
  norm_cast at h‚ÇÄ ‚ä¢
  omega


Theorem: mathd_numbertheory_34
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_34
  (x: ‚Ñï)
  (h‚ÇÄ : x < 100)
  (h‚ÇÅ : x*9 % 100 = 1) :
  x = 89 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_299
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_299 :
  (1 * 3 * 5 * 7 * 9 * 11 * 13) % 10 = 5 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_algebra_323
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_323 (œÉ : Equiv ‚Ñù ‚Ñù) (h : ‚àÄ x, œÉ.1 x = x ^ 3 - 8) : œÉ.2 (œÉ.1 (œÉ.2 19)) = 3 :=

Proof:
  simp
  rw [Equiv.symm_apply_eq]
  norm_num at h
  linarith [h 3]
Proofs are identical in both databases.


Theorem: mathd_numbertheory_235
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_235 :
  (29 * 79 + 31 * 81) % 10 = 2 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: aime_1990_p4
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1990_p4
  (x : ‚Ñù)
  (h‚ÇÄ : 0 < x)
  (h‚ÇÅ : x^2 - 10 * x - 29 ‚â† 0)
  (h‚ÇÇ : x^2 - 10 * x - 45 ‚â† 0)
  (h‚ÇÉ : x^2 - 10 * x - 69 ‚â† 0)
  (h‚ÇÑ : 1 / (x^2 - 10 * x - 29) + 1 / (x^2 - 10 * x - 45) - 2 / (x^2 - 10 * x - 69) = 0) :
  x = 13 :=

Proof:
  field_simp at h‚ÇÑ
  nlinarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_257
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_257 (x : ‚Ñï) (h‚ÇÄ : 1 ‚â§ x ‚àß x ‚â§ 100)
    (h‚ÇÅ : 77 ‚à£ (‚àë k in Finset.range 101, k) - x) : x = 45 :=

Proof:
  norm_num at h‚ÇÅ
  omega
Proofs are identical in both databases.


Theorem: mathd_algebra_398
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_398
  (a b c : ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c)
  (h‚ÇÅ : 9 * b = 20 * c)
  (h‚ÇÇ : 7 * a = 4 * b) :
  63 * a = 80 * c :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_551
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_551 :
  1529 % 6 = 5 :=

Proof:
  norm_num
Proofs are identical in both databases.


Theorem: mathd_numbertheory_247
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_247
  (n : ‚Ñï)
  (h‚ÇÄ : (3 * n) % 2 = 11) :
  n % 11 = 8 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_algebra_400
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_400
  (x : ‚Ñù)
  (h‚ÇÄ : 5 + 500 / 100 * 10 = 110 / 100 * x) :
  x = 50 :=

Proof:
  linarith
Proofs are identical in both databases.


Theorem: mathd_algebra_263
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_263
  (y : ‚Ñù)
  (h‚ÇÄ : 0 ‚â§ 19 + 3 * y)
  (h‚ÇÅ : Real.sqrt (19 + 3 * y) = 7) :
  y = 10 :=

Proof:
  rw [Real.sqrt_eq_iff_sq_eq] at h‚ÇÅ
  all_goals linarith
Proofs are identical in both databases.


Theorem: mathd_numbertheory_320
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_320
  (n : ‚Ñï)
  (h‚ÇÄ : n < 101)
  (h‚ÇÅ : 101 ‚à£ (123456 - n)) :
  n = 34 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: mathd_numbertheory_458
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_458 (n : ‚Ñï) (h‚ÇÄ : n % 8 = 7) : n % 4 = 3 :=

Proof:
  omega
Proofs are identical in both databases.


Theorem: amc12a_2013_p4
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2013_p4 :
  (2^2014 + 2^2012) / (2^2014 - 2^2012) = (5:‚Ñù) / 3 :=

Proof:
  ring
Proofs differ:
Proof in second database:
  norm_num


================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/lecopivo/SciLean (commit: 22d53b2f4e3db2a172e71da6eb9c916e62655744)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 272

Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ‚üøFD[K,n] Y)√óX) => fx.1 fx.2) :=



Theorem: SciLean.cderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.apply_rule (i : Œπ) :
    (cderiv K fun (x : (i : Œπ) ‚Üí E i) => x i)
    =
    fun _ => fun dx => dx i :=



Theorem: SciLean.HasSemiAdjoint.starRingEnd.arg_a.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a.HasSemiAdjoint_rule
  (f : X ‚Üí K) (_ : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => conj (f x) :=



Theorem: SciLean.cintegral.arg_f.parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem cintegral.arg_f.parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y ‚Üí Z) :
    parDistribDeriv (fun w => (fun x => ‚à´' y, f w x y).toDistribution (R:=R))
    =
    fun w dw =>
      let Tf := (fun w => (fun x => (fun y => f w x y).toDistribution (R:=R)).toDistribution (R:=R))
      parDistribDeriv Tf w dw |>.postComp (fun T ‚ä∏ T.extAction (fun _ => (1:R)) (fun z ‚ä∏ fun r ‚ä∏ r ‚Ä¢ z)) :=



Theorem: SciLean.Bind.bind.arg_fx.DistribDifferentiable_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem Bind.bind.arg_fx.DistribDifferentiable_rule
    (f : X ‚Üí Y ‚Üí ùíü'(Z,V)) (g : X ‚Üí ùíü'(Y,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun x => (g x).bind (f x) L) :=



Theorem: SciLean.SciLean.cderiv.arg_dx.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.cderiv_rule_at
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : cderiv K (fun dx' => cderiv K f y (g dx')) dx
    =
    fun ddx =>
      let ddy := cderiv K g dx ddx
      cderiv K f y ddy :=



Theorem: SciLean.Neg.neg.arg_a0.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiffAt_rule
    (x : X) (f : X ‚Üí Y) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => - f x) x :=



Theorem: SciLean.HAdd.hAdd.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => y + f x)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: SciLean.parDistribFwdDeriv.bind_rule
File path: SciLean/Core/Distribution/ParametricDistribFwdDeriv.lean
Theorem statement: theorem bind_rule
    (f : X ‚Üí Y ‚Üí ùíü'(Z,V)) (g : X ‚Üí ùíü'(Y,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) (hg : DistribDifferentiable g) :
    parDistribFwdDeriv (fun x => (g x).bind (f x) L)
    =
    fun x dx =>
      let ydy := parDistribFwdDeriv g x dx  let zdz := fun y => parDistribFwdDeriv (f ¬∑ y) x dx ydy.bind zdz (fun (r,dr) ‚ä∏ fun (s,ds) ‚ä∏ (L r s, L r ds + L dr s)) :=



Theorem: SciLean.cderiv.pi_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule_at
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : (cderiv K fun (x : X) (i : Œπ) => f x i) x
    =
    fun dx => fun i =>
      cderiv K (f ¬∑ i) x dx
  :=



Theorem: SciLean.Distribution.indextype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.indextype_sum_extAction {I} [IndexType I] (T : I ‚Üí ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (‚àë i, T i).extAction œÜ L = ‚àë i, (T i).extAction œÜ L :=



Theorem: SciLean.CDifferentiableAt.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.const_rule (y : Y) (x : X)
  : CDifferentiableAt K (fun _ : X => y) x
  :=



Theorem: SciLean.Distribution.extAction_iteD
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD (A : Set X) (t e : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (iteD A t e).extAction œÜ L =
        t.extAction (fun x => if x ‚àà A then œÜ x else 0) L +
        e.extAction (fun x => if x ‚àâ A then œÜ x else 0) L :=



Theorem: SciLean.Prod.mk.arg_fstsnd.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.cderiv_rule_at (x : X)
    (g : X ‚Üí Y) (hg : CDifferentiableAt K g x)
    (f : X ‚Üí Z) (hf : CDifferentiableAt K f x) :
    cderiv K (fun x => (g x, f x)) x
    =
    fun dx =>
      (cderiv K g x dx, cderiv K f x dx) :=



Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule_simple'
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule_simple'
  : Bijective (fun xy : X√óY => (xy.2, xy.1))
  :=



Theorem: SciLean.semiAdjoint.comp_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => f (g x))
    =
    fun z =>
      let y := semiAdjoint K f z
      let x := semiAdjoint K g y
      x :=



Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_nat
    (c : ‚Ñï) (f : X ‚Üí Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c ‚Ä¢ f x) x :=



Theorem: IndexType.sum.arg_f.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsLinearMap_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, IsLinearMap R (f ¬∑ i))
  : IsLinearMap R fun x => ‚àë i, f x i :=



Theorem: SciLean.Prod.snd.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.snd.arg_self.CDifferentiable_rule
  (f : X ‚Üí Y√óZ) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).2)  :=



Theorem: SciLean.split_integral_over_set_of_ite
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem split_integral_over_set_of_ite (œÜ œà : X ‚Üí R) (f g : X ‚Üí Y) (A : Set X) :
    (‚à´' x in A, if œà x ‚â§ œÜ x then f x else g x)
    =
    (‚à´' x in {x' | 0 ‚â§ œÜ x' - œà x'} ‚à© A, f x)
    +
    (‚à´' x in {x' | 0 ‚â§ œà x' - œÜ x'} ‚à© A, g x) :=



Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiable (f : W ‚Üí X ‚üøFD[K,‚àû] Y) (g : W ‚Üí X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=



Theorem: Function.invFun.HSub.hSub.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x - y)
    =
    fun y' =>
      invFun f (y' + y)
  :=



Theorem: SciLean.scalar_norm
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem scalar_norm {R} [RealScalar R] (r : R) : ‚Äñr‚Äñ‚ÇÇ[R] = Scalar.abs r :=



Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule_at (x : X) (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) (hx : g x ‚â† 0) :
    (cderiv K fun x => f x / g x) x
    =
    let k := f x
    let k' := g x
    fun dx =>
      ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=



Theorem: SciLean.inner_proj_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_proj_dualProj {Œπ K X} {_ : IndexType Œπ} [LawfulIndexType Œπ] [DecidableEq Œπ] [RCLike K] [FinVec Œπ K X] (x y : X)
  : ‚ü™x, y‚ü´[K] = ‚àë i, ‚Ñº i x * ‚Ñº' i y :=



Theorem: SciLean.Rand.swap_bind
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem swap_bind (f : X ‚Üí Y ‚Üí Z) (x : Rand X) (y : Rand Y) :
    (do let x' ‚Üê x; let y' ‚Üê y; pure (f x' y'))
    =
    (do let y' ‚Üê y; let x' ‚Üê x; pure (f x' y')) :=



Theorem: SciLean.Rand.flip.pdf_wrt_flip
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf_wrt_flip (Œ∏ Œ∏' : R) :
    (flip Œ∏).pdf R (flip Œ∏').‚Ñô
    =
    fun b => if b then Œ∏ / Œ∏' else (1-Œ∏) / (1-Œ∏') :=



Theorem: IsAffineMap.IsAffineMap_comp
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_comp {f : Y ‚Üí Z} {g : X ‚Üí Y}
    (hf : IsAffineMap R f) (hg : IsAffineMap R g) : IsAffineMap R (fun x ‚Ü¶ f (g x)) :=



Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.HasSemiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí K) (y : Y) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x ‚Ä¢ y :=



Theorem: SciLean.SmoothLinearMap.apply_zero
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.apply_zero (f : X ‚ä∏[K] Y) : f 0 = 0 :=



Theorem: Set.HAdd.hAdd.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' + x) (Ioo a b)
    =
    Ioo (a - x') (b - x') :=



Theorem: SciLean.cintegral.arg_f.IsLinearMap_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.IsLinearMap_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ y, IsLinearMap R (f ¬∑ y)) :
    IsLinearMap R (fun x => ‚à´' y, f x y ‚àÇŒº) :=



Theorem: SciLean.BasisDuality.toDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.CDifferentiable_rule
  (f : X ‚Üí Y) (hf : CDifferentiable R f) (hx : f x‚â†0)
  : CDifferentiable R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) :=



Theorem: Set.HSub.hSub.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x - x') (Ioo a b)
    =
    Ioo (a + x') (b + x') :=



Theorem: SciLean.IsContinuousLinearMap.starRingEnd.arg_a.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem starRingEnd.arg_a.IsContinuousLinearMap_rule
  (f : X ‚Üí K) (_ : IsContinuousLinearMap K f)
  : IsContinuousLinearMap K fun x => conj (f x) :=



Theorem: SciLean.odeSolve.arg_ft‚ÇÄtx‚ÇÄ.fwdDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_ft‚ÇÄtx‚ÇÄ.fwdDeriv_rule
  (f : W ‚Üí R ‚Üí X ‚Üí X) (t‚ÇÄ t : W ‚Üí R) (x‚ÇÄ : W ‚Üí X)
  (hf : CDifferentiable R (fun (w,t,x) => f w t x))
  (ht‚ÇÄ : CDifferentiable R t‚ÇÄ) (ht : CDifferentiable R t)
  (hx : CDifferentiable R x‚ÇÄ)
  : fwdDeriv R (fun w => odeSolve (f w) (t‚ÇÄ w) (t w) (x‚ÇÄ w))
    =
    fun w dw =>
      let t‚ÇÄdt‚ÇÄ := fwdDeriv R t‚ÇÄ w dw
      let tdt   := fwdDeriv R t‚ÇÄ w dw
      let x‚ÇÄdx‚ÇÄ := fwdDeriv R x‚ÇÄ w dw
      let Tf := fwdDeriv R (fun wkx : W√óR√óX => f wkx.1 wkx.2.1 wkx.2.2)

      let F := fun (t : R) (xdx : X√óX) =>
        let x  := xdx.1
        let dx := xdx.2
        Tf (w,t,x) (dw,t‚ÇÄdt‚ÇÄ.2,dx)

      let xdx := odeSolve F (t‚ÇÄdt‚ÇÄ.1) (tdt.1) x‚ÇÄdx‚ÇÄ

      (xdx.1, xdx.2 + tdt.2 ‚Ä¢ f w tdt.1 xdx.1) :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X ‚Üí Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x + g x) x :=



Theorem: SciLean.Rand.flip.pdf
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.pdf (x : R) :
    (flip x).pdf R .count
    =
    fun b =>
      let x := (x ‚äî 0) ‚äì 1
      if b then x else (1-x) :=



Theorem: SciLean.cderiv.comp_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule_at
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K f (g x)) (hg : CDifferentiableAt K g x)
  : (cderiv K fun x : X => f (g x)) x
    =
    let y := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K f y dy
      dz :=



Theorem: IndexType.sum.arg_f.revDerivProjUpdate_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProjUpdate_rule [DecidableEq Œπ]
    (f : X ‚Üí Œπ ‚Üí Y') (hf : ‚àÄ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProjUpdate K Yi (fun x => ‚àë i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Œπ√óYi) f x
      (‚àë i, ydf.1 i,
       fun j dy dx =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => ydf.2 (i,j) dy dx) dx) :=



Theorem: IsLinearMap.sum_push
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_push
  {f : X ‚Üí Y} (hf : IsLinearMap K f)
  (Œπ : Type) [IndexType.{_,u} Œπ] [IndexType.{_,v} Œπ] (x : Œπ ‚Üí X)
  : (‚àë i, f (x i)) = f (‚àë i, x i) :=



Theorem: SciLean.norm‚ÇÇ.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem norm‚ÇÇ.arg_x.ContCDiffAt_rule
    (f : X ‚Üí Y) (x : X)
    (hf : ContCDiffAt R n f x) (hx : f x‚â†0) :
    ContCDiffAt R n (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x :=



Theorem: SciLean.scalar_abs_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_one : Scalar.abs (1 : R) = 1 :=



Theorem: Function.Bijective.Prod.mk.arg_fstsnd.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.Bijective_rule
  (f : X‚ÇÅ ‚Üí Y) (g : X‚ÇÇ ‚Üí Z) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : Bijective (fun x : X => (f (p‚ÇÅ x), g (p‚ÇÇ x)))
  :=



Theorem: SciLean.CDifferentiable.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i)
  (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i))
  : CDifferentiable K (fun x i => f x i)
  :=



Theorem: SciLean.HasSemiAdjoint.HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí K) (hf : HasSemiAdjoint K f) (y : K)
  : HasSemiAdjoint K fun x => f x / y :=



Theorem: SciLean.Distribution.add_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.add_extAction (T T' : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    ((T + T') : ùíü'(X,U)).extAction œÜ L = T.extAction œÜ L + T'.extAction œÜ L :=



Theorem: SciLean.explicitSymplecticEuler_eq_implicitSymplecticEulerV1
File path: SciLean/Modules/DifferentialEquations/OdeSolvers/Solvers.lean
Theorem statement: theorem explicitSymplecticEuler_eq_implicitSymplecticEulerV1
  (T V : X ‚Üí R)
  (hT : HasAdjDiff R T) (hV : HasAdjDiff R V)
  : explicitSymplecticEuler (fun q p => T p + V q)
    =
    implicitSymplecticEulerV1 (fun q p => T p + V q) :=



Theorem: IndexType.sum.arg_f.revDerivProj_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.revDerivProj_rule [DecidableEq Œπ]
    (f : X ‚Üí Œπ ‚Üí Y') (hf : ‚àÄ i, HasAdjDiff K (fun x => f x i)) :
    revDerivProj K Yi (fun x => ‚àë i, f x i)
    =
    fun x =>
      let ydf := revDerivProjUpdate K (Œπ√óYi) f x
      (‚àë i, ydf.1 i,
       fun j dy =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => ydf.2 (i,j) dy dx) 0) :=



Theorem: Function.invFun.Equiv.toFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.toFun.arg_a0.invFun_rule (f : Y ‚âÉ Z) (g : X ‚Üí Y) (hf : Bijective g)
  : Function.invFun (fun x => f (g x))
    =
    fun z => Function.invFun g (f.invFun z) :=



Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.HasSemiAdjoint_rule
  (y' : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => y' * f x :=



Theorem: SciLean.SciLean.cderiv.arg_dx.CDifferentiableAt_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.cderiv.arg_dx.CDifferentiableAt_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y) (y : Y) (dx : X)
  (hf : CDifferentiableAt K f y) (hg : CDifferentiableAt K g dx)
  : CDifferentiableAt K (fun dx' => cderiv K f y (g dx')) dx :=



Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_nat
    (c : ‚Ñï) (f : X ‚Üí Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c ‚Ä¢ f x :=



Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ‚ü™f x, y‚ü´[K] :=



Theorem: SciLean.semiAdjoint.HAdd.hAdd.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.semiAdjoint_rule
  (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x + g x)
    =
    fun y =>
      let x‚ÇÅ := semiAdjoint K f y
      let x‚ÇÇ := semiAdjoint K g y
      x‚ÇÅ + x‚ÇÇ :=



Theorem: SciLean.parametric_inverse_affine'
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine' (f : X ‚Üí R) (c : R) (hf : IsAffineMap R f) :
    let u  := ‚àá f 0
    let dec := planeDecomposition (n:=card Œπ - 1) (R:=R) u sorry_proof
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‚Äñu‚Äñ‚ÇÇ)
      (dom := fun _ => ‚ä§) :=



Theorem: Set.HSub.hSub.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HSub.hSub.arg_a1.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x' - x) (Ioo a b)
    =
    Ioo (x' - b) (x' - a) :=



Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_field
  [Field R] [MulAction R Y]
  (r : R) (f : X ‚Üí Y) (hf : Bijective f) (hr : r ‚â† 0)
  : Bijective (fun x => r ‚Ä¢ f x)
  :=



Theorem: SciLean.semiAdjoint.HSub.hSub.arg_a0a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.semiAdjoint_rule
  (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => f x - g x)
    =
    fun y =>
      let x‚ÇÅ := semiAdjoint K f y
      let x‚ÇÇ := semiAdjoint K g y
      x‚ÇÅ - x‚ÇÇ :=



Theorem: SciLean.cderiv.let_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule
  (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K fun xy : X√óY => f xy.1 xy.2) (hg : CDifferentiable K g)
  : (cderiv K fun x : X =>
       let y := g x
       f x y)
    =
    fun x =>
      let y  := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K (fun xy : X√óY => f xy.1 xy.2) (x,y) (dx, dy)
        dz :=



Theorem: SciLean.HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.ContCDiffAt_rule_int
    (c : ‚Ñ§) (f : X ‚Üí Y) (x) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => c ‚Ä¢ f x) x :=



Theorem: SciLean.CDifferentiableAt.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.apply_rule
  (i : Œπ) (x)
  : CDifferentiableAt K (fun x : (i : Œπ) ‚Üí E i => x i) x :=



Theorem: SciLean.inner_dualBasis_proj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_proj  (i : Œπ) (x : X)
  : ‚ü™x, ‚Öá' i‚ü´[K] = ‚Ñº i x :=



Theorem: Function.invFun.HSub.hSub.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HSub.hSub.arg_a1.invFun_rule
  [AddGroup Y]
   (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => y - f x )
    =
    fun y' =>
      invFun f (y - y')
  :=



Theorem: SciLean.cintegral.arg_f.cderiv_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.cderiv_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ y, CDifferentiable R (f ¬∑ y)) :
    (cderiv R  fun x => ‚à´' y, f x y ‚àÇŒº)
    =
    fun x dx => ‚à´' y, cderiv R (f ¬∑ y) x dx ‚àÇŒº :=



Theorem: SciLean.Rand.add_as_flip_E
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem add_as_flip_E {x y : X} (Œ∏ : R) (h : Œ∏ ‚àà Set.Ioo 0 1) :
    x + y = (flip Œ∏).ùîº (fun b => if b then Œ∏‚Åª¬π ‚Ä¢ x else (1-Œ∏)‚Åª¬π ‚Ä¢ y) :=



Theorem: SciLean.semiAdjoint.Prod.fst.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.semiAdjoint_rule
  (f : X ‚Üí Y√óZ) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).1)
    =
    (fun y => semiAdjoint K (fun x => f x) (y,0)) :=



Theorem: SciLean.CDifferentiable.id_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.id_rule
  : CDifferentiable K (fun x : X => x)
  :=



Theorem: SciLean.HasSemiAdjoint.Prod.fst.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.fst.arg_self.HasSemiAdjoint_rule
    (f : X ‚Üí Y√óZ) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).fst :=



Theorem: IsLinearMap.sum_pull
File path: SciLean/Core/Meta/GenerateLinearMapSimp.lean
Theorem statement: theorem _root_.IsLinearMap.sum_pull
  {f : X ‚Üí Y} (hf : IsLinearMap K f)
  (Œπ : Type) [IndexType.{_,u} Œπ] [IndexType.{_,v} Œπ] (x : Œπ ‚Üí X)
  : f (‚àë i, x i) = ‚àë i, f (x i) :=



Theorem: IndexType.sum.arg_f.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IndexType.sum.arg_f.IsAffineMap_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, IsAffineMap R (f ¬∑ i))
  : IsAffineMap R fun x => ‚àë i, f x i :=



Theorem: SciLean.scalar_min_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_min_one_zero  : min (1 : R) (0 : R) = 0 :=



Theorem: SciLean.HasSemiAdjoint.apply_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem apply_rule (i : Œπ) :
    HasSemiAdjoint K (fun x : (i : Œπ) ‚Üí E i => x i) :=



Theorem: SciLean.cderiv.comp_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : (cderiv K fun x : X => f (g x))
    =
    fun x =>
      let y := g x
      fun dx =>
        let dy := cderiv K g x dx
        let dz := cderiv K f y dy
        dz :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.gaussian.arg_ŒºœÉx.CDifferentiableAt_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_ŒºœÉx.CDifferentiableAt_rule (w : W)
    (Œº : W ‚Üí U) (œÉ : W ‚Üí R) (x : W ‚Üí U)
    (hŒº : CDifferentiableAt R Œº w) (hœÉ : CDifferentiableAt R œÉ w) (hx : CDifferentiableAt R x w)
    (hœÉ' : œÉ w ‚â† 0) :
    CDifferentiableAt R (fun w => gaussian (Œº w) (œÉ w) (x w)) w :=



Theorem: SciLean.Rand.uniformI.pdf
File path: SciLean/Core/Rand/Distributions/UniformI.lean
Theorem statement: theorem uniformI.pdf :
    (uniformI R).pdf R volume
    =
    fun x => if 0 < x ‚àß x < 1 then 1 else 0 :=



Theorem: SciLean.Rand.mean_add
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add  (x : Rand X) (x' : X) : x.mean + x' = (x  + x').mean :=



Theorem: SciLean.CDifferentiable.apply_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.apply_rule (i : Œπ)
  : CDifferentiable K (fun x : (i : Œπ) ‚Üí E i => x i) :=



Theorem: SciLean.ite.arg_chte.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem ite.arg_chte.cderiv_rule
  (c : X ‚Üí Prop) [dec : ‚àÄ x, Decidable (c x)] (t e : X ‚Üí Y)
  (ht : ‚àÄ x ‚àà closure c, CDifferentiableAt K t x) (he : ‚àÄ x ‚àà (interior c)·∂ú, CDifferentiableAt K e x)
  (hc : (‚àÄ x, x ‚àà frontier c ‚Üí cderiv K t x = cderiv K e x))
  : cderiv K (fun x => ite (c x) (t x) (e x))
    =
    fun y =>
      ite (c y) (cderiv K t y) (cderiv K e y) :=



Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (y : Y)
  (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => f x / y) :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.semiAdjoint.Inner.inner.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ‚ü™y, f x‚ü´[K])
    =
    fun z => z ‚Ä¢ semiAdjoint K f y :=



Theorem: SciLean.cderiv.pi_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i))
  : (cderiv K fun (x : X) (i : Œπ) => f x i)
    =
    fun x => fun dx => fun i =>
      cderiv K (f ¬∑ i) x dx
  :=



Theorem: SciLean.Rand.bind_pdf
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_pdf (ŒΩ : Measure Y) (x : Rand X) (f : X ‚Üí Rand Y) :
    (x >>= f).pdf R ŒΩ = fun y => ‚à´ x', ((f x').pdf R ŒΩ y) ‚àÇx.‚Ñô :=



Theorem: SciLean.IsContinuousLinearMap.isContinuousLinearMap_differentiable
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem isContinuousLinearMap_differentiable (f : X ‚Üí Y) (hf : IsContinuousLinearMap K f) :
    Differentiable K f :=



Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.semiAdjoint_rule
  (c : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x * c)
    =
    fun y => conj c ‚Ä¢ semiAdjoint K (fun x => f x) y :=



Theorem: LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.revCDerivProj_rule
    (cont : X ‚Üí Cont) (idx : Idx) (elem : X ‚Üí Elem)
    (hcont : HasAdjDiff K cont) (helem : HasAdjDiff K elem) :
    revDerivProj K Idx (fun x => Indexed.set (cont x) idx (elem x))
    =
    fun x =>
      let cdc := revDerivProj K Idx cont x
      let ede := revDeriv K elem x
      (Indexed.set cdc.1 idx ede.1,
       fun i delem =>
         if i = idx then
           ede.2 delem
         else
           cdc.2 i delem) :=



Theorem: SciLean.Distribution.fintype_sum_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.fintype_sum_extAction {I} [Fintype I] (T : I ‚Üí ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (‚àë i, T i).extAction œÜ L = ‚àë i, (T i).extAction œÜ L :=



Theorem: SciLean.Distribution.neg_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.neg_extAction (T : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (- T).extAction œÜ L = - T.extAction œÜ L :=



Theorem: SciLean.fderiv.apply_rule
File path: SciLean/Core/FunctionTransformations/FDeriv.lean
Theorem statement: theorem fderiv.apply_rule (i : Œπ) :
    (fderiv K fun (x : (i : Œπ) ‚Üí E i) => x i)
    =
    fun _ => fun dx =>L[K] dx i :=



Theorem: SciLean.semiAdjoint.Neg.neg.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.semiAdjoint_rule
  (f : X ‚Üí Y)
  : semiAdjoint K (fun x => - f x)
    =
    fun y => - semiAdjoint K f y :=



Theorem: Function.Bijective.HDiv.hDiv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (y : Y)
  (hf : Bijective f)
  : Bijective (fun x => f x / y) :=



Theorem: SciLean.Function.invFun.arg_f_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f_a1.cderiv_rule
  (f : X ‚Üí Y ‚Üí Z)
  (hf : ‚àÄ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X√óY => f xy.1 xy.2))
  : cderiv K (fun x z => invFun (f x) z)
    =
    fun x dx z =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=



Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (hf : Bijective f) (hf' : ‚àÄ x, f x ‚â† 0)
  : Bijective fun x => (f x)‚Åª¬π
  :=



Theorem: SciLean.CDifferentiable.comp_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f (g x))
  :=



Theorem: LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.ofFn.arg_cont.semiAdjoint_rule_simple :
    semiAdjoint K (fun f : Idx ‚Üí Elem => Indexed.ofFn (C:=Cont) f)
    =
    fun (cont : Cont) idx => cont[idx] :=



Theorem: SciLean.odeSolve.arg_x‚ÇÄ.revCDeriv_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x‚ÇÄ.revCDeriv_rule
  (f : R ‚Üí X ‚Üí X) (t‚ÇÄ t : R) (x‚ÇÄ : W ‚Üí X)
  (hf : HasAdjDiff R (fun (t,x) => f t x))
  (hx : HasAdjDiff R x‚ÇÄ)
  : revDeriv R (fun w => odeSolve f t‚ÇÄ t (x‚ÇÄ w))
    =
    fun w =>
      let x‚ÇÄdx‚ÇÄ := revDeriv R x‚ÇÄ w
      let x := fun s => odeSolve f t‚ÇÄ s x‚ÇÄdx‚ÇÄ.1
      let dfdx := fun s dx' => - gradient R (fun x' => f s x') (x s) dx'
      (x t,
       fun dx =>
         let dx := odeSolve dfdx t‚ÇÄ t dx
         x‚ÇÄdx‚ÇÄ.2 dx) :=



Theorem: SciLean.IndexType.sum.arg_f.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiable_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiable K (fun x => f x i))
  : CDifferentiable K (fun x => ‚àë i, f x i) :=



Theorem: SciLean.Prod.fst.arg_self.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.fst.arg_self.CDifferentiable_rule
  (f : X ‚Üí Y√óZ) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => (f x).1)  :=



Theorem: SciLean.HasSemiAdjoint.comp_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem comp_rule
    (f : Y ‚Üí Z) (g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K (fun x => f (g x)) :=



Theorem: IsAffineMap.IsAffineMap_pi
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem IsAffineMap_pi (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, IsAffineMap R (f ¬∑ i)) :
    IsAffineMap R (fun x i ‚Ü¶ f x i) :=



Theorem: SciLean.BasisDuality.toDual.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.CDifferentiable_rule
  : CDifferentiable K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.cderiv.const_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.const_rule (x : X) :
    (cderiv K fun _ : Y => x) = fun _ => fun dx => 0 :=



Theorem: SciLean.CDifferentiableAt.pi_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiableAt.pi_rule
  (f : X ‚Üí (i : Œπ) ‚Üí E i) (x : X)
  (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : CDifferentiableAt K (fun x i => f x i) x
  :=



Theorem: SciLean.Distribution.smul_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.smul_extAction (r : R) (T : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W)  :
    (r ‚Ä¢ T).extAction œÜ L = r ‚Ä¢ T.extAction œÜ L :=



Theorem: SciLean.jacobian.comp_rule
File path: SciLean/Core/Integral/Jacobian.lean
Theorem statement: theorem jacobian.comp_rule (f : U ‚Üí V) (g : U ‚Üí U)
    (hf : HasAdjDiff R f) (hg : HasAdjDiff R g) :
    jacobian R (fun x => f (g x))
    =
    fun x => jacobian R f x * jacobian R g x :=



Theorem: SciLean.approx_consistency
File path: SciLean/Core/Approx/ApproxSolution.lean
Theorem statement: theorem approx_consistency {N} {lN : Filter N} [T2Space Œ±] {spec : Œ± ‚Üí Prop}
  (approx : ApproxSolution lN spec)
  : ‚àÄ a, a = (limit n ‚àà lN, approx.val n) ‚Üí spec a :=



Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a1.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a1.IsContinuousLinearMap_rule
  (f : X ‚Üí Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ y (f x) :=



Theorem: SciLean.HSMul.hSMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSMul.hSMul.arg_a0a1.cderiv_rule_at (x : X) (f : X ‚Üí K) (g : X ‚Üí Y)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x ‚Ä¢ g x) x
    =
    let k := f x
    let y := g x
    fun dx =>
      k ‚Ä¢ (cderiv K g x dx) + (cderiv K f x dx) ‚Ä¢ y :=



Theorem: Function.invFun.Equiv.invFun.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Equiv.invFun.arg_a0.invFun_rule (f : Y ‚âÉ Z) (g : X ‚Üí Z) (hf : Bijective g)
  : Function.invFun (fun x => f.invFun (g x))
    =
    fun z => Function.invFun g (f z) :=



Theorem: Set.HAdd.hAdd.arg_a0.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.preimage_rule_Ioo (x' a b : R)  :
    preimage (fun x : R => x + x') (Ioo a b)
    =
    Ioo (a - x') (b - x') :=



Theorem: SciLean.HAdd.hAdd.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => f x + y)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: SciLean.scalar_abs_neg
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_neg (r : R) : Scalar.abs (- r) = Scalar.abs r :=



Theorem: SciLean.ArrayType.ext
File path: SciLean/Data/ArrayType/Basic.lean
Theorem statement: theorem ext (x y : Cont) : (‚àÄ i, x[i] = y[i]) ‚Üí x = y :=



Theorem: LeanColls.Range.fold_def
File path: .lake/packages/leancolls/LeanColls/Data/Range.lean
Theorem statement: theorem fold_def (r : Range) (f : Œ≤ ‚Üí Nat ‚Üí Œ≤)
    : fold r f init =
      Fin.foldl (r.size) (fun acc i => f acc (r.get i)) init
  :=



Theorem: SciLean.HasSemiAdjoint.HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.HasSemiAdjoint_rule
    (c : K) (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun x => c ‚Ä¢ f x :=



Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_field
  [Field Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => f x * y)
  :=



Theorem: SciLean.DualBasis.dualProj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ‚Ñº' i x) x :=



Theorem: SciLean.gaussian.arg_Œºx.cderiv_rule
File path: SciLean/Core/Functions/Gaussian.lean
Theorem statement: theorem gaussian.arg_Œºx.cderiv_rule
    (Œº : W ‚Üí U) (œÉ : R) (x : W ‚Üí U)
    (hŒº : CDifferentiable R Œº) (hx : CDifferentiable R x) :
    fwdDeriv R (fun w => gaussian (Œº w) œÉ (x w))
    =
    fun w dw =>
      let ŒºdŒº := fwdDeriv R Œº w dw
      let xdx := fwdDeriv R x w dw
      let xdx' := œÉ‚Åª¬π ‚Ä¢ (xdx - ŒºdŒº)
      let g := gaussian ŒºdŒº.1 œÉ xdx.1
      (g, - ‚ü™xdx'.1, xdx'.2‚ü´ * g) :=



Theorem: SciLean.inner_basis_dualProj
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_basis_dualProj (i : Œπ) (x : X)
  : ‚ü™x, ‚Öá i‚ü´[K] = ‚Ñº' i x :=



Theorem: SciLean.SmoothLinearMap.fintype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.fintype_sum_apply {I} [Fintype I] (f : I ‚Üí X‚ä∏[K] Y) (x : X) :
    (‚àë i, f i) x = ‚àë i, f i x  :=



Theorem: SciLean.ContCDiffMapFD_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_apply_CDifferentiableAt (f : W ‚Üí X ‚üøFD[K,‚àû] Y) (g : W ‚Üí X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=



Theorem: Function.Bijective.HSub.hSub.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x - y
  :=



Theorem: SciLean.norm‚ÇÇ_squared_nat
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_squared_nat {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‚Äñx‚Äñ‚ÇÇ[K] ^ 2 = ‚Äñx‚Äñ‚ÇÇ¬≤[K] :=



Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (y' : Y) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x ‚Ä¢ y')
    =
    fun y => semiAdjoint K (fun x => f x) ‚ü™y',y‚ü´[K] :=



Theorem: SciLean.cderiv.let_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.let_rule_at
  (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt K ‚Üøf (x, g x))
  (hg : CDifferentiableAt K g x)
  : (cderiv K
      fun x : X =>
        let y := g x
        f x y) x
    =
    let y  := g x
    fun dx =>
      let dy := cderiv K g x dx
      let dz := cderiv K (fun xy : X√óY => f xy.1 xy.2) (x,y) (dx, dy)
      dz :=



Theorem: Function.Bijective.HVAdd.hVAdd.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HVAdd.hVAdd.arg_a1.Bijective_rule_group
  [AddGroup G] [AddAction G Y]
  (g : G) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => g +·µ• f x)
  :=



Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_group
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_group
  [Group Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => (f x)‚Åª¬π)
    =
    fun y =>
      invFun f (y‚Åª¬π)
  :=



Theorem: SciLean.semiAdjoint.id_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem id_rule : semiAdjoint K (fun (x : X) => x) = fun x => x :=



Theorem: SciLean.scalar_sqrt_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_zero  : Scalar.sqrt (0 : R) = 0 :=



Theorem: SciLean.cderiv.arg_f.IsSmoothLinearMap_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.arg_f.IsSmoothLinearMap_rule
    (f : X ‚Üí Y ‚Üí Z) (hf : CDifferentiable K (fun (x,y) => f x y)) (hf' : ‚àÄ y, IsLinearMap K (fun x => f x y)) :
    IsSmoothLinearMap K (fun x => cderiv K (f x ¬∑)) :=



Theorem: SciLean.Inner.inner.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Inner.inner.arg_a0a1.cderiv_rule_at
  (f : X ‚Üí Y) (g : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt R f x) (hg : CDifferentiableAt R g x)
  : cderiv R (fun x => ‚ü™f x, g x‚ü´[R]) x
    =
    fun dx =>
      let y‚ÇÅ := f x
      let dy‚ÇÅ := cderiv R f x dx
      let y‚ÇÇ := g x
      let dy‚ÇÇ := cderiv R g x dx
      ‚ü™dy‚ÇÅ, y‚ÇÇ‚ü´[R] + ‚ü™y‚ÇÅ, dy‚ÇÇ‚ü´[R] :=



Theorem: SciLean.parDistribDeriv.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem parDistribDeriv.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    parDistribDeriv (fun x => f (g x))
    =
    fun x dx =>
      let ydy := fwdDeriv R g x dx
      parDistribDeriv f ydy.1 ydy.2 :=



Theorem: SciLean.Measure.restrict_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.restrict_restrict {X} [MeasurableSpace X] (Œº : Measure X) (A B : Set X) :
    (Œº.restrict A).restrict B = Œº.restrict (A ‚à© B) :=



Theorem: SciLean.Inner.inner.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Inner.inner.arg_a0a1.CDifferentiable_rule
    (f : X ‚Üí Y) (g : X ‚Üí Y)
    (hf : CDifferentiable R f) (hg : CDifferentiable R g) :
    CDifferentiable R (fun x => ‚ü™f x, g x‚ü´[R]) :=



Theorem: SciLean.scalar_max_one_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_max_one_zero  : max (1 : R) (0 : R) = 1 :=



Theorem: SciLean.scalar_abs_zero
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_abs_zero : Scalar.abs (0 : R) = 0 :=



Theorem: SciLean.Diffeomorphism.id_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem id_rule
  : Diffeomorphism K (fun x : X => x)
  :=



Theorem: SciLean.CDifferentiable.const_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem CDifferentiable.const_rule (y : Y)
  : CDifferentiable K (fun _ : X => y)
  :=



Theorem: IsLinearMap.isLinearMap_pi
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem isLinearMap_pi (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, IsLinearMap R (f ¬∑ i)) :
    IsLinearMap R (fun x i ‚Ü¶ f x i) :=



Theorem: SciLean.semiAdjoint.HDiv.hDiv.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HDiv.hDiv.arg_a0.semiAdjoint_rule
  (f : X ‚Üí K) (c : K)
  (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => f x / c)
    =
    fun y => (conj c)‚Åª¬π ‚Ä¢ semiAdjoint K f y :=



Theorem: SciLean.Neg.neg.arg_a0.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Neg.neg.arg_a0.CDifferentiable_rule
  (f : X ‚Üí Y) (hf : CDifferentiable K f)
  : CDifferentiable K (fun x => - f x)  :=



Theorem: SciLean.DualBasis.dualProj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.semiAdjoint.Finset.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.semiAdjoint_rule {Œπ : Type _} [Fintype Œπ]
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i))
  : semiAdjoint K (fun x => ‚àë i, f x i)
    =
    (fun y => ‚àë i, semiAdjoint K (f ¬∑ i) y) :=



Theorem: SciLean.IndexType.sum.arg_f.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.cderiv_rule_at
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x)
  : cderiv K (fun x => ‚àë i, f x i) x
    =
    fun dx => ‚àë i, cderiv K (f ¬∑ i) x dx :=



Theorem: SciLean.decompose_has_unique_solution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decompose_has_unique_solution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys ‚Üí Zs ‚Üí Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs ‚Üí Prop)       (Q‚ÇÅ : Ys ‚Üí Zs ‚Üí Prop) (Q‚ÇÇ : Ys ‚Üí Zs ‚Üí Prop) (equiv : ‚àÄ ys zs, (Q‚ÇÅ ys zs ‚àß Q‚ÇÇ ys zs) ‚Üî P (f ys zs))
  (unique : ‚àÄ ys, HasUniqueSolution (Q‚ÇÅ ys))
  : HasUniqueSolution P
    ‚Üî
    HasUniqueSolution fun ys => Q‚ÇÇ ys (solve zs, Q‚ÇÅ ys zs)
  :=



Theorem: SciLean.Function.invFun.arg_f.cderiv_rule'
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_f.cderiv_rule'
  (f : X ‚Üí Y ‚Üí Z) (z : Z)
  (hf : ‚àÄ x, Diffeomorphism K (f x))
  (hf' : CDifferentiable K (fun xy : X√óY => f xy.1 xy.2))
  : cderiv K (fun x => invFun (f x) z)
    =
    fun x dx =>
      let y := invFun (f x) z
      let dfdx_y := (cderiv K f x dx) y
      let df'dy := cderiv K (invFun (f x)) (f x y) (dfdx_y)
      (-df'dy)
  :=



Theorem: SciLean.Rand.bind_E
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem bind_E (r : Rand X) (f : X ‚Üí Rand Y) (œÜ : Y ‚Üí Z) :
    (r >>= f).ùîº œÜ = r.ùîº (fun x' => (f x').ùîº œÜ) :=



Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.cderiv_rule_at
  (f : X ‚Üí Y) (x : X)
  (hf : CDifferentiableAt R f x) (hx : f x‚â†0)
  : cderiv R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x
    =
    fun dx =>
      let y := f x
      let dy := cderiv R f x dx
      ‚Äñy‚Äñ‚ÇÇ[R]‚Åª¬π * ‚ü™dy,y‚ü´[R] :=



Theorem: SciLean.ContCDiffMapFD_eta
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eta (f : X ‚üøFD[K,n] Y) : (fun x ‚üøFD[K,n] f x) = f :=



Theorem: SciLean.HasSemiAdjoint.Inner.inner.arg_a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a1.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (_ : HasSemiAdjoint K f) (y : Y)
  : HasSemiAdjoint K fun x => ‚ü™y, f x‚ü´[K] :=



Theorem: SciLean.ContCDiffMap_apply_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiable (f : W ‚Üí X ‚üø[K,‚àû] Y) (g : W ‚Üí X)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) : CDifferentiable K (fun w => f w (g w)) :=



Theorem: SciLean.ContCDiffMap_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ‚üø[K,‚àû] Y)√óX) => fx.1 fx.2) :=



Theorem: Function.invFun.let_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem let_rule
  (f : X‚ÇÇ ‚Üí Y ‚Üí Z) (g : X‚ÇÅ ‚Üí Y) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective (fun xy : X‚ÇÇ√óY => f xy.1 xy.2)) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : invFun (fun x => let y := g (p‚ÇÅ x); f (p‚ÇÇ x) y)
    =
    fun z =>
      let x‚ÇÇy := invFun (fun xy : X‚ÇÇ√óY => f xy.1 xy.2) z
      let x‚ÇÅ := invFun g x‚ÇÇy.2
      let x := invFun (fun x => (p‚ÇÅ x, p‚ÇÇ x)) (x‚ÇÅ,x‚ÇÇy.1)
      x :=



Theorem: SciLean.semiAdjoint.Prod.snd.arg_self.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.semiAdjoint_rule
  (f : X ‚Üí Y√óZ) (hf : SciLean.HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (f x).2)
    =
    (fun z => semiAdjoint K f (0,z)) :=



Theorem: Function.Bijective.HSMul.hSMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.Bijective_rule_group
  [Group G] [MulAction G Y]
  (g : G) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => g ‚Ä¢ f x)
  :=



Theorem: SciLean.HasSemiAdjoint.Prod.snd.arg_self.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Prod.snd.arg_self.HasSemiAdjoint_rule
    (f : X ‚Üí Y√óZ) (hf : HasSemiAdjoint K f) :
    HasSemiAdjoint K fun (x : X) => (f x).snd :=



Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiable K (f ¬∑ i)) :
    fwdDeriv K (fun x => ‚àë i, f x i)
    =
    fun x dx =>
      let ydy := fun i => fwdDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=



Theorem: SciLean.ContCDiffMap_eval_CDifferentiable
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_eval_CDifferentiable (h : 0 < n) :
    CDifferentiable K (fun (fx : (X ‚üø[K,n] Y)√óX) => fx.1 fx.2) :=



Theorem: Function.invFun.Inv.inv.arg_a0.invFun_rule_field
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Inv.inv.arg_a0.invFun_rule_field
  [Field Y]
  (f : X ‚Üí Y) (hf : Bijective f) (hf' : ‚àÄ x, f x ‚â† 0)
  : invFun (fun x => (f x)‚Åª¬π)
    =
    fun y =>
      invFun f (y‚Åª¬π)
  :=



Theorem: SciLean.decomposeSolution
File path: SciLean/Util/SolveFun.lean
Theorem statement: theorem decomposeSolution {Xs Ys Zs : Type _} [Nonempty Xs] [Nonempty Ys] [Nonempty Zs]
  (f : Ys ‚Üí Zs ‚Üí Xs)  (hf : Function.Bijective (uncurryN 2 f))     (P : Xs ‚Üí Prop)       (Q‚ÇÅ : Ys ‚Üí Zs ‚Üí Prop) (Q‚ÇÇ : Ys ‚Üí Zs ‚Üí Prop) (equiv : ‚àÄ ys zs, (Q‚ÇÅ ys zs ‚àß Q‚ÇÇ ys zs) ‚Üî P (f ys zs))
  (unique : ‚àÄ ys, HasUniqueSolution (Q‚ÇÅ ys))
  : (solve xs, P xs)
    =
    let zs' := fun ys => (solve zs, Q‚ÇÅ ys zs)
    let ys  := solve ys, Q‚ÇÇ ys (zs' ys)
    let zs  := zs' ys
    f ys zs
  :=



Theorem: Function.invFun.Prod.mk.arg_fstsnd.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.invFun_rule
  (f : X‚ÇÅ ‚Üí Y) (g : X‚ÇÇ ‚Üí Z) (p‚ÇÅ : X ‚Üí X‚ÇÅ) (p‚ÇÇ : X ‚Üí X‚ÇÇ)
  (hf : Bijective f) (hg : Bijective g) (hp : Bijective (fun x => (p‚ÇÅ x, p‚ÇÇ x)))
  : invFun (fun x : X => (f (p‚ÇÅ x), g (p‚ÇÇ x)))
    =
    fun yz =>
      let x‚ÇÅ := invFun f yz.1
      let x‚ÇÇ := invFun g yz.2
      let x  := invFun (fun x => (p‚ÇÅ x, p‚ÇÇ x)) (x‚ÇÅ,x‚ÇÇ)
      x :=



Theorem: SciLean.DualBasis.dualProj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.Function.invFun.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem Function.invFun.arg_a1.cderiv_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Z)
  (hf : Diffeomorphism K f) (hg : CDifferentiable K g)
  : cderiv K (fun x => invFun f (g x))
    =
    fun x dx =>
      let z := g x
      let dz := cderiv K g x dx
      let y := invFun f z
      let dy := invFun (cderiv K f y) dz
      dy :=



Theorem: SciLean.fwdDeriv.IndexType.sum.arg_f.fwdDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdDeriv.lean
Theorem statement: theorem IndexType.sum.arg_f.fwdDeriv_rule_at (x : X)
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, CDifferentiableAt K (f ¬∑ i) x) :
    fwdDeriv K (fun x => ‚àë i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.CDifferentiable_rule
  (f g : X ‚Üí Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x + g x)  :=



Theorem: SciLean.Distribution.iteD_same
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.iteD_same (A : Set X) (u : ùíü'(X,Y)) :
   iteD A u u = u :=



Theorem: GetElem.getElem.arg_cont.revCDerivProj_rule
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.revCDerivProj_rule
  {J ElemJ} [StructType Elem J ElemJ] [IndexType J] [LawfulIndexType J] [DecidableEq J]
  [‚àÄ j, SemiInnerProductSpace K (ElemJ j)] [SemiInnerProductSpaceStruct K Elem J ElemJ]
  (f : X ‚Üí Cont) (idx : Idx)
  (hf : HasAdjDiff K f)
  : revDerivProj K J (fun x => (f x)[idx])
    =
    fun x =>
      let ydf := revDerivProj K (Idx√óJ) f x
      (ydf.1[idx],
       fun j delem => ydf.2 (idx,j) delem) :=



Theorem: SciLean.Neg.neg.arg_a0.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Neg.neg.arg_a0.ContCDiff_rule
    (f : X ‚Üí Y) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => - f x) :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.IsLinearMap_rule :
    IsLinearMap K (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.semiAdjoint.Inner.inner.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Inner.inner.arg_a0.semiAdjoint_rule
  {Y : Type _} [SemiHilbert K Y]
  (f : X ‚Üí Y) (hf : HasSemiAdjoint K f) (y : Y)
  : semiAdjoint K (fun x => ‚ü™f x, y‚ü´[K])
    =
    fun z => (conj z) ‚Ä¢ semiAdjoint K f y :=



Theorem: SciLean.FwdFDeriv.HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.fwdFDeriv_rule_at (x : X)
    (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : DifferentiableAt K f x) (hg : DifferentiableAt K g x) (hx : g x ‚â† 0) :
    (fwdFDeriv K fun x => f x / g x) x
    =
    fun dx =>
      let ydy := (fwdFDeriv K f x dx)
      let zdz := (fwdFDeriv K g x dx)
      (ydy.1 / zdz.1, (ydy.2 * zdz.1 - ydy.1 * zdz.2) / zdz.1^2) :=



Theorem: SciLean.revDerivProjUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasAdjDiff K (f ¬∑ i)) :
    (revDerivProjUpdate K Unit fun (x : X) (i : Œπ) => f x i)
    =
    fun x =>
      let ydf := fun i => revDerivUpdate K (f ¬∑ i) x
      (fun i => (ydf i).1,
       fun _ df dx =>
         Fold.fold (IndexType.univ Œπ) (fun dx i => (ydf i).2 (df i) dx) dx) :=



Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiff_rule
    (f g : X ‚Üí Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x - g x) :=



Theorem: SciLean.Diffeomorphism.comp_rule
File path: SciLean/Core/FunctionPropositions/Diffeomorphism.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : Diffeomorphism K f) (hg : Diffeomorphism K g)
  : Diffeomorphism K (fun x => f (g x))
  :=



Theorem: SciLean.cintegral.arg_f.CDifferentiable_rule
File path: SciLean/Core/Integral/CIntegral.lean
Theorem statement: theorem cintegral.arg_f.CDifferentiable_rule
    (f : X ‚Üí Œ≤ ‚Üí Z) (Œº : Measure Œ≤) (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) :
    CDifferentiable R (fun x => ‚à´' y, f x y ‚àÇŒº) :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.fromDual x) x :=



Theorem: SciLean.Basis.proj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ‚Ñº i x) :=



Theorem: LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem LeanColls.Indexed.set.arg_contelem.IsLinearMap_rule_simple (idx : Idx) :
    IsLinearMap R (fun ((cont,elem) : Cont√óElem) => Indexed.set cont idx elem) :=



Theorem: SciLean.Distribution.sub_extAction
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.sub_extAction (T T' : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    (T - T').extAction œÜ L = T.extAction œÜ L - T'.extAction œÜ L :=



Theorem: SciLean.Rand.flip.integral
File path: SciLean/Core/Rand/Distributions/Flip.lean
Theorem statement: theorem flip.integral (Œ∏ : R) (f : Bool ‚Üí X) :
    ‚à´' x, f x ‚àÇ(flip Œ∏).‚Ñô = Œ∏ ‚Ä¢ f true + (1-Œ∏) ‚Ä¢ f false :=



Theorem: SciLean.HasSemiAdjoint.HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.HasSemiAdjoint_rule
    (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x - g x :=



Theorem: SciLean.Prod.snd.arg_self.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiff_rule
    (f : X ‚Üí Y√óZ) (hf : ContCDiff K n f) :
    ContCDiff K n (fun x => (f x).2) :=



Theorem: SciLean.IndexType.sum.arg_f.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem IndexType.sum.arg_f.CDifferentiableAt_rule
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, CDifferentiableAt K (fun x => f x i) x)
  : CDifferentiableAt K (fun x => ‚àë i, f x i) x :=



Theorem: SciLean.BasisDuality.fromDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.fromDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.fromDual x) :=



Theorem: SciLean.ContCDiffMapFD_eval_CDifferentiable'
File path: SciLean/Core/FunctionSpaces/ContCDiffMapFD.lean
Theorem statement: theorem ContCDiffMapFD_eval_CDifferentiable' :
    CDifferentiable K (fun (fx : (X ‚üøFD[K,‚àû] Y)√óX) => fx.1 fx.2) :=



Theorem: SciLean.Rand.pull_E_affine
File path: SciLean/Core/Rand/PushPullExpectation.lean
Theorem statement: theorem pull_E_affine (r : Rand X) (œÜ : X ‚Üí Y)
    (f : Y ‚Üí Z) (hf : IsAffineMap ‚Ñù f := by fun_prop) :
    (f (r.ùîº œÜ)) = r.ùîº (fun x => f (œÜ x)) :=



Theorem: SciLean.SciLean.norm‚ÇÇ.arg_x.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.norm‚ÇÇ.arg_x.HasAdjDiffAt_rule (x : X)
    (f : X ‚Üí Y) (hf : HasAdjDiffAt R f x) (hfz : f x ‚â† 0) :
    HasAdjDiffAt R (fun x => ‚Äñf x‚Äñ‚ÇÇ[R]) x :=



Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiff_rule
  : ContCDiff K n (fun x : X => BasisDuality.toDual x) :=



Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_group
  [Group Y]
  (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective (fun x => y * f x)
  :=



Theorem: SciLean.semiAdjoint.HMul.hMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a1.semiAdjoint_rule
  (c : K) (f : X ‚Üí K) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => c * f x)
    =
    fun y => conj c ‚Ä¢ semiAdjoint K (fun x => f x) y :=



Theorem: SciLean.DualBasis.dualProj.arg_x.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem DualBasis.dualProj.arg_x.ContCDiff_rule (i : IX)
  : ContCDiff K n (fun x : X => ‚Ñº' i x) :=



Theorem: SciLean.norm‚ÇÇ_prod
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_prod {R K X Y} [Scalar R K] [AddCommMonoid K] [Inner K X] [Inner K Y] (x : X) (y : Y) :
  ‚Äñ(x,y)‚Äñ‚ÇÇ[K] = Scalar.sqrt (‚Äñx‚Äñ‚ÇÇ¬≤[K] + ‚Äñy‚Äñ‚ÇÇ¬≤[K]) :=



Theorem: SciLean.Rand.E_smul
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem E_smul (r : Rand X) (œÜ : X ‚Üí ‚Ñù) (y : Y) :
    r.ùîº (fun x' => œÜ x' ‚Ä¢ y) = r.ùîº œÜ ‚Ä¢ y :=



Theorem: Function.Bijective.HMul.hMul.arg_a1.Bijective_rule_field
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a1.Bijective_rule_field
  [Field Y]
  (y : Y) (f : X ‚Üí Y) (hf : Bijective f) (hy : y ‚â† 0)
  : Bijective (fun x => y * f x)
  :=



Theorem: SciLean.IsContinuousLinearMap.Inner.inner.arg_a0.IsContinuousLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsContinuousLinearMap.lean
Theorem statement: theorem Inner.inner.arg_a0.IsContinuousLinearMap_rule
  (f : X ‚Üí Y) (_ : IsContinuousLinearMap K f) (y : Y)
  : IsContinuousLinearMap K fun x => @inner K _ _ (f x) y :=



Theorem: SciLean.Function.toDistribution_zero
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Function.toDistribution_zero  :
    Function.toDistribution (fun (_ : X) => 0) = (0 : ùíü'(X,Y)) :=



Theorem: SciLean.cderiv.id_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem cderiv.id_rule :
    (cderiv K fun x : X => x) = fun _ => fun dx => dx :=



Theorem: SciLean.Prod.mk.arg_fstsnd.CDifferentiableAt_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.CDifferentiableAt_rule
  (x : X)
  (g : X ‚Üí Y) (hg : CDifferentiableAt K g x)
  (f : X ‚Üí Z) (hf : CDifferentiableAt K f x)
  : CDifferentiableAt K (fun x => (g x, f x)) x
  :=



Theorem: Function.invFun.Neg.neg.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem Neg.neg.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => - f x)
    =
    fun y =>
      invFun f (-y)
  :=



Theorem: Function.Bijective.HAdd.hAdd.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.Bijective_rule
  [AddGroup Y]
  (y : Y)  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => y + f x
  :=



Theorem: SciLean.SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule
File path: SciLean/Core/FunctionPropositions/HasAdjDiff.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasAdjDiffAt_rule (w : W)
    (f : X ‚Üí Y) (a0 : W ‚Üí Y) (hf : CDifferentiable K f) (ha0 : HasAdjDiffAt K a0 w) :
    HasAdjDiffAt K (fun w => semiAdjoint K f (a0 w)) w :=



Theorem: Function.Bijective.HMul.hMul.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HMul.hMul.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective (fun x => f x * y)
  :=



Theorem: SciLean.HDiv.hDiv.arg_a0a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HDiv.hDiv.arg_a0a1.cderiv_rule (f : X ‚Üí K) (g : X ‚Üí K)
    (hf : CDifferentiable K f) (hg : CDifferentiable K g) (hx : ‚àÄ x, g x ‚â† 0) :
    (cderiv K fun x => f x / g x)
    =
    fun x =>
      let k := f x
      let k' := g x
      fun dx =>
        ((cderiv K f x dx) * k' - k * (cderiv K g x dx)) / k'^2 :=



Theorem: SciLean.Prod.snd.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.snd.arg_self.ContCDiffAt_rule (x : X)
    (f : X ‚Üí Y√óZ) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).2) x :=



Theorem: SciLean.HAdd.hAdd.arg_a0a1.ContCDiff_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.ContCDiff_rule
    (f g : X ‚Üí Y) (hf : ContCDiff K n f) (hg : ContCDiff K n g) :
    ContCDiff K n (fun x => f x + g x) :=



Theorem: GetElem.getElem.arg_cont.semiAdjoint_rule_simple
File path: SciLean/Data/ArrayType/Properties.lean
Theorem statement: theorem GetElem.getElem.arg_cont.semiAdjoint_rule_simple (idx : Idx) :
    semiAdjoint K (fun cont : Cont => cont[idx])
    =
    fun elem => oneHot (X:=Cont) idx elem :=



Theorem: SciLean.Inner.inner.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Inner.inner.arg_a0a1.ContCDiffAt_rule
    (f : X ‚Üí Y) (g : X ‚Üí Y) (x : X)
    (hf : ContCDiffAt R n f x) (hg : ContCDiffAt R n g x) :
    ContCDiffAt R n (fun x => ‚ü™f x, g x‚ü´[R]) x :=



Theorem: SciLean.semiAdjoint.IndexType.sum.arg_f.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem IndexType.sum.arg_f.semiAdjoint_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i))
  : semiAdjoint K (fun x => ‚àë i, f x i)
    =
    (fun y => ‚àë i, semiAdjoint K (f ¬∑ i) y) :=



Theorem: SciLean.HSMul.hSMul.arg_a1.CDifferentiable_rule_int
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.CDifferentiable_rule_int
    (c : ‚Ñ§) (f : X ‚Üí Y) (hf : CDifferentiable K f) : CDifferentiable K fun x => c ‚Ä¢ f x :=



Theorem: Function.invFun.HAdd.hAdd.arg_a1.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a1.invFun_rule
  [AddGroup Y]
  (y : Y)  (f : X ‚Üí Y) (hf : Bijective f)
  : invFun (fun x => y + f x)
    =
    fun y' =>
      invFun f (-y + y')
  :=



Theorem: SciLean.Measure.prod_restrict
File path: SciLean/Core/Integral/Common.lean
Theorem statement: theorem Measure.prod_restrict {X Y} [MeasurableSpace X] [MeasurableSpace Y]
    (Œº : Measure X) (ŒΩ : Measure Y) (A : Set X) (B : Set Y) :
    (Measure.prod (Œº.restrict A) (ŒΩ.restrict B)) = (Œº.prod ŒΩ).restrict (A √óÀ¢ B) :=



Theorem: SciLean.ContCDiffMap_apply_CDifferentiableAt
File path: SciLean/Core/FunctionSpaces/ContCDiffMap.lean
Theorem statement: theorem ContCDiffMap_apply_CDifferentiableAt (f : W ‚Üí X ‚üø[K,‚àû] Y) (g : W ‚Üí X) (w : W)
    (hf : CDifferentiableAt K f w) (hg : CDifferentiableAt K g w) : CDifferentiableAt K (fun w => f w (g w)) w :=



Theorem: SciLean.BasisDuality.toDual.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.IsAffineMap_rule :
    IsAffineMap K (fun x : X => BasisDuality.toDual x) :=



Theorem: SciLean.toDistribution.linear_parDistribDeriv_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem toDistribution.linear_parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y) (L : Y ‚Üí Z)
    (hL : IsSmoothLinearMap R L) :
    parDistribDeriv (fun w => (fun x => L (f w x)).toDistribution)
    =
    fun w dw =>
      parDistribDeriv (fun w => (fun x => f w x).toDistribution) w dw |>.postComp (fun y ‚ä∏ L y) :=



Theorem: SciLean.parametric_inverse_bijection
File path: SciLean/Core/Integral/ParametricInverse.lean
Theorem statement: theorem parametric_inverse_bijection [Nonempty X] (f : X ‚Üí Y) (hf : f.Bijective) (y : Y) :
    ParametricInverseAt f y
      (I := Unit) (X‚ÇÅ := fun _ => Unit)
      (p := fun _ _ x => x)
      (g := fun _ _ => f.invFun y)
      (dom := fun _ => Set.univ) :=



Theorem: SciLean.HSub.hSub.arg_a0a1.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.CDifferentiable_rule
  (f g : X ‚Üí Y) (hf : CDifferentiable K f) (hg : CDifferentiable K g)
  : CDifferentiable K (fun x => f x - g x)  :=



Theorem: SciLean.HasSemiAdjoint.HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HAdd.hAdd.arg_a0a1.HasSemiAdjoint_rule [ContinuousAdd Y]
    (f g : X ‚Üí Y) (hf : HasSemiAdjoint K f) (hg : HasSemiAdjoint K g) :
    HasSemiAdjoint K fun x => f x + g x :=



Theorem: SciLean.inner_dualBasis_basis
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem inner_dualBasis_basis  (i j : Œπ)
  : ‚ü™‚Öá'[X] i, ‚Öá j‚ü´[K] = if i=j then 1 else 0 :=



Theorem: SciLean.ContCDiffAt.apply_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.apply_rule
    (i : Œπ) (x) : ContCDiffAt K n (fun x : (i : Œπ) ‚Üí E i => x i) x :=



Theorem: Function.invFun.comp_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem comp_rule
  (f : Y ‚Üí Z) (g : X ‚Üí Y)
  (hf : Bijective f) (hg : Bijective g)
  : invFun (fun x => f (g x))
    =
    fun z =>
      let y := invFun f z
      let x := invFun g y
      x :=



Theorem: SciLean.SmoothLinearMap.indextype_sum_apply
File path: SciLean/Core/FunctionSpaces/SmoothLinearMap.lean
Theorem statement: theorem SmoothLinearMap.indextype_sum_apply {I} [IndexType I] (f : I ‚Üí X‚ä∏[K] Y) (x : X) :
    (‚àë i, f i) x = ‚àë i, f i x  :=



Theorem: Function.Bijective.HSub.hSub.arg_a1.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HSub.hSub.arg_a1.Bijective_rule
  [AddGroup Y]
   (y : Y) (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => y - f x
  :=



Theorem: SciLean.HasSemiAdjoint.SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.IndexType.sum.arg_f.HasSemiAdjoint_rule
  (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, HasSemiAdjoint K fun x : X => f x i)
  : HasSemiAdjoint K fun x => ‚àë i, f x i :=



Theorem: SciLean.Distribution.postComp.arg_T.IsSmoothLinarMap_rule
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.postComp.arg_T.IsSmoothLinarMap_rule (T : W ‚Üí ùíü'(X,Y)) (f : Y ‚ä∏ Z)
    (hT : IsSmoothLinearMap R T) :
    IsSmoothLinearMap R (fun w => (T w).postComp f) :=



Theorem: SciLean.Rand.mean_add'
File path: SciLean/Core/Rand/Rand.lean
Theorem statement: theorem mean_add' (x : Rand X) (x' : X) : x' + x.mean = (x' +  x).mean :=



Theorem: SciLean.Prod.mk.arg_fstsnd.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.ContCDiffAt_rule (x : X)
  (g : X ‚Üí Y) (hg : ContCDiffAt K n g x)
  (f : X ‚Üí Z) (hf : ContCDiffAt K n f x)
  : ContCDiffAt K n (fun x => (g x, f x)) x
  :=



Theorem: SciLean.semiAdjoint.starRingEnd.arg_a0.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem starRingEnd.arg_a0.semiAdjoint_rule
  (f : X ‚Üí K)
  : semiAdjoint K (fun x => conj (f x))
    =
    fun z => semiAdjoint K f z :=



Theorem: SciLean.proj_zero
File path: SciLean/Core/Objects/FinVec.lean
Theorem statement: theorem proj_zero (i : Œπ)
  : ‚Ñº i (0 : X) = 0 :=



Theorem: SciLean.HasSemiAdjoint.Finset.sum.arg_f.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Finset.sum.arg_f.HasSemiAdjoint_rule {Œπ : Type _} [Fintype Œπ]
  (f : X ‚Üí Œπ ‚Üí Y) (_ : ‚àÄ i, HasSemiAdjoint K fun x : X => f x i) (A : Finset Œπ)
  : HasSemiAdjoint K fun x => ‚àë i in A, f x i :=



Theorem: SciLean.HSub.hSub.arg_a0.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a0.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => f x - y)
    =
    fun x dx =>
      cderiv K f x dx :=



Theorem: SciLean.semiAdjoint.SciLean.semiAdjoint.arg_y.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.semiAdjoint_rule
  (f : X ‚Üí Y) (a3 : W ‚Üí Y) (hf : HasSemiAdjoint K f) (ha3 : HasSemiAdjoint K a3)
  : semiAdjoint K (fun w => semiAdjoint K f (a3 w))
    =
    fun x =>
      let y := f x
      semiAdjoint K a3 y :=



Theorem: SciLean.semiAdjoint.const_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem const_rule : semiAdjoint K (fun (_ : X) => (0 : Y)) = fun x => 0 :=



Theorem: SciLean.HasSemiAdjoint.pi_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem pi_rule
    (f : X ‚Üí (i : Œπ) ‚Üí E i) (hf : ‚àÄ i, HasSemiAdjoint K (f ¬∑ i)) :
    HasSemiAdjoint K (fun x i => f x i) :=



Theorem: SciLean.HasSemiAdjoint.const_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem const_rule : HasSemiAdjoint K (fun _ : X => (0:Y)) :=



Theorem: SciLean.HMul.hMul.arg_a0a1.cderiv_rule_at
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HMul.hMul.arg_a0a1.cderiv_rule_at (x : X) (f g : X ‚Üí K)
    (hf : CDifferentiableAt K f x) (hg : CDifferentiableAt K g x) :
    (cderiv K fun x => f x * g x) x
    =
    let fx := f x
    let gx := g x
    fun dx =>
      (cderiv K g x dx) * fx + (cderiv K f x dx) * gx :=



Theorem: Function.Bijective.Equiv.invFun.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Equiv.invFun.arg_a0.Bijective_rule (f : Y ‚âÉ Z) (g : X ‚Üí Z) (hf : Bijective g)
  : Bijective (fun x => f.invFun (g x)) :=



Theorem: Function.Bijective.Inv.inv.arg_a0.Bijective_rule_group
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Inv.inv.arg_a0.Bijective_rule_group
  [Group Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => (f x)‚Åª¬π
  :=



Theorem: Function.Bijective.HAdd.hAdd.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : Bijective fun x => f x + y
  :=



Theorem: SciLean.ContCDiffAt.const_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.const_rule (y : Y) (x : X) :
    ContCDiffAt K n (fun _ : X => y) x :=



Theorem: SciLean.norm2_scalar
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm2_scalar {R} [RealScalar R] (x : R) :
  ‚Äñx‚Äñ‚ÇÇ¬≤[R] = x^2 :=



Theorem: SciLean.HSub.hSub.arg_a0a1.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem HSub.hSub.arg_a0a1.ContCDiffAt_rule
    (x : X) (f g : X ‚Üí Y) (hf : ContCDiffAt K n f x) (hg : ContCDiffAt K n g x) :
    ContCDiffAt K n (fun x => f x - g x) x :=



Theorem: SciLean.HasSemiAdjoint.Neg.neg.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem Neg.neg.arg_a0.HasSemiAdjoint_rule
    (f : X ‚Üí Y) : HasSemiAdjoint K fun x => - f x :=



Theorem: SciLean.Distribution.extAction_iteD'
File path: SciLean/Core/Distribution/Basic.lean
Theorem statement: theorem Distribution.extAction_iteD' (A B : Set X) (t e : ùíü'(X,U)) (œÜ : X ‚Üí V) (L : U ‚ä∏ V ‚ä∏ W) :
    ((iteD A t e).restrict B).extAction œÜ L =
        (t.restrict B).extAction (fun x => if x ‚àà A then œÜ x else 0) L +
        (e.restrict B).extAction (fun x => if x ‚àâ A then œÜ x else 0) L :=



Theorem: SciLean.ContCDiffAt.pi_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem ContCDiffAt.pi_rule (x : X)
    (f : X ‚Üí (i : Œπ) ‚Üí E i)
    (hf : ‚àÄ i, ContCDiffAt K n (f ¬∑ i) x) :
    ContCDiffAt K n (fun x i => f x i) x :=



Theorem: SciLean.Basis.proj.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Basis.proj.arg_x.ContCDiffAt_rule (i : IX) (x)
  : ContCDiffAt K n (fun x : X => ‚Ñº i x) x :=



Theorem: SciLean.DistribDiffrentiable.comp_rule
File path: SciLean/Core/Distribution/ParametricDistribDeriv.lean
Theorem statement: theorem DistribDiffrentiable.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    DistribDifferentiable (fun x => f (g x)) :=



Theorem: SciLean.HSub.hSub.arg_a1.cderiv_rule
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem HSub.hSub.arg_a1.cderiv_rule
    (f : X ‚Üí Y) (y : Y) :
    (cderiv K fun x => y - f x)
    =
    fun x dx =>
      - cderiv K f x dx :=



Theorem: SciLean.HasSemiAdjoint.SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem SciLean.semiAdjoint.arg_y.HasSemiAdjoint_rule
  (f : X ‚Üí Y) (a0 : W ‚Üí Y) (ha0 : HasSemiAdjoint K a0)
  : HasSemiAdjoint K (fun w => semiAdjoint K f (a0 w)) :=



Theorem: Function.Bijective.Neg.neg.arg_a0.Bijective_rule
File path: SciLean/Core/FunctionPropositions/Bijective.lean
Theorem statement: theorem Neg.neg.arg_a0.Bijective_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (hf : Bijective f)
  : Bijective fun x => - f x
  :=



Theorem: SciLean.Basis.proj.arg_x.IsAffineMap_rule
File path: SciLean/Core/FunctionPropositions/IsAffineMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsAffineMap_rule (i : IX) :
    IsAffineMap K (fun x : X => ‚Ñº i x) :=



Theorem: SciLean.revDerivUpdate.pi_rule
File path: SciLean/Core/FunctionTransformations/RevDeriv.lean
Theorem statement: theorem pi_rule
    (f :  X ‚Üí (i : I) ‚Üí EI i) (hf : ‚àÄ i, HasAdjDiff K (f ¬∑ i)) :
    (revDerivUpdate K fun (x : X) (i : I) => f x i)
    =
    fun x =>
      let xdf := fun i => revDerivUpdate K (f ¬∑ i) x
      (fun i => (xdf i).1,
       fun dy dx =>
         Fold.fold (IndexType.univ I) (fun dx i => (xdf i).2 (dy i) dx) dx) :=



Theorem: SciLean.norm‚ÇÇ_squared
File path: SciLean/Core/Objects/SemiInnerProductSpace.lean
Theorem statement: theorem norm‚ÇÇ_squared {R K X : Type _} [Scalar R K] [Norm2 K X] (x : X)
  : ‚Äñx‚Äñ‚ÇÇ[K] ^ (2:K) = ‚Äñx‚Äñ‚ÇÇ¬≤[K] :=



Theorem: Set.Neg.neg.arg_a1.preimage_rule_Ioo
File path: SciLean/Core/FunctionTransformations/Preimage.lean
Theorem statement: theorem Neg.neg.arg_a1.preimage_rule_Ioo (a b : R)  :
    preimage (fun x : R => - x) (Ioo a b)
    =
    Ioo (-b) (-a) :=



Theorem: SciLean.Basis.proj.arg_x.CDifferentiable_rule
File path: SciLean/Core/FunctionPropositions/CDifferentiable.lean
Theorem statement: theorem Basis.proj.arg_x.CDifferentiable_rule (i : IX)
  : CDifferentiable K (fun x : X => ‚Ñº i x) :=



Theorem: SciLean.scalar_sqrt_one
File path: SciLean/Core/Objects/Scalar.lean
Theorem statement: theorem scalar_sqrt_one  : Scalar.sqrt (1 : R) = 1 :=



Theorem: SciLean.semiAdjoint.let_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem let_rule
    (f : X ‚Üí Y ‚Üí Z) (g : X ‚Üí Y)
    (hf : HasSemiAdjoint K ‚Üøf) (hg : HasSemiAdjoint K g) :
    semiAdjoint K (fun x => let y := g x; f x y)
    =
    fun z =>
      let xy := semiAdjoint K (fun xy : X√óY => f xy.1 xy.2) z
      let x' := semiAdjoint K g xy.2
      xy.1 + x' :=



Theorem: SciLean.FwdFDeriv.FinType.sum.arg_f.fwdFDeriv_rule_at
File path: SciLean/Core/FunctionTransformations/FwdFDeriv.lean
Theorem statement: theorem FinType.sum.arg_f.fwdFDeriv_rule_at (x : X)
    (f : X ‚Üí Œπ ‚Üí Y) (hf : ‚àÄ i, DifferentiableAt K (f ¬∑ i) x) :
    fwdFDeriv K (fun x => ‚àë i, f x i) x
    =
    fun dx =>
      let ydy := fun i => fwdFDeriv K (f ¬∑ i) x dx
      ‚àë i, ydy i :=



Theorem: SciLean.semiAdjoint.Prod.mk.arg_fstsnd.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem Prod.mk.arg_fstsnd.semiAdjoint_rule
  (g : X ‚Üí Y) (f : X ‚Üí Z)
  (hg : HasSemiAdjoint K g) (hf : HasSemiAdjoint K f)
  : semiAdjoint K (fun x => (g x, f x))
    =
    fun yz =>
      let x‚ÇÅ := semiAdjoint K g yz.1
      let x‚ÇÇ := semiAdjoint K f yz.2
      x‚ÇÅ + x‚ÇÇ :=



Theorem: SciLean.BasisDuality.toDual.arg_x.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem BasisDuality.toDual.arg_x.ContCDiffAt_rule (x)
  : ContCDiffAt K n (fun x : X => BasisDuality.toDual x) x :=



Theorem: SciLean.semiAdjoint.HSMul.hSMul.arg_a1.semiAdjoint_rule
File path: SciLean/Core/FunctionTransformations/SemiAdjoint.lean
Theorem statement: theorem HSMul.hSMul.arg_a1.semiAdjoint_rule
  (c : K) (g : X ‚Üí Y) (hg : HasSemiAdjoint K g)
  : semiAdjoint K (fun x => c ‚Ä¢ g x)
    =
    fun y => (conj c) ‚Ä¢ semiAdjoint K g y :=



Theorem: SciLean.parametric_inverse_affine
File path: SciLean/Core/Integral/PlaneDecomposition.lean
Theorem statement: theorem parametric_inverse_affine {n} (f : X ‚Üí R) (c : R) (hf : IsAffineMap R f)
    (hn : n + 1 = card Œπ := by first | assumption | infer_var) :
    let u  := ‚àá f 0
    let dec := planeDecomposition (R:=R) u hn
    ParametricInverseAt f c
      (I:=Unit)
      (p:=fun _ y t => dec (t,y))
      (g:=fun _ _ => (c - f 0) / ‚Äñu‚Äñ‚ÇÇ)
      (dom := fun _ => ‚ä§) :=



Theorem: SciLean.odeSolve.arg_x‚ÇÄ.semiAdjoint_rule
File path: SciLean/Modules/DifferentialEquations/OdeSolve.lean
Theorem statement: theorem odeSolve.arg_x‚ÇÄ.semiAdjoint_rule
  (f : R ‚Üí X ‚Üí X) (t‚ÇÄ t : R) (x‚ÇÄ : W ‚Üí X)
  (hf : ‚àÄ t, HasSemiAdjoint R (f t)) (hx‚ÇÄ : HasSemiAdjoint R x‚ÇÄ)
  : semiAdjoint R (fun w => odeSolve f t‚ÇÄ t (x‚ÇÄ w))
    =
    fun x‚ÇÄ' =>
      let f' := (fun s y => - semiAdjoint R (f s) y)
      let y := odeSolve f' t t‚ÇÄ x‚ÇÄ'
      semiAdjoint R x‚ÇÄ y :=



Theorem: SciLean.Basis.proj.arg_x.IsLinearMap_rule
File path: SciLean/Core/FunctionPropositions/IsLinearMap.lean
Theorem statement: theorem Basis.proj.arg_x.IsLinearMap_rule (i : IX) :
    IsLinearMap K (fun x : X => ‚Ñº i x) :=



Theorem: SciLean.Neg.neg.arg_a0.cderiv_rule'
File path: SciLean/Core/FunctionTransformations/CDeriv.lean
Theorem statement: theorem Neg.neg.arg_a0.cderiv_rule' (x : X) (f : X ‚Üí Y) :
    (cderiv K fun x => - f x) x
    =
    fun dx => - cderiv K f x dx :=



Theorem: SciLean.Prod.fst.arg_self.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem Prod.fst.arg_self.ContCDiffAt_rule (x : X)
    (f : X ‚Üí Y√óZ) (hf : ContCDiffAt K n f x) :
    ContCDiffAt K n (fun x => (f x).1) x :=



Theorem: Function.invFun.HAdd.hAdd.arg_a0.invFun_rule
File path: SciLean/Core/FunctionTransformations/InvFun.lean
Theorem statement: theorem HAdd.hAdd.arg_a0.invFun_rule
  [AddGroup Y]
  (f : X ‚Üí Y) (y : Y) (hf : Bijective f)
  : invFun (fun x => f x + y)
    =
    fun y' =>
      invFun f (y' - y)
  :=



Theorem: SciLean.IndexType.sum.arg_f.ContCDiffAt_rule
File path: SciLean/Core/FunctionPropositions/ContCDiff.lean
Theorem statement: theorem IndexType.sum.arg_f.ContCDiffAt_rule
  (f : X ‚Üí Œπ ‚Üí Y) (x : X) (hf : ‚àÄ i, ContCDiffAt K n (fun x => f x i) x)
  : ContCDiffAt K n (fun x => ‚àë i, f x i) x :=



Theorem: SciLean.HasSemiAdjoint.HMul.hMul.arg_a0.HasSemiAdjoint_rule
File path: SciLean/Core/FunctionPropositions/HasSemiAdjoint.lean
Theorem statement: theorem HMul.hMul.arg_a0.HasSemiAdjoint_rule
  (f : X ‚Üí K) (y' : K) (hf : HasSemiAdjoint K f)
  : HasSemiAdjoint K fun x => f x * y' :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/ImperialCollegeLondon/FLT (commit: b208a302cdcbfadce33d8165f0b054bfa17e2147)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 2

Theorem: Hurwitz.exists_near
File path: FLT/AutomorphicRepresentation/Example.lean
Theorem statement: lemma exists_near (z : ‚Ñç) : ‚àÉ q : ùìû, dist z (toQuaternion q) < 1 :=



Theorem: Hurwitz.canonicalForm
File path: FLT/AutomorphicRepresentation/Example.lean
Theorem statement: lemma canonicalForm (z : D^) : ‚àÉ (N : ‚Ñï+) (z' : ùìû^), z = j‚ÇÅ ((N‚Åª¬π : ‚Ñö) ‚äó‚Çú 1 : D) * j‚ÇÇ z' :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/teorth/pfr (commit: fa398a5b853c7e94e3294c45e50c6aee013a2687)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 36

Theorem: rho_of_subgroup
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_subgroup (H: AddSubgroup G)  {Œ© : Type*} [MeasureSpace Œ©] (U : Œ© ‚Üí G) (hunif: IsUniform H U) (A : Finset G) (r:‚Ñù) (hr: rho U A ‚â§ r) : ‚àÉ t:G, Nat.card ((A:Set G) ‚à© ((t +·µ• H.carrier)) : Set G) ‚â§ 2^(-r) * (Nat.card A * Nat.card H)^(1/2) ‚àß Nat.card A ‚â§ 2^(2*r) * Nat.card H ‚àß Nat.card H ‚â§ 2^(2*r) * Nat.card A :=



Theorem: iter_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule {m:‚Ñï} (G : Fin (m+1) ‚Üí Type*) (hG: ‚àÄ i, MeasurableSpace (G i)) (hGs: ‚àÄ i, MeasurableSingletonClass (G i)) (hGa: ‚àÄ i, AddCommGroup (G i)) (hGsub: ‚àÄ i, MeasurableSub‚ÇÇ (G i)) (hGadd: ‚àÄ i, MeasurableAdd‚ÇÇ (G i)) (hGcount: ‚àÄ i, Fintype (G i)) (œÜ: ‚àÄ i, G (i+1) ‚Üí+ G i) (œÄ: ‚àÄ d, G m ‚Üí+ G d) (hcomp: ‚àÄ i, i < m ‚Üí œÄ i = (œÜ i) ‚àò (œÄ (i+1))) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí (G m)) (hindep : iIndepFun (fun _ ‚Ü¶ (hG m)) X ) : D[X; fun _ ‚Ü¶ hŒ©] = ‚àë d ‚àà Finset.Iio m, D[ fun i ‚Ü¶ (œÄ (d+1)) ‚àò (X i) | fun i ‚Ü¶ (œÄ d) ‚àò (X i); fun _ ‚Ü¶ hŒ©] + ‚àë d ‚àà Finset.Iio m, I[ ‚àë i, X i : fun œâ ‚Ü¶ (fun i ‚Ü¶ (œÄ (d+1)) (X i œâ)) | ‚ü® (œÄ (d+1)) ‚àò ‚àë i, X i, fun œâ ‚Ü¶ (fun i ‚Ü¶ (œÄ d) (X i œâ))‚ü© ] :=



Theorem: condRho_sum_le'
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_sum_le' {Œ©': Type uG} [MeasureSpace Œ©'] (Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ : Œ©' ‚Üí G) (hindep: iIndepFun (fun _ ‚Ü¶ hGm) ![Y‚ÇÅ, Y‚ÇÇ, Y‚ÇÉ, Y‚ÇÑ]) :
  let S := Y‚ÇÅ + Y‚ÇÇ + Y‚ÇÉ + Y‚ÇÑ
  let T‚ÇÅ := Y‚ÇÅ + Y‚ÇÇ
  let T‚ÇÇ := Y‚ÇÅ + Y‚ÇÉ
  let T‚ÇÉ := Y‚ÇÇ + Y‚ÇÉ
  condRho T‚ÇÅ T‚ÇÇ A + condRho T‚ÇÇ T‚ÇÅ A + condRho T‚ÇÅ T‚ÇÉ A + condRho T‚ÇÉ T‚ÇÅ A + condRho T‚ÇÇ T‚ÇÉ A + condRho T‚ÇÉ T‚ÇÇ A - 3*(rho Y‚ÇÅ A + rho Y‚ÇÇ A + rho Y‚ÇÉ A + rho Y‚ÇÑ A)/2 ‚â§ d[ Y‚ÇÅ # Y‚ÇÇ ] + d[ Y‚ÇÅ # Y‚ÇÉ ] + d[ Y‚ÇÅ # Y‚ÇÑ ] + d[ Y‚ÇÇ # Y‚ÇÉ ] + d[ Y‚ÇÇ # Y‚ÇÑ ] + d[ Y‚ÇÉ # Y‚ÇÑ ] :=



Theorem: I_one_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma I_one_le : I‚ÇÅ ‚â§ 2 * Œ∑ * d[ X‚ÇÅ # X‚ÇÇ ] :=



Theorem: multidist_eq_zero
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_eq_zero {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i)) (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) (hvanish: D[X; hŒ©] = 0) : ‚àÄ i, ‚àÉ H : AddSubgroup G, ‚àÉ U : (Œ© i) ‚Üí G, Measurable U ‚àß IsUniform H U ‚àß d[X i # U] = 0  :=



Theorem: dist_le_of_sum_zero
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_le_of_sum_zero {Œ©': Type uG} [MeasureSpace Œ©'] (T‚ÇÅ T‚ÇÇ T‚ÇÉ : Œ©' ‚Üí G) (hsum: T‚ÇÅ + T‚ÇÇ + T‚ÇÉ = 0) : d[ X‚ÇÅ # X‚ÇÇ ] ‚â§ 3 * I[T‚ÇÅ : T‚ÇÇ | T‚ÇÉ] + (2 * H[T‚ÇÉ] - H[T‚ÇÅ] - H[T‚ÇÇ]) + Œ∑ * (condRho T‚ÇÅ T‚ÇÉ A + condRho T‚ÇÇ T‚ÇÉ A - rho X‚ÇÅ A - rho X‚ÇÇ A) :=



Theorem: condRho_of_injective
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_injective {Œ© S T : Type*} [MeasureSpace Œ©] (X : Œ© ‚Üí G) (Y : Œ© ‚Üí S) (A : Finset G) (f: S ‚Üí T) (hf: Function.Injective f) : condRho X (f ‚àò Y) A = condRho X Y A :=



Theorem: rho_of_translate
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_translate {Œ© : Type*} [MeasureSpace Œ©]
    (X : Œ© ‚Üí G) (A : Finset G) (s:G) : rho (fun œâ ‚Ü¶ X œâ + s) A = rho X A :=



Theorem: rho_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_sum {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho (X+Y) A ‚â§ rho X A + (H[X+Y] - H[X])/2 :=



Theorem: dist_add_dist_eq
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_add_dist_eq : d[ X‚ÇÅ # X‚ÇÅ ] + d[ X‚ÇÇ # X‚ÇÇ ] = 2 * d[ X‚ÇÅ # X‚ÇÇ ] + (I‚ÇÇ - I‚ÇÅ) :=



Theorem: phi_min_exists
File path: PFR/RhoFunctional.lean
Theorem statement: lemma phi_min_exists : ‚àÉ (Œ©: Type uG) (_:MeasureSpace Œ©) (X Y : Œ© ‚Üí G), phiMinimizes X Y Œ∑ A :=



Theorem: condRho_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_sum_le {Œ©': Type uG} [MeasureSpace Œ©'] (Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ : Œ©' ‚Üí G) (hindep: iIndepFun (fun _ ‚Ü¶ hGm) ![Y‚ÇÅ, Y‚ÇÇ, Y‚ÇÉ, Y‚ÇÑ]) :
  let S := Y‚ÇÅ + Y‚ÇÇ + Y‚ÇÉ + Y‚ÇÑ
  let T‚ÇÅ := Y‚ÇÅ + Y‚ÇÇ
  let T‚ÇÇ := Y‚ÇÅ + Y‚ÇÉ
  condRho T‚ÇÅ T‚ÇÇ A + condRho T‚ÇÇ T‚ÇÅ A - (rho Y‚ÇÅ A + rho Y‚ÇÇ A + rho Y‚ÇÉ A + rho Y‚ÇÑ A)/2 ‚â§ (d[ Y‚ÇÅ # Y‚ÇÇ ] + d[ Y‚ÇÉ # Y‚ÇÑ ] + d[ Y‚ÇÅ # Y‚ÇÉ ] + d[ Y‚ÇÇ # Y‚ÇÑ ]) / 2 :=



Theorem: rho_plus_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_plus_of_sum  {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho_plus (X+Y) A ‚â§ rho_plus X A + H[X+Y] - H[X] :=



Theorem: multidist_ruzsa_III
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_III {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) (hident: ‚àÄ j k, IdentDistrib (X j) (X k)): ‚àÄ i, D[X; hŒ©] ‚â§ m * d[X i # X i] :=



Theorem: I_two_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma I_two_le : I‚ÇÇ ‚â§ 2 * Œ∑ * d[ X‚ÇÅ # X‚ÇÇ ] + (Œ∑ / (1 - Œ∑)) * (2 * Œ∑ * d[ X‚ÇÅ # X‚ÇÇ ] - I‚ÇÅ) :=



Theorem: ent_of_sum_le_ent_of_sum
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma ent_of_sum_le_ent_of_sum [IsProbabilityMeasure Œº] {I : Type*} {s t : Finset I} (hdisj : Disjoint s t)
    (hs : Finset.Nonempty s) (ht : Finset.Nonempty t) (X : I ‚Üí Œ© ‚Üí G) (hX : (i : I) ‚Üí Measurable (X i))
    (hX' : (i : I) ‚Üí FiniteRange (X i)) (hindep : iIndepFun (fun (i : I) ‚Ü¶ hG) X Œº ) (f : I ‚Üí I)
    (hf : Finset.image f t ‚äÜ s) :
    H[‚àë i in t, X i; Œº] ‚â§ H[‚àë i in s, X i; Œº] + ‚àë i in t, (H[X i - X (f i); Œº] - H[X (f i); Œº]) :=



Theorem: condRho_of_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_of_sum_le {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : condRho X (X + Y) A ‚â§ (rho X A + rho Y A + d[ X # Y ]) / 2 :=



Theorem: rho_minus_of_sum
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_minus_of_sum  {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho_minus (X+Y) A ‚â§ rho_minus X A :=



Theorem: multidist_ruzsa_I
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_I {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G): ‚àë j, ‚àë k, (if j = k then (0:‚Ñù) else d[X j # X k]) ‚â§ m * (m-1) * D[X; hŒ©] :=



Theorem: cor_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cor_multiDist_chainRule [Fintype G] {m:‚Ñï} (hm: m ‚â• 1) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin (m+1) √ó Fin (m+1) ‚Üí Œ© ‚Üí G) (hindep : iIndepFun (fun _ ‚Ü¶ hG) X) : I[ fun œâ ‚Ü¶ (fun j ‚Ü¶ ‚àë i, X (i, j) œâ) : fun œâ ‚Ü¶ (fun i ‚Ü¶ ‚àë j, X (i, j) œâ) | ‚àë p, X p] ‚â§ ‚àë j, (D[ fun i ‚Ü¶ X (i, j); fun _ ‚Ü¶ hŒ©] -  D[ fun i ‚Ü¶ X (i, j) | fun i ‚Ü¶ ‚àë k ‚àà Finset.Ici j, X (i, k); fun _ ‚Ü¶ hŒ©]) + D[ fun i ‚Ü¶ X (i, m); fun _ ‚Ü¶ hŒ©] - D[ fun i ‚Ü¶ ‚àë j, X (i, j); fun _ ‚Ü¶ hŒ©] :=



Theorem: condRho_minus_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_minus_le {Œ© S : Type*} [MeasureSpace Œ©] [MeasurableSpace S] (X : Œ© ‚Üí G) (Z : Œ© ‚Üí S) (A : Finset G) : condRho_minus X Z A ‚â§ rho_minus X A + H[ X ] - H[ X | Z ] :=



Theorem: cond_multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma cond_multiDist_chainRule (G H: Type*) [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G] [MeasurableSub‚ÇÇ G] [MeasurableAdd‚ÇÇ G] [Countable G] [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H] [MeasurableSub‚ÇÇ H] [MeasurableAdd‚ÇÇ H] [Fintype H] (œÄ: G ‚Üí+ H) {S : Type*} [Fintype S] [hS: MeasurableSpace S] {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G) (Y : Fin m ‚Üí Œ© ‚Üí S) (hindep : iIndepFun (fun _ ‚Ü¶ (hG.prod hS)) (fun i ‚Ü¶ ‚ü® X i, Y i ‚ü©) ) : D[X | Y; fun _ ‚Ü¶ hŒ©] = D[X | fun i ‚Ü¶ ‚ü® œÄ ‚àò (X i), Y i ‚ü©; fun _ ‚Ü¶ hŒ©] + D[ fun i ‚Ü¶ œÄ ‚àò (X i) | Y; fun _ ‚Ü¶ hŒ©] + I[ ‚àë i, X i : fun œâ ‚Ü¶ (fun i ‚Ü¶ œÄ (X i œâ)) | ‚ü® œÄ ‚àò (‚àë i, X i), fun œâ ‚Ü¶ (fun i ‚Ü¶ Y i œâ)‚ü©] :=



Theorem: multiDist_chainRule
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_chainRule (G H: Type*) [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G] [MeasurableSub‚ÇÇ G] [MeasurableAdd‚ÇÇ G] [Countable G] [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H] [MeasurableSub‚ÇÇ H] [MeasurableAdd‚ÇÇ H] [Fintype H] (œÄ: G ‚Üí+ H) {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G) (hindep : iIndepFun (fun _ ‚Ü¶ hG) X ) : D[X; fun _ ‚Ü¶ hŒ©] = D[X | fun i ‚Ü¶ œÄ ‚àò (X i); fun _ ‚Ü¶ hŒ©] + D[ fun i ‚Ü¶ œÄ ‚àò (X i); fun _ ‚Ü¶ hŒ©] + I[ ‚àë i, X i : fun œâ ‚Ü¶ (fun i ‚Ü¶ œÄ (X i œâ)) | œÄ ‚àò (‚àë i, X i)] :=



Theorem: condRho_plus_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_plus_le {Œ© S : Type*} [MeasureSpace Œ©] [MeasurableSpace S] (X : Œ© ‚Üí G) (Z : Œ© ‚Üí S) (A : Finset G) : condRho_plus X Z A ‚â§ rho_plus X A :=



Theorem: multiTau_min_exists
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_min_exists {G Œ©‚ÇÄ : Type u} [MeasureableFinGroup G] [MeasureSpace Œ©‚ÇÄ] (p : multiRefPackage G Œ©‚ÇÄ) : ‚àÉ (Œ© : Fin p.m ‚Üí Type u) (hŒ© : ‚àÄ i, MeasureSpace (Œ© i)) (X : ‚àÄ i, Œ© i ‚Üí G), multiTauMinimizes p Œ© hŒ© X :=



Theorem: multidist_ruzsa_IV
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_IV {m:‚Ñï} (hm: m ‚â• 2) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G)
    (hindep : iIndepFun (fun _ ‚Ü¶ hG) X ) : d[ ‚àë i, X i # ‚àë i, X i ] ‚â§ 2 * D[X; fun _ ‚Ü¶ hŒ©] :=



Theorem: iter_multiDist_chainRule'
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma iter_multiDist_chainRule'  {m:‚Ñï} (G : Fin (m+1) ‚Üí Type*) (hG: ‚àÄ i, MeasurableSpace (G i)) (hGs: ‚àÄ i, MeasurableSingletonClass (G i)) (hGa: ‚àÄ i, AddCommGroup (G i)) (hGsub: ‚àÄ i, MeasurableSub‚ÇÇ (G i)) (hGadd: ‚àÄ i, MeasurableAdd‚ÇÇ (G i)) (hGcount: ‚àÄ i, Fintype (G i)) (œÜ: ‚àÄ i, G (i+1) ‚Üí+ G i) (œÄ: ‚àÄ d, G m ‚Üí+ G d) (hcomp: ‚àÄ i, i < m ‚Üí œÄ i = (œÜ i) ‚àò (œÄ (i+1))) {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí (G m)) (hindep : iIndepFun (fun _ ‚Ü¶ (hG m)) X ) : D[X; fun _ ‚Ü¶ hŒ©] ‚â• ‚àë d ‚àà Finset.Iio m, D[ fun i ‚Ü¶ (œÄ (d+1)) ‚àò (X i) | fun i ‚Ü¶ (œÄ d) ‚àò (X i); fun _ ‚Ü¶ hŒ©]  :=



Theorem: multiDist_indep
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_indep {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (X : Fin m ‚Üí Œ© ‚Üí G)
    (hindep : iIndepFun (fun _ ‚Ü¶ hG) X ) :
    D[X ; fun _ ‚Ü¶ hŒ©] = H[‚àë i, X i] - (‚àë i, H[X i]) / m :=



Theorem: rho_of_sum_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_of_sum_le {Œ© : Type*} [MeasureSpace Œ©] (X Y : Œ© ‚Üí G) (A : Finset G) (hindep: IndepFun X Y) : rho (X + Y) A ‚â§ (rho X A + rho Y A + d[ X # Y ]) / 2 :=



Theorem: condRho_le
File path: PFR/RhoFunctional.lean
Theorem statement: lemma condRho_le {Œ© S : Type*} [MeasureSpace Œ©] [MeasurableSpace S] (X : Œ© ‚Üí G) (Z : Œ© ‚Üí S) (A : Finset G) : condRho X Z A ‚â§ rho X A + (H[ X ] - H[ X | Z ]) / 2 :=



Theorem: dist_of_min_eq_zero
File path: PFR/RhoFunctional.lean
Theorem statement: lemma dist_of_min_eq_zero (hŒ∑': Œ∑ < 1/8) : d[ X‚ÇÅ # X‚ÇÇ ] = 0 :=



Theorem: condMultiDist_eq
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma condMultiDist_eq {m : ‚Ñï} {Œ© : Type*} (hŒ© : MeasureSpace Œ©) (hprob: IsProbabilityMeasure hŒ©.volume) {S: Type*} [Fintype S] [hS: MeasurableSpace S] [MeasurableSingletonClass S]
    (X : (i : Fin m) ‚Üí Œ© ‚Üí G) (Y : (i : Fin m) ‚Üí Œ© ‚Üí S) (hY : (i:Fin m) ‚Üí  Measurable (Y i)) (hindep: ProbabilityTheory.iIndepFun (fun _ ‚Ü¶ hG.prod hS) (fun i ‚Ü¶ ‚ü® X i, Y i ‚ü©) ): D[ X | Y ; fun _ ‚Ü¶ hŒ©] =  H[ fun œâ ‚Ü¶ ‚àë i, X i œâ | fun œâ ‚Ü¶ (fun i ‚Ü¶ Y i œâ)] - (m:‚Ñù)‚Åª¬π * ‚àë i, H[X i | Y i] :=



Theorem: multiTau_continuous
File path: PFR/MultiTauFunctional.lean
Theorem statement: lemma multiTau_continuous {G Œ©‚ÇÄ : Type u} [MeasureableFinGroup G] [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] [MeasureSpace Œ©‚ÇÄ] (p : multiRefPackage G Œ©‚ÇÄ) : Continuous
      (fun (Œº : Fin p.m ‚Üí ProbabilityMeasure G) ‚Ü¶ multiTau p (fun _ ‚Ü¶ G) (fun i ‚Ü¶ ‚ü® Œº i ‚ü©) (fun _ ‚Ü¶ id)) :=



Theorem: rho_continuous
File path: PFR/RhoFunctional.lean
Theorem statement: lemma rho_continuous [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] : Continuous
      (fun (Œº: ProbabilityMeasure G) ‚Ü¶ @rho G _ hGm G ‚ü® Œº ‚ü© id A) :=



Theorem: multiDist_nonneg
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multiDist_nonneg {m : ‚Ñï} {Œ© : Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G) : D[X ; hŒ©] ‚â• 0 :=



Theorem: multidist_ruzsa_II
File path: PFR/MoreRuzsaDist.lean
Theorem statement: lemma multidist_ruzsa_II {m:‚Ñï} (hm: m ‚â• 2) {Œ©: Fin m ‚Üí Type*} (hŒ© : (i : Fin m) ‚Üí MeasureSpace (Œ© i))
    (X : (i : Fin m) ‚Üí (Œ© i) ‚Üí G): ‚àë j, d[X j # X j] ‚â§ 2 * m * D[X; hŒ©] :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/AlexKontorovich/PrimeNumberTheoremAnd (commit: 29baddd685660b5fedd7bd67f9916ae24253d566)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 27

Theorem: pn_asymptotic
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pn_asymptotic : ‚àÉ c : ‚Ñï ‚Üí ‚Ñù, c =o[atTop] (fun _ ‚Ü¶ (1:‚Ñù)) ‚àß
    ‚àÄ n : ‚Ñï, Nat.nth Nat.Prime n = (1 + c n) * n * log n :=



Theorem: pn_pn_plus_one
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pn_pn_plus_one : ‚àÉ c : ‚Ñï ‚Üí ‚Ñù, c =o[atTop] (fun _ ‚Ü¶ (1:‚Ñù)) ‚àß
    ‚àÄ n : ‚Ñï, Nat.nth Nat.Prime (n+1) - Nat.nth Nat.Prime n = (c n) * Nat.nth Nat.Prime n :=



Theorem: primorial_bounds
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem primorial_bounds :
    ‚àÉ E : ‚Ñù ‚Üí ‚Ñù, E =o[atTop] (fun x ‚Ü¶ x) ‚àß
    ‚àÄ x : ‚Ñù, ‚àè p in (filter Nat.Prime (range ‚åäx‚åã‚Çä)), p = exp ( x + E x ) :=



Theorem: MediumPNT
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: theorem MediumPNT : ‚àÉ (c : ‚Ñù) (hc : c > 0),
    (ChebyshevPsi - id) =O[atTop] (fun (x : ‚Ñù) ‚Ü¶ x * Real.exp (-c * (Real.log x) ^ ((1 : ‚Ñù) / 18))) :=



Theorem: SmoothedChebyshevDirichlet
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: theorem SmoothedChebyshevDirichlet {œà : ‚Ñù ‚Üí ‚Ñù} (diffŒ® : ContDiff ‚Ñù 1 œà) (œàpos : ‚àÄ x, 0 ‚â§ œà x)
    (suppŒ® : Function.support œà ‚äÜ Icc (1 / 2) 2) (mass_one: ‚à´ x in Ioi (0 : ‚Ñù), œà x / x = 1)
    (X : ‚Ñù) (X_pos : 0 < X) (Œµ : ‚Ñù) (Œµpos: 0 < Œµ) :
    SmoothedChebyshev œà Œµ X = ‚àë' n, Œõ n * Smooth1 œà Œµ (n / X) :=



Theorem: lambda_pnt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem lambda_pnt : (fun x:‚Ñù ‚Ü¶ ‚àë n in range ‚åä x ‚åã‚Çä, (-1)^(Œ© n)) =o[atTop] (fun x ‚Ü¶ x) :=



Theorem: MellinInversion_aux2
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux2 {f : ‚Ñù ‚Üí ‚ÑÇ} (s : ‚ÑÇ) (fDiff : DifferentiableOn ‚Ñù f (Ioi 0))
    (fDiff2 : DifferentiableOn ‚Ñù (deriv f) (Ioi 0))
    (hfs : Tendsto (fun x ‚Ü¶ deriv f x * x ^ s) (ùìù[>]0) (ùìù 0))
    (hfinf : Tendsto (fun x ‚Ü¶ deriv f x * x ^ s) atTop (ùìù 0)) :
    ‚à´ x in Ioi 0, (deriv f x) * x ^ s =
      -‚à´ x in Ioi 0, (deriv (deriv f) x) * x ^ (s + 1) / (s + 1) :=



Theorem: ZetaDerivUpperBnd''
File path: PrimeNumberTheoremAnd/ZetaBounds.lean
Theorem statement: lemma ZetaDerivUpperBnd'' {A œÉ : ‚Ñù} (hA : A ‚àà Ioc 0 (1 / 2))
    (œÉ_le : œÉ ‚â§ 2) :
    (fun (t : ‚Ñù) ‚Ü¶
    ‚Äñ‚àë n in Finset.range (‚åä|t|‚åã‚Çä + 1), -1 / (n : ‚ÑÇ) ^ (œÉ + t * I) * (Real.log n)‚Äñ +
      ‚Äñ-(‚åä|t|‚åã‚Çä : ‚ÑÇ) ^ (1 - (œÉ + t * I)) / (1 - (œÉ + t * I)) ^ 2‚Äñ +
      ‚Äñ(Real.log ‚åä|t|‚åã‚Çä) * (‚åä|t|‚åã‚Çä : ‚ÑÇ) ^ (1 - (œÉ + t * I)) / (1 - (œÉ + t * I))‚Äñ +
      ‚Äñ(Real.log ‚åä|t|‚åã‚Çä) * (‚åä|t|‚åã‚Çä : ‚ÑÇ) ^ (-(œÉ + t * I)) / 2‚Äñ +
      ‚Äñ(1 * ‚à´ (x : ‚Ñù) in Ioi (‚åä|t|‚åã‚Çä : ‚Ñù), (‚åäx‚åã + 1 / 2 - x) * (x : ‚ÑÇ) ^ (-(œÉ + t * I) - 1))‚Äñ +
      ‚Äñ(œÉ + t * I) * ‚à´ (x : ‚Ñù) in Ioi (‚åä|t|‚åã‚Çä : ‚Ñù),
        (‚åäx‚åã + 1 / 2 - x) * (x : ‚ÑÇ) ^ (-(œÉ + t * I) - 1) * -(Real.log x)‚Äñ)
        =O[atTop ‚äì Filter.principal {t : ‚Ñù | |t| < Real.exp (A / (1 - œÉ))}] fun t ‚Ü¶ Real.log |t| ^ 2 :=



Theorem: continuousAt_Smooth1
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma continuousAt_Smooth1 {œà : ‚Ñù ‚Üí ‚Ñù} (diffŒ® : ContDiff ‚Ñù 1 œà) (œàpos : ‚àÄ (x : ‚Ñù), 0 ‚â§ œà x)
    (suppŒ® : support œà ‚äÜ Icc (1 / 2) 2) (mass_one : ‚à´ (x : ‚Ñù) in Ioi 0, œà x / x = 1)
    (Œµ : ‚Ñù) (Œµpos : 0 < Œµ) (y : ‚Ñù) (ypos : 0 < y) :
    ContinuousAt (fun x ‚Ü¶ Smooth1 œà Œµ x) y :=



Theorem: integrable_x_mul_Smooth1
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma integrable_x_mul_Smooth1 {œà : ‚Ñù ‚Üí ‚Ñù} (diffŒ® : ContDiff ‚Ñù 1 œà) (œàpos : ‚àÄ (x : ‚Ñù), 0 ‚â§ œà x)
    (suppŒ® : support œà ‚äÜ Icc (1 / 2) 2) (mass_one : ‚à´ (x : ‚Ñù) in Ioi 0, œà x / x = 1)
    (Œµ : ‚Ñù) (Œµpos : 0 < Œµ) :
    MeasureTheory.IntegrableOn (fun x ‚Ü¶ x * Smooth1 œà Œµ x) (Ioi 0) :=



Theorem: auto_cheby
File path: PrimeNumberTheoremAnd/Wiener.lean
Theorem statement: lemma auto_cheby (hpos: 0 ‚â§ f) (hf : ‚àÄ (œÉ' : ‚Ñù), 1 < œÉ' ‚Üí Summable (nterm f œÉ'))
    (hG: ContinuousOn G {s | 1 ‚â§ s.re})
    (hG' : Set.EqOn G (fun s ‚Ü¶ LSeries f s - A / (s - 1)) {s | 1 < s.re}) : cheby f :=



Theorem: mu_pnt_alt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem mu_pnt_alt : (fun x:‚Ñù ‚Ü¶ ‚àë n in range ‚åä x ‚åã‚Çä, (Œº n: ‚Ñù) / n) =o[atTop] (fun x ‚Ü¶ (1:‚Ñù)) :=



Theorem: chebyshev_asymptotic
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem chebyshev_asymptotic :
    (fun x ‚Ü¶ ‚àë p in (filter Nat.Prime (range ‚åàx‚åâ‚Çä)), log p) ~[atTop] (fun x ‚Ü¶ x) :=



Theorem: MellinInversion_aux3
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux3 {f : ‚Ñù ‚Üí ‚ÑÇ} (œÉ : ‚Ñù) (œÉ_ne_zero : œÉ ‚â† 0) (œÉ_ne_negOne : œÉ ‚â† -1)
    (fInt : IntegrableOn (fun x ‚Ü¶ f x * (x : ‚ÑÇ) ^ (œÉ : ‚ÑÇ)) (Ioi 0)) :
    IntegrableOn (fun (‚ü®x, t‚ü© : ‚Ñù √ó ‚Ñù) ‚Ü¶ f x * x ^ (œÉ + t * I) / ((œÉ + t * I) * ((œÉ + t * I) + 1)))
      ((Ioi 0).prod (univ : Set ‚Ñù)) :=



Theorem: pi_asymp
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pi_asymp :
    ‚àÉ c : ‚Ñù ‚Üí ‚Ñù, c =o[atTop] (fun _ ‚Ü¶ (1:‚Ñù)) ‚àß
    ‚àÄ x : ‚Ñù, Nat.primeCounting ‚åäx‚åã‚Çä = (1 + c x) * ‚à´ t in Set.Icc 2 x, 1 / (log t) ‚àÇ volume :=



Theorem: prime_between
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem prime_between {Œµ:‚Ñù} (hŒµ: 0 < Œµ): ‚àÄ·∂† x:‚Ñù in atTop, ‚àÉ p:‚Ñï, Nat.Prime p ‚àß
    x < p ‚àß p < (1+Œµ)* x :=



Theorem: limiting_fourier_variant
File path: PrimeNumberTheoremAnd/Wiener.lean
Theorem statement: lemma limiting_fourier_variant
    (hpos: 0 ‚â§ f)
    (hG: ContinuousOn G {s | 1 ‚â§ s.re})
    (hG' : Set.EqOn G (fun s ‚Ü¶ LSeries f s - A / (s - 1)) {s | 1 < s.re})
    (hf : ‚àÄ (œÉ' : ‚Ñù), 1 < œÉ' ‚Üí Summable (nterm f œÉ'))
    (œà : CS 2 ‚ÑÇ)
    (hœàpos : ‚àÄ y, 0 ‚â§ (ùìï œà y).re ‚àß (ùìï œà y).im = 0)
    (hx : 1 ‚â§ x) :
    ‚àë' n, f n / n * ùìï œà (1 / (2 * œÄ) * log (n / x)) -
      A * ‚à´ u in Set.Ici (-log x), ùìï œà (u / (2 * œÄ)) =
      ‚à´ (t : ‚Ñù), (G (1 + t * I)) * (œà t) * x ^ (t * I) :=



Theorem: crude_upper_bound
File path: PrimeNumberTheoremAnd/Wiener.lean
Theorem statement: lemma crude_upper_bound
    (hpos: 0 ‚â§ f)
    (hG: ContinuousOn G {s | 1 ‚â§ s.re})
    (hG' : Set.EqOn G (fun s ‚Ü¶ LSeries f s - A / (s - 1)) {s | 1 < s.re})
    (hf : ‚àÄ (œÉ' : ‚Ñù), 1 < œÉ' ‚Üí Summable (nterm f œÉ'))
    (œà : CS 2 ‚ÑÇ)
    (hœàpos : ‚àÄ y, 0 ‚â§ (ùìï œà y).re ‚àß (ùìï œà y).im = 0) :
    ‚àÉ B : ‚Ñù, ‚àÄ x : ‚Ñù, 0 < x ‚Üí ‚Äñ‚àë' n, f n / n * ùìï œà (1 / (2 * œÄ) * log (n / x))‚Äñ ‚â§ B :=



Theorem: MellinInversion_aux1
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux1 {f : ‚Ñù ‚Üí ‚ÑÇ} {s : ‚ÑÇ} (s_ne_zero : s ‚â† 0)
    (fDiff : DifferentiableOn ‚Ñù f (Ioi 0))
    (hfs : Tendsto (fun x ‚Ü¶ f x * x ^ s) (ùìù[>]0) (ùìù 0))
    (hfinf : Tendsto (fun x ‚Ü¶ f x * x ^ s) atTop (ùìù 0)) :
    ‚à´ x in Ioi 0, f x * x ^ s / x = - ‚à´ x in Ioi 0, (deriv f x) * x ^ s / s :=



Theorem: MellinInversion_aux4
File path: PrimeNumberTheoremAnd/MellinCalculus.lean
Theorem statement: lemma MellinInversion_aux4 {f : ‚Ñù ‚Üí ‚ÑÇ} (œÉ : ‚Ñù) (œÉ_ne_zero : œÉ ‚â† 0) (œÉ_ne_negOne : œÉ ‚â† -1)
    (fInt : IntegrableOn (fun x ‚Ü¶ f x * (x : ‚ÑÇ) ^ (œÉ : ‚ÑÇ)) (Ioi 0)) :
    VerticalIntegral (fun s ‚Ü¶ ‚à´ x in Ioi 0, f x * (x : ‚ÑÇ) ^ (s + 1) / (s * (s + 1))) œÉ =
      ‚à´ x in Ioi 0, VerticalIntegral (fun s ‚Ü¶ f x * (x : ‚ÑÇ) ^ (s + 1) / (s * (s + 1))) œÉ :=



Theorem: pi_alt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem pi_alt : ‚àÉ c : ‚Ñù ‚Üí ‚Ñù, c =o[atTop] (fun _ ‚Ü¶ (1:‚Ñù)) ‚àß
    ‚àÄ x : ‚Ñù, Nat.primeCounting ‚åäx‚åã‚Çä = (1 + c x) * x / log x :=



Theorem: vertical_integrable_Smooth1
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma vertical_integrable_Smooth1 {œà : ‚Ñù ‚Üí ‚Ñù} (diffŒ® : ContDiff ‚Ñù 1 œà) (œàpos : ‚àÄ (x : ‚Ñù), 0 ‚â§ œà x)
    (suppŒ® : support œà ‚äÜ Icc (1 / 2) 2) (mass_one : ‚à´ (x : ‚Ñù) in Ioi 0, œà x / x = 1)
    (Œµ : ‚Ñù) (Œµpos : 0 < Œµ) :
    MeasureTheory.Integrable
      (fun (y : ‚Ñù) ‚Ü¶ ‚à´ (t : ‚Ñù) in Ioi 0, (t : ‚ÑÇ) ^ (1 + y * I) * (Smooth1 œà Œµ t : ‚ÑÇ)) :=



Theorem: mu_pnt
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem mu_pnt : (fun x:‚Ñù ‚Ü¶ ‚àë n in range ‚åä x ‚åã‚Çä, Œº n) =o[atTop] (fun x ‚Ü¶ x) :=



Theorem: primorial_bounds_finprod
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem primorial_bounds_finprod :
    ‚àÉ E : ‚Ñù ‚Üí ‚Ñù, E =o[atTop] (fun x ‚Ü¶ x) ‚àß
    ‚àÄ x : ‚Ñù, ‚àè·∂† (p:‚Ñï) (_:p ‚â§ x) (_:Nat.Prime p), p = exp ( x + E x ) :=



Theorem: chebyshev_asymptotic_finsum
File path: PrimeNumberTheoremAnd/Consequences.lean
Theorem statement: theorem chebyshev_asymptotic_finsum :
    (fun x ‚Ü¶ ‚àë·∂† (p:‚Ñï) (_: p ‚â§ x) (_: Nat.Prime p), log p) ~[atTop] (fun x ‚Ü¶ x) :=



Theorem: SmoothedChebyshevClose
File path: PrimeNumberTheoremAnd/MediumPNT.lean
Theorem statement: lemma SmoothedChebyshevClose {œà : ‚Ñù ‚Üí ‚Ñù} (Œµ : ‚Ñù) (Œµ_pos: 0 < Œµ)
    (suppŒ® : Function.support œà ‚äÜ Icc (1 / 2) 2) (Œ®nonneg : ‚àÄ x > 0, 0 ‚â§ œà x)
    (mass_one : ‚à´ x in Ioi 0, œà x / x = 1) (X : ‚Ñù) :
    (fun X ‚Ü¶ ‚ÄñSmoothedChebyshev œà Œµ X - ChebyshevPsi X‚Äñ) =O[atTop]
      (fun X ‚Ü¶ Œµ * X * Real.log X) :=



Theorem: DerivUpperBnd_aux7
File path: PrimeNumberTheoremAnd/ZetaBounds.lean
Theorem statement: theorem DerivUpperBnd_aux7 {A œÉ t : ‚Ñù} (t_gt : 3 < |t|) (hœÉ : œÉ ‚àà Icc (1 - A / |t|.log) 2) :
    let N := ‚åä|t|‚åã‚Çä;
    let s := ‚ÜëœÉ + ‚Üët * I;
    0 < N ‚Üí ‚ÜëN ‚â§ |t| ‚Üí s ‚â† 1 ‚Üí 1 / 2 < œÉ ‚Üí
    ‚Äñs * ‚à´ (x : ‚Ñù) in Ioi (N : ‚Ñù), (‚Üë‚åäx‚åã + 1 / 2 - ‚Üëx) * (x : ‚ÑÇ) ^ (-s - 1) * -‚Üëx.log‚Äñ ‚â§
      2 * |t| * ‚ÜëN ^ (-œÉ) / œÉ * |t|.log :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/dwrensha/compfiles (commit: f99bf6f2928d47dd1a445b414b3a723c2665f091)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 5

Theorem: Imo2008P5.claim
File path: Compfiles/Imo2008P5.lean
Theorem statement: lemma claim (n k : ‚Ñï) (hn : 0 < n) (hnk : n ‚â§ k) (he : Even (k - n))
    (f : {b : Sequence n k // MSequence n k b }) :
    Set.ncard {g | œà n k g = f} = 2^(k - n) :=



Theorem: Imo2001P1.lemma1
File path: Compfiles/Imo2001P1.lean
Theorem statement: lemma lemma1
    (t : Affine.Triangle ‚Ñù (EuclideanSpace ‚Ñù (Fin 2)))
    : ‚à° t.circumcenter (t.points 2) (t.points 1) =
      Real.pi - ‚à° (t.points 1) (t.points 0) (t.points 2) :=



Theorem: Bulgaria1998P6.lemma_1'
File path: Compfiles/Bulgaria1998P6.lean
Theorem statement: lemma lemma_1'
    (a b c : ‚Ñï)
    (ha : 0 < a)
    (hb : 0 < b)
    (hc : 0 < c)
    (h : a^4 = b^4 + c^2) : False :=



Theorem: Imo2008P5.even_subsets_card
File path: Compfiles/Imo2008P5.lean
Theorem statement: lemma even_subsets_card {Œ± : Type} [Fintype Œ±] :
    Fintype.card {s : Finset Œ± // Even (Finset.card s) } = 2^(Fintype.card Œ± - 1) :=



Theorem: Imo2009P6.imo2009_p6_aux1
File path: Compfiles/Imo2009P6.lean
Theorem statement: theorem imo2009_p6_aux1 (n : ‚Ñï) (hn : 0 < n)
    (a : Fin n ‚Üí ‚Ñ§)
    (ainj : a.Injective)
    (apos : ‚àÄ i, 0 < a i)
    (asorted : ‚àÄ i j, i < j ‚Üí a i < a j)
    (M : Finset ‚Ñ§)
    (Mpos : ‚àÄ m ‚àà M, 0 < m)
    (Mcard : M.card ‚â§ n - 1)
    (hM : ‚àë i, a i ‚àâ M)
    : ‚àÉ p : Equiv.Perm (Fin n),
          ‚àÄ i : Fin n, ‚àë j ‚àà Finset.filter (¬∑ ‚â§ i) Finset.univ, a (p j) ‚àâ M :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/google-deepmind/debate (commit: 7fb39251b705797ee54e08c96177fabd29a5b5a3)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/avigad/mathematics_in_lean_source (commit: 5297e0fb051367c48c0a084411853a576389ecf5)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 9

Theorem: C03S06.exists_abs_le_of_convergesTo
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem exists_abs_le_of_convergesTo {s : ‚Ñï ‚Üí ‚Ñù} {a : ‚Ñù} (cs : ConvergesTo s a) :
    ‚àÉ N b, ‚àÄ n, N ‚â§ n ‚Üí |s n| < b :=



Theorem: C03S06.aux
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem aux {s t : ‚Ñï ‚Üí ‚Ñù} {a : ‚Ñù} (cs : ConvergesTo s a) (ct : ConvergesTo t 0) :
    ConvergesTo (fun n ‚Ü¶ s n * t n) 0 :=



Theorem: C03S05.MyAbs.lt_abs
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem lt_abs : x < |y| ‚Üî x < y ‚à® x < -y :=



Theorem: C03S06.convergesTo_mul_const
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_mul_const {s : ‚Ñï ‚Üí ‚Ñù} {a : ‚Ñù} (c : ‚Ñù) (cs : ConvergesTo s a) :
    ConvergesTo (fun n ‚Ü¶ c * s n) (c * a) :=



Theorem: C03S05.MyAbs.abs_lt
File path: MIL/C03_Logic/S05_Disjunction.lean
Theorem statement: theorem abs_lt : |x| < y ‚Üî -y < x ‚àß x < y :=



Theorem: C03S06.convergesTo_unique
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_unique {s : ‚Ñï ‚Üí ‚Ñù} {a b : ‚Ñù}
      (sa : ConvergesTo s a) (sb : ConvergesTo s b) :
    a = b :=



Theorem: cauchySeq_of_le_geometric_two'
File path: MIL/C09_Topology/S02_Metric_Spaces.lean
Theorem statement: theorem cauchySeq_of_le_geometric_two' {u : ‚Ñï ‚Üí X}
    (hu : ‚àÄ n : ‚Ñï, dist (u n) (u (n + 1)) ‚â§ (1 / 2) ^ n) : CauchySeq u :=



Theorem: Cantor
File path: MIL/C04_Sets_and_Functions/S02_Functions.lean
Theorem statement: theorem Cantor : ‚àÄ f : Œ± ‚Üí Set Œ±, ¬¨Surjective f :=



Theorem: C03S06.convergesTo_add
File path: MIL/C03_Logic/S06_Sequences_and_Convergence.lean
Theorem statement: theorem convergesTo_add {s t : ‚Ñï ‚Üí ‚Ñù} {a b : ‚Ñù}
      (cs : ConvergesTo s a) (ct : ConvergesTo t b) :
    ConvergesTo (fun n ‚Ü¶ s n + t n) (a + b) :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/digama0/lean4lean (commit: 05b1f4a68c5facea96a5ee51c6a56fef21276e0f)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 4

Theorem: Lean4Lean.NormalEq.trans
File path: Lean4Lean/Theory/Typing/ParallelReduction.lean
Theorem statement: theorem NormalEq.trans
    (H1 : NormalEq TY Œì e1 e2) (H2 : NormalEq TY Œì e2 e3) :
    NormalEq TY Œì e1 e3 :=



Theorem: Lean4Lean.VEnv.IsDefEq.induction1
File path: Lean4Lean/Theory/Typing/Stratified.lean
Theorem statement: theorem IsDefEq.induction1
    (defEq : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hasType : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hty : ‚àÄ {Œì e A}, HasType1 env U defEq Œì e A ‚Üí hasType Œì e A)
    (hdf : ‚àÄ {Œì e1 e2 A}, IsDefEq1 env U hasType defEq Œì e1 e2 A ‚Üí defEq Œì e1 e2 A)
    (H : env.IsDefEq U Œì e1 e2 A) :
    HasType1 env U defEq Œì e1 A ‚àß
    HasType1 env U defEq Œì e2 A ‚àß
    IsDefEq1 env U hasType defEq Œì e1 e2 A :=



Theorem: Lean4Lean.VEnv.IsDefEqU.weakN_iff
File path: Lean4Lean/Theory/Typing/UniqueTyping.lean
Theorem statement: theorem IsDefEqU.weakN_iff (W : Ctx.LiftN n k Œì Œì') :
    env.IsDefEqU U Œì' (e1.liftN n k) (e2.liftN n k) ‚Üî env.IsDefEqU U Œì e1 e2 :=



Theorem: Lean4Lean.VEnv.IsDefEq.inductionU1
File path: Lean4Lean/Theory/Typing/StratifiedUntyped.lean
Theorem statement: theorem IsDefEq.inductionU1
    (defEq : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hasType : List VExpr ‚Üí VExpr ‚Üí VExpr ‚Üí Prop)
    (hty : ‚àÄ {Œì e A}, HasTypeU1 env U defEq Œì e A ‚Üí hasType Œì e A)
    (hdf : ‚àÄ {Œì e1 e2 A1 A2},
      HasTypeU1 env U defEq Œì e1 A1 ‚Üí HasTypeU1 env U defEq Œì e2 A2 ‚Üí
      IsDefEqU1 env U hasType Œì e1 e2 ‚Üí defEq Œì e1 e2)
    (H : env.IsDefEq U Œì e1 e2 A) :
    HasTypeU1 env U defEq Œì e1 A ‚àß
    HasTypeU1 env U defEq Œì e2 A ‚àß
    IsDefEqU1 env U hasType Œì e1 e2 :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/eric-wieser/lean-matrix-cookbook (commit: f15a149d321ac99ff9b9c024b58e7882f564669f)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 7

Theorem: MatrixCookbook.eq_446
File path: MatrixCookbook/9SpecialMatrices.lean
Theorem statement: theorem eq_446 (A : Matrix l m R) (B : Matrix n p R) (k i j l) :
    A k i * B j l = (A * stdBasisMatrix i j (1 : R) * B) k l :=



Theorem: MatrixCookbook.eq_257
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_257 (h : IsUnit E)  :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      (1 - t ‚Ä¢ I : ‚ÑÇ) ‚Ä¢ ((E + F * E‚Åª¬π * F)‚Åª¬π.map (‚Üë) * (1 - (F * E‚Åª¬π).map (¬∑ ‚Ä¢ I))) :=



Theorem: MatrixCookbook.eq_259
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_259 (h : IsUnit E) :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      ((E + F * E‚Åª¬π * F)‚Åª¬π * (1 - t ‚Ä¢ (F * E‚Åª¬π))).map (‚Üë) -
       ((E + F * E‚Åª¬π * F)‚Åª¬π * (t ‚Ä¢ 1 + (F * E‚Åª¬π))).map (¬∑ ‚Ä¢ I) :=



Theorem: MatrixCookbook.eq_258
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_258 (h : IsUnit E) :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      (E + F * E‚Åª¬π * F)‚Åª¬π.map (‚Üë) *
        ((1 - t ‚Ä¢ (F * E‚Åª¬π).map (‚Üë)) - (t ‚Ä¢ 1 + (F * E‚Åª¬π)).map (¬∑ ‚Ä¢ I)) :=



Theorem: MatrixCookbook.eq_256
File path: MatrixCookbook/4ComplexMatrices.lean
Theorem statement: theorem eq_256 (h : IsUnit E)  :
    (A.map (‚Üë) + B.map (¬∑ ‚Ä¢ I))‚Åª¬π =
      (1 - t ‚Ä¢ I : ‚ÑÇ) ‚Ä¢ ((E + F * E‚Åª¬π * F)‚Åª¬π.map (‚Üë) - ((E + F * E‚Åª¬π * F)‚Åª¬π * F * E).map (¬∑ ‚Ä¢ I))‚Åª¬π :=



Theorem: MatrixCookbook.eq_533
File path: MatrixCookbook/10FunctionsAndOperators.lean
Theorem statement: lemma eq_533 (A : Matrix m n ‚Ñù) : ‚ÄñA‚Äñ = sSup { ‚ÄñA.mulVec x‚Äñ | (x) (hx : ‚Äñx‚Äñ = 1)} :=



Theorem: MatrixCookbook.eq_160
File path: MatrixCookbook/3Inverses.lean
Theorem statement: theorem eq_160 (b c : n ‚Üí ‚ÑÇ) :
    (A + col b * row c)‚Åª¬π = A‚Åª¬π - (1 + c ‚¨ù·µ• A‚Åª¬π.mulVec b)‚Åª¬π ‚Ä¢ A‚Åª¬π * (col b * row c) * A‚Åª¬π :=



================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/yuma-mizuno/lean-math-workshop (commit: 5acd4b933d47fd6c1032798a6046c1baf261445d)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/loganrjmurphy/LeanEuclid (commit: f1912c3090eb82820575758efc31e40b9db86bb8)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/FormalizedFormalLogic/Foundation (commit: d5fe5d057a90a0703a745cdc318a1b6621490c21)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/leanprover-community/lean-auto (commit: 0f5f39a0336e36ae4ba8ab45b27865ebd9f8f025)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/nomeata/loogle (commit: 387ab85308ce817bb95cc99730025eb44cb8a9ab)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/leanprover-community/con-nf (commit: 00bdc85ba7d486a9e544a0806a1018dd06fa3856)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/siddhartha-gadgil/Saturn (commit: 3811a9dd46cdfd5fa0c0c1896720c28d2ec4a42a)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/leanprover-community/flt-regular (commit: 359ab563c7ba5d775c1878ac7b3d0c4095b37ec4)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/rami3l/plfl (commit: 1a25fc310d8fb0c6e21ab9e385cc7dac0c31f77a)
================================================================================

Unproved sorry theorems only in first database: 0

Unproved sorry theorems only in second database: 0

Common Unproved sorry theorems: 0

================================================================================
Comparing Unproved sorry theorems for repository: https://github.com/yangky11/miniF2F-lean4 (commit: 9e445f5435407f014b88b44a98436d50dd7abd00)
================================================================================

Unproved sorry theorems only in first database: 15

Theorem: aime_1989_p8
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1989_p8
  (a b c d e f g : ‚Ñù)
  (h‚ÇÄ : a + 4 * b + 9 * c + 16 * d + 25 * e + 36 * f + 49 * g = 1)
  (h‚ÇÅ : 4 * a + 9 * b + 16 * c + 25 * d + 36 * e + 49 * f + 64 * g = 12)
  (h‚ÇÇ : 9 * a + 16 * b + 25 * c + 36 * d + 49 * e + 64 * f + 81 * g = 123) :
  16 * a + 25 * b + 36 * c + 49 * d + 64 * e + 81 * f + 100 * g = 334 :=


Theorem: mathd_algebra_141
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_141
  (a b : ‚Ñù)
  (h‚ÇÅ : (a * b)=180)
  (h‚ÇÇ : 2 * (a + b)=54) :
  (a^2 + b^2) = 369 :=


Theorem: induction_1pxpownlt1pnx
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_1pxpownlt1pnx
  (x : ‚Ñù)
  (n : ‚Ñï)
  (h‚ÇÄ : -1 < x)
  (h‚ÇÅ : 0 < n) :
  (1 + ‚Üën*x) ‚â§ (1 + x)^(n:‚Ñï) :=


Theorem: mathd_algebra_329
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_329
  (x y : ‚Ñù)
  (h‚ÇÄ : 3 * y = x)
  (h‚ÇÅ : 2 * x + 5 * y = 11) :
  x + y = 4 :=


Theorem: mathd_algebra_547
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_547 (x y : ‚Ñù) (h‚ÇÄ : x = 5) (h‚ÇÅ : y = 2) : Real.sqrt (x ^ 3 - 2 ^ y) = 11 :=


Theorem: mathd_algebra_441
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_441
  (x : ‚Ñù)
  (h‚ÇÄ : x ‚â† 0) :
  12 / (x * x) * (x^4 / (14 * x)) * (35 / (3 * x)) = 10 :=


Theorem: mathd_numbertheory_254
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_254 :
  (239 + 174 + 83) % 10 = 6 :=


Theorem: amc12a_2009_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2009_p5 (x : ‚Ñù) (h‚ÇÄ : x ^ 3 - (x + 1) * (x - 1) * x = 5) : x ^ 3 = 125 :=


Theorem: mathd_numbertheory_110
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_110 (a b : ‚Ñï) (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß b ‚â§ a) (h‚ÇÅ : (a + b) % 10 = 2)
  (h‚ÇÇ : (2 * a + b) % 10 = 1) : (a - b) % 10 = 6 :=


Theorem: mathd_algebra_143
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_143
  (f g : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = x + 1)
  (h‚ÇÅ : ‚àÄ x, g x = x^2 + 3) :
  f (g 2) = 8 :=


Theorem: mathd_algebra_304
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_304 :
  91^2 = 8281 :=


Theorem: mathd_numbertheory_342
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_342 :
  54 % 6 = 0 :=


Theorem: mathd_algebra_484
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_484 :
  Real.log 27 / Real.log 3 = 3 :=


Theorem: mathd_numbertheory_328
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_328 :
  (5^999999) % 7 = 6 :=


Theorem: mathd_numbertheory_447
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_447 :
  ‚àë k in Finset.filter (Œª x => 3‚à£x) (Finset.Icc 1 49), (k % 10) = 78 :=


Unproved sorry theorems only in second database: 19

Theorem: mathd_numbertheory_12
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_12 :
  Finset.card (Finset.filter (Œª x => 20‚à£x) (Finset.Icc 15 85)) = 4 :=


Theorem: mathd_algebra_148
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_148
  (c : ‚Ñù)
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = c * x^3 - 9 * x + 3)
  (h‚ÇÅ : f 2 = 9) :
  c = 3 :=


Theorem: mathd_numbertheory_233
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_233
  (b :  ZMod (11^2))
  (h‚ÇÄ : b = 24‚Åª¬π) :
  b = 116 :=


Theorem: mathd_algebra_513
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_513
  (a b : ‚Ñù)
  (h‚ÇÄ : 3 * a + 2 * b = 5)
  (h‚ÇÅ : a + b = 2) :
  a = 1 ‚àß b = 1 :=


Theorem: mathd_algebra_234
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_234 (d : ‚Ñù) (h‚ÇÄ : 27 / 125 * d = 9 / 25) : 3 / 5 * d ^ 3 = 25 / 9 :=


Theorem: mathd_algebra_160
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_160
  (n x : ‚Ñù)
  (h‚ÇÄ : n + x = 97)
  (h‚ÇÅ : n + 5 * x = 265) :
  n + 2 * x = 139 :=


Theorem: mathd_algebra_270
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_270
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, x ‚â† -2 -> f x = 1 / (x + 2)) :
  f (f 1) = 3/7 :=


Theorem: mathd_algebra_209
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_209
  (œÉ : Equiv ‚Ñù ‚Ñù)
  (h‚ÇÄ : œÉ.2 2 = 10)
  (h‚ÇÅ : œÉ.2 10 = 1)
  (h‚ÇÇ : œÉ.2 1 = 2) :
  œÉ.1 (œÉ.1 10) = 1 :=


Theorem: mathd_numbertheory_293
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_293
  (n : ‚Ñï)
  (h‚ÇÄ : n ‚â§ 9)
  (h‚ÇÅ : 11‚à£20 * 100 + 10 * n + 7) :
  n = 5 :=


Theorem: mathd_algebra_432
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_432
  (x : ‚Ñù) :
  (x + 3) * (2 * x - 6) = 2 * x^2 - 18 :=


Theorem: amc12b_2020_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2020_p2 :
  ((100 ^ 2 - 7 ^ 2):‚Ñù) / (70 ^ 2 - 11 ^ 2) * ((70 - 11) * (70 + 11) / ((100 - 7) * (100 + 7))) = 1 :=


Theorem: mathd_algebra_24
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_24
  (x : ‚Ñù)
  (h‚ÇÄ : x / 50 = 40) :
  x = 2000 :=


Theorem: induction_12dvd4expnp1p20
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_12dvd4expnp1p20
  (n : ‚Ñï) :
  12 ‚à£ 4^(n+1) + 20 :=


Theorem: mathd_numbertheory_35
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_35 (S : Finset ‚Ñï) (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚à£ Nat.sqrt 196) :
    (‚àë k in S, k) = 24 :=


Theorem: mathd_algebra_123
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_123 (a b : ‚Ñï) (h‚ÇÄ : 0 < a ‚àß 0 < b) (h‚ÇÅ : a + b = 20) (h‚ÇÇ : a = 3 * b) :
  a - b = 10 :=


Theorem: amc12a_2002_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2002_p6
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n) :
  ‚àÉ m, (m > n ‚àß ‚àÉ p, m * p ‚â§ m + p) :=


Theorem: mathd_numbertheory_728
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_728 :
  (29^13 - 5^13) % 7 = 3 :=


Theorem: mathd_numbertheory_284
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_284 (a b : ‚Ñï) (h‚ÇÄ : 1 ‚â§ a ‚àß a ‚â§ 9 ‚àß b ‚â§ 9)
  (h‚ÇÅ : 10 * a + b = 2 * (a + b)) : 10 * a + b = 18 :=


Theorem: mathd_algebra_346
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_346
  (f g : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = 2 * x - 3)
  (h‚ÇÅ : ‚àÄ x, g x = x + 1) :
  g (f 5 - 1) = 7 :=


Common Unproved sorry theorems: 292

Theorem: amc12b_2021_p21
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2021_p21 (S : Finset ‚Ñù)
  (h‚ÇÄ : ‚àÄ x : ‚Ñù, x ‚àà S ‚Üî 0 < x ‚àß x ^ (2 : ‚Ñù) ^ Real.sqrt 2 = Real.sqrt 2 ^ (2 : ‚Ñù) ^ x) :
  (‚Üë2 ‚â§ ‚àë k in S, k) ‚àß (‚àë k in S, k) < 6 :=



Theorem: mathd_numbertheory_780
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_780 (m x : ‚Ñ§) (h‚ÇÄ : 0 ‚â§ x) (h‚ÇÅ : 10 ‚â§ m ‚àß m ‚â§ 99) (h‚ÇÇ : 6 * x % m = 1)
  (h‚ÇÉ : (x - 6 ^ 2) % m = 0) : m = 43 :=



Theorem: mathd_algebra_73
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_73 (p q r x : ‚ÑÇ) (h‚ÇÄ : (x - p) * (x - q) = (r - p) * (r - q)) (h‚ÇÅ : x ‚â† r) :
  x = p + q - r :=



Theorem: amc12b_2002_p11
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2002_p11 (a b : ‚Ñï) (h‚ÇÄ : Nat.Prime a) (h‚ÇÅ : Nat.Prime b) (h‚ÇÇ : Nat.Prime (a + b))
  (h‚ÇÉ : Nat.Prime (a - b)) : Nat.Prime (a + b + (a - b + (a + b))) :=



Theorem: imo_2019_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_2019_p1
  (f : ‚Ñ§ ‚Üí ‚Ñ§) :
  ((‚àÄ a b, f (2 * a) + (2 * f b) = f (f (a + b))) ‚Üî (‚àÄ z, f z = 0 \/ ‚àÉ c, ‚àÄ z, f z = 2 * z + c)) :=



Theorem: algebra_absapbon1pabsapbleqsumabsaon1pabsa
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_absapbon1pabsapbleqsumabsaon1pabsa
  (a b : ‚Ñù) :
  abs (a + b) / (1 + abs (a + b)) ‚â§ abs a / (1 + abs a) + abs b / (1 + abs b) :=



Theorem: mathd_algebra_276
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_276
  (a b : ‚Ñ§)
  (h‚ÇÄ : ‚àÄ x : ‚Ñù, 10 * x^2 - x - 24 = (a * x - 8) * (b * x + 3)) :
  a * b + b = 12 :=



Theorem: imo_1990_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1990_p3 (n : ‚Ñï) (h‚ÇÄ : 2 ‚â§ n) (h‚ÇÅ : n ^ 2 ‚à£ 2 ^ n + 1) : n = 3 :=



Theorem: mathd_numbertheory_530
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_530 (n k : ‚Ñï) (h‚ÇÄ : 0 < n ‚àß 0 < k) (h‚ÇÄ : (n : ‚Ñù) / k < 6)
  (h‚ÇÅ : (5 : ‚Ñù) < n / k) : 22 ‚â§ Nat.lcm n k / Nat.gcd n k :=



Theorem: induction_divisibility_9div10tonm1
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_divisibility_9div10tonm1 (n : ‚Ñï) (h‚ÇÄ : 0 < n) : 9 ‚à£ 10 ^ n - 1 :=



Theorem: amc12a_2003_p25
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2003_p25 (a b : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : 0 < b)
  (h‚ÇÅ : ‚àÄ x, f x = Real.sqrt (a * x ^ 2 + b * x)) (h‚ÇÇ : { x | 0 ‚â§ f x } = f '' { x | 0 ‚â§ f x }) :
  a = 0 ‚à® a = -4 :=



Theorem: mathd_numbertheory_353
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_353
  (s : ‚Ñï)
  (h‚ÇÄ : s = ‚àë k in Finset.Icc 2010 4018, k) :
  s % 2009 = 0 :=



Theorem: mathd_numbertheory_451
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_451
  (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ (n : ‚Ñï), n ‚àà S ‚Üî 2010 ‚â§ n ‚àß n ‚â§ 2019 ‚àß ‚àÉ m, ((Nat.divisors m).card = 4 ‚àß ‚àë p in (Nat.divisors m), p = n)) :
  ‚àë k in S, k = 2016 :=



Theorem: imo_1962_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1962_p2
  (x : ‚Ñù)
  (h‚ÇÄ : 0 ‚â§ 3 - x)
  (h‚ÇÅ : 0 ‚â§ x + 1)
  (h‚ÇÇ : 1 / 2 < Real.sqrt (3 - x) - Real.sqrt (x + 1)) :
  -1 ‚â§ x ‚àß x < 1 - Real.sqrt 31 / 8 :=



Theorem: induction_sum_1oktkp1
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_sum_1oktkp1 (n : ‚Ñï) :
  (‚àë k in Finset.range n, (1 : ‚Ñù) / ((k + 1) * (k + 2))) = n / (n + 1) :=



Theorem: numbertheory_prmdvsneqnsqmodpeq0
File path: MiniF2F/Valid.lean
Theorem statement: theorem numbertheory_prmdvsneqnsqmodpeq0 (n : ‚Ñ§) (p : ‚Ñï) (h‚ÇÄ : Nat.Prime p) :
  ‚Üëp ‚à£ n ‚Üî n ^ 2 % p = 0 :=



Theorem: imo_1965_p1
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1965_p1 (x : ‚Ñù) (h‚ÇÄ : 0 ‚â§ x) (h‚ÇÅ : x ‚â§ 2 * œÄ)
  (h‚ÇÇ : 2 * Real.cos x ‚â§ abs (Real.sqrt (1 + Real.sin (2 * x)) - Real.sqrt (1 - Real.sin (2 * x))))
  (h‚ÇÉ : abs (Real.sqrt (1 + Real.sin (2 * x)) - Real.sqrt (1 - Real.sin (2 * x))) ‚â§ Real.sqrt 2) :
  œÄ / 4 ‚â§ x ‚àß x ‚â§ 7 * œÄ / 4 :=



Theorem: imo_1984_p2
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1984_p2 (a b : ‚Ñ§) (h‚ÇÄ : 0 < a ‚àß 0 < b) (h‚ÇÅ : ¬¨7 ‚à£ a) (h‚ÇÇ : ¬¨7 ‚à£ b) (h‚ÇÉ : ¬¨7 ‚à£ a + b)
  (h‚ÇÑ : 7 ^ 7 ‚à£ (a + b) ^ 7 - a ^ 7 - b ^ 7) : 19 ‚â§ a + b :=



Theorem: algebra_binomnegdiscrineq_10alt28asqp1
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_binomnegdiscrineq_10alt28asqp1 (a : ‚Ñù) : 10 * a ‚â§ 28 * a ^ 2 + 1 :=



Theorem: imo_1964_p1_2
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1964_p1_2 (n : ‚Ñï) : ¬¨7 ‚à£ 2 ^ n + 1 :=



Theorem: mathd_numbertheory_629
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_629 : IsLeast { t : ‚Ñï | 0 < t ‚àß Nat.lcm 12 t ^ 3 = (12 * t) ^ 2 } 18 :=



Theorem: amc12b_2021_p18
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2021_p18
  (z : ‚ÑÇ)
  (h‚ÇÄ : 12 * Complex.normSq z = 2 * Complex.normSq (z + 2) + Complex.normSq (z^2 + 1) + 31) :
  z + 6 / z = -2 :=



Theorem: mathd_algebra_31
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_31 (x : NNReal) (u : ‚Ñï ‚Üí NNReal) (h‚ÇÄ : ‚àÄ n, u (n + 1) = NNReal.sqrt (x + u n))
  (h‚ÇÅ : Filter.Tendsto u Filter.atTop (ùìù 9)) : 9 = NNReal.sqrt (x + 9) :=



Theorem: algebra_amgm_faxinrrp2msqrt2geq2mxm1div2x
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_amgm_faxinrrp2msqrt2geq2mxm1div2x :
  ‚àÄ x > 0, 2 - Real.sqrt 2 ‚â• 2 - x - 1 / (2 * x) :=



Theorem: mathd_algebra_267
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_267 (x : ‚Ñù) (h‚ÇÄ : x ‚â† 1) (h‚ÇÅ : x ‚â† -2)
  (h‚ÇÇ : (x + 1) / (x - 1) = (x - 2) / (x + 2)) : x = 0 :=



Theorem: mathd_numbertheory_43
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_43 : IsGreatest { n : ‚Ñï | 15 ^ n ‚à£ 942! } 233 :=



Theorem: imo_1984_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1984_p6
  (a b c d k m : ‚Ñï)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c ‚àß 0 < d)
  (h‚ÇÅ : Odd a ‚àß Odd b ‚àß Odd c ‚àß Odd d)
  (h‚ÇÇ : a < b ‚àß b < c ‚àß c < d)
  (h‚ÇÉ : a * d = b * c)
  (h‚ÇÑ : a + d = 2^k)
  (h‚ÇÖ : b + c = 2^m) :
  a = 1 :=



Theorem: mathd_numbertheory_430
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_430
  (a b c : ‚Ñï)
  (h‚ÇÄ : 1 ‚â§ a ‚àß a ‚â§ 9)
  (h‚ÇÅ : 1 ‚â§ b ‚àß b ‚â§ 9)
  (h‚ÇÇ : 1 ‚â§ c ‚àß c ‚â§ 9)
  (h‚ÇÉ : a ‚â† b)
  (h‚ÇÑ : a ‚â† c)
  (h‚ÇÖ : b ‚â† c)
  (h‚ÇÜ : a + b = c)
  (h‚Çá : 10 * a + a - b = 2 * c)
  (h‚Çà : c * b = 10 * a + a + a) :
  a + b + c = 8 :=



Theorem: mathd_algebra_114
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_114
  (a : ‚Ñù)
  (h‚ÇÄ : a = 8) :
  (16 * (a^2)^(1 / 3))^(1 / 3) = 4 :=



Theorem: imo_1963_p5
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1963_p5 :
  Real.cos (œÄ / 7) - Real.cos (2 * œÄ / 7) + Real.cos (3 * œÄ / 7) = 1 / 2 :=



Theorem: mathd_algebra_392
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_392
  (n : ‚Ñï)
  (h‚ÇÄ : Even n)
  (h‚ÇÅ : ((n:‚Ñ§) - 2)^2 + (n:‚Ñ§)^2 + ((n:‚Ñ§) + 2)^2 = 12296) :
  ((n - 2) * n * (n + 2)) / 8 = 32736 :=



Theorem: imo_1981_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1981_p6
  (f : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : ‚àÄ y, f 0 y = y + 1)
  (h‚ÇÅ : ‚àÄ x, f (x + 1) 0 = f x 1)
  (h‚ÇÇ : ‚àÄ x y, f (x + 1) (y + 1) = f x (f (x + 1) y)) :
  ‚àÄ y, f 4 (y + 1) = 2^(f 4 y + 3) - 3 :=



Theorem: algebra_xmysqpymzsqpzmxsqeqxyz_xpypzp6dvdx3y3z3
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_xmysqpymzsqpzmxsqeqxyz_xpypzp6dvdx3y3z3 (x y z : ‚Ñ§)
  (h‚ÇÄ : (x - y) ^ 2 + (y - z) ^ 2 + (z - x) ^ 2 = x * y * z) :
  x + y + z + 6 ‚à£ x ^ 3 + y ^ 3 + z ^ 3 :=



Theorem: mathd_numbertheory_32
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_32 (S : Finset ‚Ñï) (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚àà S ‚Üî n ‚à£ 36) : (‚àë k in S, k) = 91 :=



Theorem: amc12a_2009_p15
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2009_p15 (n : ‚Ñï) (h‚ÇÄ : 0 < n)
  (h‚ÇÅ : (‚àë k in Finset.Icc 1 n, ‚Üëk * Complex.I ^ k) = 48 + 49 * Complex.I) : n = 97 :=



Theorem: aime_1983_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1983_p2
  (x p : ‚Ñù)
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : 0 < p ‚àß p < 15)
  (h‚ÇÅ : p ‚â§ x ‚àß x ‚â§ 15)
  (h‚ÇÇ : f x = abs (x - p) + abs (x - 15) + abs (x - p - 15)) :
  15 ‚â§ f x :=



Theorem: mathd_algebra_313
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_313
  (v i z : ‚ÑÇ)
  (h‚ÇÄ : v = i * z)
  (h‚ÇÅ : v = 1 + Complex.I)
  (h‚ÇÇ : z = 2 - Complex.I) :
  i = 1/5 + 3/5 * Complex.I :=



Theorem: aime_1984_p15
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1984_p15 (x y z w : ‚Ñù)
    (h‚ÇÄ :
      x ^ 2 / (2 ^ 2 - 1) + y ^ 2 / (2 ^ 2 - 3 ^ 2) + z ^ 2 / (2 ^ 2 - 5 ^ 2) +
          w ^ 2 / (2 ^ 2 - 7 ^ 2) =
        1)
    (h‚ÇÅ :
      x ^ 2 / (4 ^ 2 - 1) + y ^ 2 / (4 ^ 2 - 3 ^ 2) + z ^ 2 / (4 ^ 2 - 5 ^ 2) +
          w ^ 2 / (4 ^ 2 - 7 ^ 2) =
        1)
    (h‚ÇÇ :
      x ^ 2 / (6 ^ 2 - 1) + y ^ 2 / (6 ^ 2 - 3 ^ 2) + z ^ 2 / (6 ^ 2 - 5 ^ 2) +
          w ^ 2 / (6 ^ 2 - 7 ^ 2) =
        1)
    (h‚ÇÉ :
      x ^ 2 / (8 ^ 2 - 1) + y ^ 2 / (8 ^ 2 - 3 ^ 2) + z ^ 2 / (8 ^ 2 - 5 ^ 2) +
          w ^ 2 / (8 ^ 2 - 7 ^ 2) =
        1) :
    x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 = 36 :=



Theorem: mathd_algebra_28
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_28 (c : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x, f x = 2 * x ^ 2 + 5 * x + c)
  (h‚ÇÅ : ‚àÉ x, f x ‚â§ 0) : c ‚â§ 25 / 8 :=



Theorem: aime_1994_p4
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1994_p4 (n : ‚Ñï) (h‚ÇÄ : 0 < n)
  (h‚ÇÄ : (‚àë k in Finset.Icc 1 n, Int.floor (Real.logb 2 k)) = 1994) : n = 312 :=



Theorem: mathd_algebra_362
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_362
  (a b : ‚Ñù)
  (h‚ÇÄ : a^2 * b^3 = 32 / 27)
  (h‚ÇÅ : a / b^3 = 27 / 4) :
  a + b = 8 / 3 :=



Theorem: mathd_algebra_184
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_184
  (a b : NNReal)
  (h‚ÇÄ : 0 < a ‚àß 0 < b)
  (h‚ÇÅ : (a^2) = 6*b)
  (h‚ÇÇ : (a^2) = 54/b) :
  a = 3 * NNReal.sqrt 2 :=



Theorem: imo_1966_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1966_p5 (x a : ‚Ñï ‚Üí ‚Ñù) (h‚ÇÄ : a 1 ‚â† a 2) (h‚ÇÅ : a 1 ‚â† a 3) (h‚ÇÇ : a 1 ‚â† a 4)
  (h‚ÇÉ : a 2 ‚â† a 3) (h‚ÇÑ : a 2 ‚â† a 4) (h‚ÇÖ : a 3 ‚â† a 4) (h‚ÇÜ : a 1 > a 2) (h‚Çá : a 2 > a 3)
  (h‚Çà : a 3 > a 4)
  (h‚Çâ : abs (a 1 - a 2) * x 2 + abs (a 1 - a 3) * x 3 + abs (a 1 - a 4) * x 4 = 1)
  (h‚ÇÅ‚ÇÄ : abs (a 2 - a 1) * x 1 + abs (a 2 - a 3) * x 3 + abs (a 2 - a 4) * x 4 = 1)
  (h‚ÇÅ‚ÇÅ : abs (a 3 - a 1) * x 1 + abs (a 3 - a 2) * x 2 + abs (a 3 - a 4) * x 4 = 1)
  (h‚ÇÅ‚ÇÇ : abs (a 4 - a 1) * x 1 + abs (a 4 - a 2) * x 2 + abs (a 4 - a 3) * x 3 = 1) :
  x 2 = 0 ‚àß x 3 = 0 ‚àß x 1 = 1 / abs (a 1 - a 4) ‚àß x 4 = 1 / abs (a 1 - a 4) :=



Theorem: algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_2varlineareq_xpeeq7_2xpeeq3_eeq11_xeqn4 (x e : ‚ÑÇ) (h‚ÇÄ : x + e = 7)
  (h‚ÇÅ : 2 * x + e = 3) : e = 11 ‚àß x = -4 :=



Theorem: mathd_algebra_410
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_410 (x y : ‚Ñù) (h‚ÇÄ : y = x ^ 2 - 6 * x + 13) : 4 ‚â§ y :=



Theorem: mathd_algebra_196
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_196
  (S : Finset ‚Ñù)
  (h‚ÇÄ : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üî abs (2 - x) = 3) :
  ‚àë k in S, k = 4 :=



Theorem: imo_1993_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1993_p5 : ‚àÉ f : ‚Ñï ‚Üí ‚Ñï, f 1 = 2 ‚àß ‚àÄ n, f (f n) = f n + n ‚àß ‚àÄ n, f n < f (n + 1) :=



Theorem: imo_1982_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1982_p1
  (f : ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : ‚àÄ m n, (0 < m ‚àß 0 < n) ‚Üí f (m + n) - f m - f n = 0 ‚à® f (m + n) - f m - f n = 1)
  (h‚ÇÅ : f 2 = 0)
  (h‚ÇÇ : 0 < f 3)
  (h‚ÇÉ : f 9999 = 3333) :
  f 1982 = 660 :=



Theorem: imo_1962_p4
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1962_p4 (S : Set ‚Ñù)
    (h‚ÇÄ : S = { x : ‚Ñù | Real.cos x ^ 2 + Real.cos (2 * x) ^ 2 + Real.cos (3 * x) ^ 2 = 1 }) :
    S =
      { x : ‚Ñù |
        ‚àÉ m : ‚Ñ§,
          x = œÄ / 2 + m * œÄ ‚à®
            x = œÄ / 4 + m * œÄ / 2 ‚à® x = œÄ / 6 + m * œÄ / 6 ‚à® x = 5 * œÄ / 6 + m * œÄ / 6 } :=



Theorem: aime_1984_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1984_p1
  (u : ‚Ñï ‚Üí ‚Ñö)
  (h‚ÇÄ : ‚àÄ n, u (n + 1) = u n + 1)
  (h‚ÇÅ : ‚àë k in Finset.range 98, u k.succ = 137) :
  ‚àë k in Finset.range 49, u (2 * k.succ) = 93 :=



Theorem: numbertheory_notEquiv2i2jasqbsqdiv8
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_notEquiv2i2jasqbsqdiv8 :
  ¬¨ (‚àÄ a b : ‚Ñ§, (‚àÉ i j, a = 2*i ‚àß b=2*j) ‚Üî (‚àÉ k, a^2 + b^2 = 8*k)) :=



Theorem: algebra_sqineq_4bap1lt4bsqpap1sq
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_sqineq_4bap1lt4bsqpap1sq (a b : ‚Ñù) : 4 * b * (a + 1) ‚â§ 4 * b ^ 2 + (a + 1) ^ 2 :=



Theorem: amc12_2000_p20
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12_2000_p20
  (x y z : ‚Ñù)
  (h‚ÇÄ : 0 < x ‚àß 0 < y ‚àß 0 < z)
  (h‚ÇÅ : x + 1/y = 4)
  (h‚ÇÇ : y + 1/z = 1)
  (h‚ÇÉ : z + 1/x = 7/3) :
  x*y*z = 1 :=



Theorem: mathd_numbertheory_495
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_495
  (a b : ‚Ñï)
  (h‚ÇÄ : 0 < a ‚àß 0 < b)
  (h‚ÇÅ : a % 10 = 2)
  (h‚ÇÇ : b % 10 = 4)
  (h‚ÇÉ : Nat.gcd a b = 6) :
  108 ‚â§ Nat.lcm a b :=



Theorem: mathd_numbertheory_552
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_552
  (f g h : ‚Ñï+ ‚Üí ‚Ñï)
  (h‚ÇÄ : ‚àÄ x, f x = 12 * x + 7)
  (h‚ÇÅ : ‚àÄ x, g x = 5 * x + 2)
  (h‚ÇÇ : ‚àÄ x, h x = Nat.gcd (f x) (g x))
  (h‚ÇÉ : Fintype (Set.range h)) :
  ‚àë k in (Set.range h).toFinset, k = 12 :=



Theorem: algebra_sqineq_36azm9asqle36zsq
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_sqineq_36azm9asqle36zsq (z a : ‚Ñù) : 36 * (a * z) - 9 * a ^ 2 ‚â§ 36 * z ^ 2 :=



Theorem: numbertheory_aneqprodakp4_anmsqrtanp1eq2
File path: MiniF2F/Valid.lean
Theorem statement: theorem numbertheory_aneqprodakp4_anmsqrtanp1eq2 (a : ‚Ñï ‚Üí ‚Ñù) (h‚ÇÄ : a 0 = 1)
  (h‚ÇÅ : ‚àÄ n, a (n + 1) = (‚àè k in Finset.range (n + 1), a k) + 4) :
  ‚àÄ n ‚â• 1, a n - Real.sqrt (a (n + 1)) = 2 :=



Theorem: mathd_algebra_756
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_756
  (a b : ‚Ñù)
  (h‚ÇÄ : (2:‚Ñù)^a = 32)
  (h‚ÇÅ : a^b = 125) :
  b^a = 243 :=



Theorem: amc12a_2015_p10
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2015_p10 (x y : ‚Ñ§) (h‚ÇÄ : 0 < y) (h‚ÇÅ : y < x) (h‚ÇÇ : x + y + x * y = 80) : x = 26 :=



Theorem: amc12b_2002_p4
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2002_p4
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n)
  (h‚ÇÄ : ((1 / 2 + 1 / 3 + 1 / 7 + 1 / n) : ‚Ñö).den = 1) :
  n = 42 :=



Theorem: mathd_numbertheory_405
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_405 (a b c : ‚Ñï) (t : ‚Ñï ‚Üí ‚Ñï) (h‚ÇÄ : t 0 = 0) (h‚ÇÅ : t 1 = 1)
  (h‚ÇÇ : ‚àÄ n > 1, t n = t (n - 2) + t (n - 1)) (h‚ÇÉ : a ‚â° 5 [MOD 16]) (h‚ÇÑ : b ‚â° 10 [MOD 16])
  (h‚ÇÖ : c ‚â° 15 [MOD 16]) : (t a + t b + t c) % 7 = 5 :=



Theorem: mathd_algebra_215
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_215
  (S : Finset ‚Ñù)
  (h‚ÇÄ : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üî (x + 3)^2 = 121) :
  ‚àë k in S, k = -6 :=



Theorem: mathd_numbertheory_412
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_412 (x y : ‚Ñ§) (h‚ÇÄ : x % 19 = 4) (h‚ÇÅ : y % 19 = 7) :
  (x + 1) ^ 2 * (y + 5) ^ 3 % 19 = 13 :=



Theorem: amc12a_2009_p9
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2009_p9 (a b c : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x, f (x + 3) = 3 * x ^ 2 + 7 * x + 4)
  (h‚ÇÅ : ‚àÄ x, f x = a * x ^ 2 + b * x + c) : a + b + c = 2 :=



Theorem: imo_2001_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_2001_p6
  (a b c d : ‚Ñï)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c ‚àß 0 < d)
  (h‚ÇÅ : d < c)
  (h‚ÇÇ : c < b)
  (h‚ÇÉ : b < a)
  (h‚ÇÑ : a * c + b * d = (b + d + a - c) * (b + d + c - a)) :
  ¬¨ Nat.Prime (a * b + c * d) :=



Theorem: algebra_bleqa_apbon2msqrtableqambsqon8b
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_bleqa_apbon2msqrtableqambsqon8b
  (a b : ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b)
  (h‚ÇÅ : b ‚â§ a) :
  (a + b) / 2 - Real.sqrt (a * b) ‚â§ (a - b)^2 / (8 * b) :=



Theorem: mathd_algebra_320
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_320
  (x : ‚Ñù)
  (a b c : ‚Ñï)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c ‚àß 0 ‚â§ x)
  (h‚ÇÅ : 2 * x^2 = 4 * x + 9)
  (h‚ÇÇ : x = (a + Real.sqrt b) / c)
  (h‚ÇÉ : c = 2) :
  a + b + c = 26 :=



Theorem: mathd_algebra_405
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_405 (S : Finset ‚Ñï) (h‚ÇÄ : ‚àÄ x, x ‚àà S ‚Üî 0 < x ‚àß x ^ 2 + 4 * x + 4 < 20) :
  S.card = 2 :=



Theorem: mathd_numbertheory_64
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_64 : IsLeast { x : ‚Ñï | 30 * x ‚â° 42 [MOD 47] } 39 :=



Theorem: imo_1974_p3
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1974_p3
  (n : ‚Ñï) :
  ¬¨ 5‚à£‚àë k in Finset.range (n + 1), (Nat.choose (2 * n + 1) (2 * k + 1)) * (2^(3 * k)) :=



Theorem: aime_1991_p6
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1991_p6 (r : ‚Ñù) (h‚ÇÄ : (‚àë k in Finset.Icc (19 : ‚Ñï) 91, Int.floor (r + k / 100)) = 546) :
  Int.floor (100 * r) = 743 :=



Theorem: mathd_numbertheory_126
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_126 (x a : ‚Ñï) (h‚ÇÄ : 0 < x ‚àß 0 < a) (h‚ÇÅ : Nat.gcd a 40 = x + 3)
  (h‚ÇÇ : Nat.lcm a 40 = x * (x + 3))
  (h‚ÇÉ : ‚àÄ b : ‚Ñï, 0 < b ‚Üí Nat.gcd b 40 = x + 3 ‚àß Nat.lcm b 40 = x * (x + 3) ‚Üí a ‚â§ b) : a = 8 :=



Theorem: mathd_algebra_247
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_247 (t s : ‚Ñù) (n : ‚Ñ§) (h‚ÇÄ : t = 2 * s - s ^ 2) (h‚ÇÅ : s = n ^ 2 - 2 ^ n + 1)
  (n) (_ : n = 3) : t = 0 :=



Theorem: mathd_algebra_433
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_433 (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x, f x = 3 * Real.sqrt (2 * x - 7) - 8) : f 8 = 19 :=



Theorem: amc12a_2003_p23
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2003_p23
  (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ (k : ‚Ñï), k ‚àà S ‚Üî 0 < k ‚àß ((k * k) : ‚Ñï) ‚à£ (‚àè i in (Finset.Icc 1 9), i!)) :
  S.card = 672 :=



Theorem: algebra_amgm_sumasqdivbsqgeqsumbdiva
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_amgm_sumasqdivbsqgeqsumbdiva (a b c : ‚Ñù) (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c) :
  a ^ 2 / b ^ 2 + b ^ 2 / c ^ 2 + c ^ 2 / a ^ 2 ‚â• b / a + c / b + a / c :=



Theorem: imo_1992_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1992_p1
  (p q r : ‚Ñ§)
  (h‚ÇÄ : 1 < p ‚àß p < q ‚àß q < r)
  (h‚ÇÅ : (p - 1) * (q - 1) * (r - 1)‚à£(p * q * r - 1)) :
  (p, q, r) = (2, 4, 8) ‚à® (p, q, r) = (3, 5, 15) :=



Theorem: mathd_algebra_437
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_437 (x y : ‚Ñù) (n : ‚Ñ§) (h‚ÇÄ : x ^ 3 = -45) (h‚ÇÅ : y ^ 3 = -101) (h‚ÇÇ : x < n)
  (h‚ÇÉ : ‚Üën < y) : n = -4 :=



Theorem: mathd_algebra_113
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_113
  (x : ‚Ñù) :
  x^2 - 14 * x + 3 ‚â• 7^2 - 14 * 7 + 3 :=



Theorem: numbertheory_4x3m7y3neq2003
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_4x3m7y3neq2003
  (x y : ‚Ñ§) :
  4 * x^3 - 7 * y^3 ‚â† 2003 :=



Theorem: amc12a_2019_p12
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2019_p12 (x y : ‚Ñï) (h‚ÇÄ : x ‚â† 1 ‚àß y ‚â† 1)
    (h‚ÇÅ : Real.log x / Real.log 2 = Real.log 16 / Real.log y) (h‚ÇÇ : x * y = 64) :
    (Real.log (x / y) / Real.log 2) ^ 2 = 20 :=



Theorem: aime_1990_p2
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1990_p2 :
  (52 + 6 * Real.sqrt 43) ^ ((3 : ‚Ñù) / 2) - (52 - 6 * Real.sqrt 43) ^ ((3 : ‚Ñù) / 2) = 828 :=



Theorem: amc12b_2021_p9
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2021_p9 :
  (Real.log 80 / Real.log 2) / (Real.log 2 / Real.log 40) - (Real.log 160 / Real.log 2) / (Real.log 2 / Real.log 20) = 2 :=



Theorem: amc12a_2020_p4
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2020_p4
  (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ (n : ‚Ñï), n ‚àà S ‚Üî 1000 ‚â§ n ‚àß n ‚â§ 9999 ‚àß (‚àÄ (d : ‚Ñï), d ‚àà Nat.digits 10 n ‚Üí Even d) ‚àß 5 ‚à£ n) :
  S.card = 100 :=



Theorem: algebra_apbon2pownleqapownpbpowon2
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_apbon2pownleqapownpbpowon2
  (a b : ‚Ñù)
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < a ‚àß 0 < b)
  (h‚ÇÅ : 0 < n) :
  ((a + b) / 2)^n ‚â§ (a^n + b^n) / 2 :=



Theorem: aime_1983_p9
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1983_p9 (x : ‚Ñù) (h‚ÇÄ : 0 < x ‚àß x < Real.pi) :
  12 ‚â§ (9 * (x ^ 2 * Real.sin x ^ 2) + 4) / (x * Real.sin x) :=



Theorem: mathd_algebra_11
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_11 (a b : ‚Ñù) (h‚ÇÄ : a ‚â† b) (h‚ÇÅ : a ‚â† 2 * b)
    (h‚ÇÇ : (4 * a + 3 * b) / (a - 2 * b) = 5) : (a + 11 * b) / (a - b) = 2 :=



Theorem: algebra_ineq_nto1onlt2m1on
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_ineq_nto1onlt2m1on
  (n : ‚Ñï) :
  n^(1 / n) < 2 - 1 / n :=



Theorem: aime_1997_p11
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1997_p11 (x : ‚Ñù)
    (h‚ÇÄ :
      x =
        (‚àë n in Finset.Icc (1 : ‚Ñï) 44, Real.cos (n * œÄ / 180)) /
          ‚àë n in Finset.Icc (1 : ‚Ñï) 44, Real.sin (n * œÄ / 180)) :
    Int.floor (100 * x) = 241 :=



Theorem: algebra_sqineq_unitcircatbpabsamblt1
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_sqineq_unitcircatbpabsamblt1
  (a b: ‚Ñù)
  (h‚ÇÄ : a^2 + b^2 = 1) :
  a * b + |a - b| ‚â§ 1 :=



Theorem: amc12a_2019_p9
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2019_p9 (a : ‚Ñï ‚Üí ‚Ñö) (h‚ÇÄ : a 1 = 1) (h‚ÇÅ : a 2 = 3 / 7)
  (h‚ÇÇ : ‚àÄ n, a (n + 2) = a n * a (n + 1) / (2 * a n - a (n + 1))) :
  ‚Üë(a 2019).den + (a 2019).num = 8078 :=



Theorem: imo_2006_p6
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_2006_p6 (a b c : ‚Ñù) :
  a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2) ‚â§
  9 * Real.sqrt 2 / 32 * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2 :=



Theorem: aime_1996_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1996_p5 (a b c r s t : ‚Ñù) (f g : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = x ^ 3 + 3 * x ^ 2 + 4 * x - 11) (h‚ÇÅ : ‚àÄ x, g x = x ^ 3 + r * x ^ 2 + s * x + t)
  (h‚ÇÇ : f a = 0) (h‚ÇÉ : f b = 0) (h‚ÇÑ : f c = 0) (h‚ÇÖ : g (a + b) = 0) (h‚ÇÜ : g (b + c) = 0)
  (h‚Çá : g (c + a) = 0) (h‚Çà : List.Pairwise (¬∑ ‚â† ¬∑) [a, b, c]) : t = 23 :=



Theorem: mathd_numbertheory_221
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_221 (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ x : ‚Ñï, x ‚àà S ‚Üî 0 < x ‚àß x < 1000 ‚àß x.divisors.card = 3) : S.card = 11 :=



Theorem: amc12a_2021_p22
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p22
  (a b c : ‚Ñù)
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = x^3 + a * x^2 + b * x + c)
  (h‚ÇÅ : f‚Åª¬π' {0} = {Real.cos (2 * Real.pi / 7), Real.cos (4 * Real.pi / 7), Real.cos (6 * Real.pi / 7)}) :
  a * b * c = 1 / 32 :=



Theorem: algebra_amgm_sqrtxymulxmyeqxpy_xpygeq4
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_amgm_sqrtxymulxmyeqxpy_xpygeq4 (x y : ‚Ñù) (h‚ÇÄ : 0 < x ‚àß 0 < y) (h‚ÇÅ : y ‚â§ x)
  (h‚ÇÇ : Real.sqrt (x * y) * (x - y) = x + y) : x + y ‚â• 4 :=



Theorem: mathd_algebra_421
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_421 (a b c d : ‚Ñù) (h‚ÇÄ : b = a ^ 2 + 4 * a + 6)
  (h‚ÇÅ : b = 1 / 2 * a ^ 2 + a + 6) (h‚ÇÇ : d = c ^ 2 + 4 * c + 6) (h‚ÇÉ : d = 1 / 2 * c ^ 2 + c + 6)
  (h‚ÇÑ : a < c) : c - a = 6 :=



Theorem: algebra_amgm_prod1toneq1_sum1tongeqn
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_amgm_prod1toneq1_sum1tongeqn (a : ‚Ñï ‚Üí NNReal) (n : ‚Ñï)
  (h‚ÇÄ : Finset.prod (Finset.range n) a = 1) : Finset.sum (Finset.range n) a ‚â• n :=



Theorem: imo_1965_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1965_p2
  (x y z : ‚Ñù)
  (a : ‚Ñï ‚Üí ‚Ñù)
  (h‚ÇÄ : 0 < a 0 ‚àß 0 < a 4 ‚àß 0 < a 8)
  (h‚ÇÅ : a 1 < 0 ‚àß a 2 < 0)
  (h‚ÇÇ : a 3 < 0 ‚àß a 5 < 0)
  (h‚ÇÉ : a 6 < 0 ‚àß a 7 < 0)
  (h‚ÇÑ : 0 < a 0 + a 1 + a 2)
  (h‚ÇÖ : 0 < a 3 + a 4 + a 5)
  (h‚ÇÜ : 0 < a 6 + a 7 + a 8)
  (h‚Çá : a 0 * x + a 1 * y + a 2 * z = 0)
  (h‚Çà : a 3 * x + a 4 * y + a 5 * z = 0)
  (h‚Çâ : a 6 * x + a 7 * y + a 8 * z = 0) :
  x = 0 ‚àß y = 0 ‚àß z = 0 :=



Theorem: imo_1967_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1967_p3 (k m n : ‚Ñï) (c : ‚Ñï ‚Üí ‚Ñï) (h‚ÇÄ : 0 < k ‚àß 0 < m ‚àß 0 < n)
  (h‚ÇÅ : ‚àÄ s, c s = s * (s + 1)) (h‚ÇÇ : Nat.Prime (k + m + 1)) (h‚ÇÉ : n + 1 < k + m + 1) :
  (‚àè i in Finset.Icc 1 n, c i) ‚à£ ‚àè i in Finset.Icc 1 n, c (m + i) - c k :=



Theorem: mathd_algebra_17
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_17
  (a : ‚Ñù)
  (h‚ÇÄ : Real.sqrt (4 + Real.sqrt (16 + 16 * a)) + Real.sqrt (1 + Real.sqrt (1 + a)) = 6) :
  a = 8 :=



Theorem: mathd_algebra_59
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_59 (b : ‚Ñù) (h‚ÇÄ : (4 : ‚Ñù) ^ b + 2 ^ 3 = 12) : b = 1 :=



Theorem: mathd_algebra_89
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_89 (b : ‚Ñù) (h‚ÇÄ : b ‚â† 0) :
  (7 * b ^ 3) ^ 2 * (4 * b ^ 2) ^ (-(3 : ‚Ñ§)) = 49 / 64 :=



Theorem: mathd_algebra_282
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_282 (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x : ‚Ñù, ¬¨ (Irrational x) ‚Üí f x = abs (Int.floor x))
  (h‚ÇÅ : ‚àÄ x, Irrational x ‚Üí f x = (Int.ceil x) ^ 2) :
  f (8 ^ (1 / 3)) + f (-Real.pi) + f (Real.sqrt 50) + f (9 / 2) = 79 :=



Theorem: amc12b_2004_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2004_p3 (x y : ‚Ñï) (h‚ÇÄ : 2 ^ x * 3 ^ y = 1296) : x + y = 8 :=



Theorem: mathd_numbertheory_341
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_341
  (a b c : ‚Ñï)
  (h‚ÇÄ : a ‚â§ 9 ‚àß b ‚â§ 9 ‚àß c ‚â§ 9)
  (h‚ÇÅ : Nat.digits 10 ((5^100) % 1000) = [c,b,a]) :
  a + b + c = 13 :=



Theorem: algebra_apbpceq2_abpbcpcaeq1_aleq1on3anbleq1ancleq4on3
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_apbpceq2_abpbcpcaeq1_aleq1on3anbleq1ancleq4on3
  (a b c : ‚Ñù)
  (h‚ÇÄ : a ‚â§ b ‚àß b ‚â§ c)
  (h‚ÇÅ : a + b + c = 2)
  (h‚ÇÇ : a * b + b * c + c * a = 1) :
  0 ‚â§ a ‚àß a ‚â§ 1 / 3 ‚àß 1 / 3 ‚â§ b ‚àß b ‚â§ 1 ‚àß 1 ‚â§ c ‚àß c ‚â§ 4 / 3 :=



Theorem: mathd_algebra_170
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_170
  (S : Finset ‚Ñ§)
  (h‚ÇÄ : ‚àÄ (n : ‚Ñ§), n ‚àà S ‚Üî abs (n - 2) ‚â§ 5 + 6 / 10) :
  S.card = 11 :=



Theorem: mathd_algebra_598
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_598
  (a b c d : ‚Ñù)
  (h‚ÇÅ : ((4:‚Ñù)^a) = 5)
  (h‚ÇÇ : ((5:‚Ñù)^b) = 6)
  (h‚ÇÉ : ((6:‚Ñù)^c) = 7)
  (h‚ÇÑ : ((7:‚Ñù)^d) = 8) :
  a * b * c * d = 3 / 2 :=



Theorem: amc12a_2021_p8
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p8
  (d : ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : d 0 = 0)
  (h‚ÇÅ : d 1 = 0)
  (h‚ÇÇ : d 2 = 1)
  (h‚ÇÉ : ‚àÄ n‚â•3, d n = d (n - 1) + d (n - 3)) :
  Even (d 2021) ‚àß Odd (d 2022) ‚àß Even (d 2023) :=



Theorem: mathd_numbertheory_483
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_483
  (a : ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : a 1 = 1)
  (h‚ÇÅ : a 2 = 1)
  (h‚ÇÇ : ‚àÄ n, a (n + 2) = a (n + 1) + a n) :
  (a 100) % 4 = 3 :=



Theorem: mathd_algebra_509
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_509 :
  Real.sqrt ((5 / Real.sqrt 80 + Real.sqrt 845 / 9 + Real.sqrt 45) / Real.sqrt 5) = 13 / 6 :=



Theorem: algebra_amgm_sum1toneqn_prod1tonleq1
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_amgm_sum1toneqn_prod1tonleq1
  (a : ‚Ñï ‚Üí NNReal)
  (n : ‚Ñï)
  (h‚ÇÄ : ‚àë x in Finset.range n, a x = n) :
  ‚àè x in Finset.range n, a x ‚â§ 1 :=



Theorem: amc12_2000_p15
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12_2000_p15 (f : ‚ÑÇ ‚Üí ‚ÑÇ) (h‚ÇÄ : ‚àÄ x, f (x / 3) = x ^ 2 + x + 1)
  (h‚ÇÅ : Fintype (f ‚Åª¬π' {7})) : (‚àë y in (f ‚Åª¬π' {7}).toFinset, y / 3) = -1 / 9 :=



Theorem: amc12_2001_p5
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12_2001_p5 :
  Finset.prod (Finset.filter (Œª x => ¬¨ Even x) (Finset.range 10000)) (id : ‚Ñï ‚Üí ‚Ñï) = (10000!) / ((2^5000) * (5000!)) :=



Theorem: algebra_2varlineareq_fp3zeq11_3tfm1m5zeqn68_feqn10_zeq7
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_2varlineareq_fp3zeq11_3tfm1m5zeqn68_feqn10_zeq7
  (f z: ‚ÑÇ)
  (h‚ÇÄ : f + 3*z = 11)
  (h‚ÇÅ : 3*(f - 1) - 5*z = -68) :
  f = -10 ‚àß z = 7 :=



Theorem: mathd_algebra_140
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_140 (a b c : ‚Ñù) (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c)
  (h‚ÇÅ : ‚àÄ x, 24 * x ^ 2 - 19 * x - 35 = (a * x - 5) * (2 * (b * x) + c)) : a * b - 3 * c = -9 :=



Theorem: mathd_algebra_77
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_77 (a b : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : a ‚â† 0 ‚àß b ‚â† 0) (h‚ÇÅ : a ‚â† b)
  (h‚ÇÇ : ‚àÄ x, f x = x ^ 2 + a * x + b) (h‚ÇÉ : f a = 0) (h‚ÇÑ : f b = 0) : a = 1 ‚àß b = -2 :=



Theorem: amc12b_2002_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2002_p3 (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚àà S ‚Üî 0 < n ‚àß Nat.Prime (n ^ 2 + 2 - 3 * n)) :
  S.card = 1 :=



Theorem: algebra_sum1onsqrt2to1onsqrt10000lt198
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_sum1onsqrt2to1onsqrt10000lt198 :
  ‚àë k in (Finset.Icc (2 : ‚Ñï) 10000), (1 / Real.sqrt k) < 198 :=



Theorem: amc12b_2002_p6
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2002_p6 (a b : ‚Ñù) (h‚ÇÄ : a ‚â† 0 ‚àß b ‚â† 0)
  (h‚ÇÅ : ‚àÄ x, x ^ 2 + a * x + b = (x - a) * (x - b)) : a = 1 ‚àß b = -2 :=



Theorem: amc12b_2020_p22
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2020_p22
  (t : ‚Ñù) :
  ((2^t - 3 * t) * t) / (4^t) ‚â§ 1 / 12 :=



Theorem: induction_pord1p1on2powklt5on2
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_pord1p1on2powklt5on2
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n) :
  ‚àè k in Finset.Icc 1 n, (1 + (1:‚Ñù) / 2^k) < 5 / 2 :=



Theorem: mathd_algebra_69
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_69 (rows seats : ‚Ñï) (h‚ÇÄ : rows * seats = 450)
  (h‚ÇÅ : (rows + 5) * (seats - 3) = 450) : rows = 25 :=



Theorem: amc12a_2020_p13
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2020_p13 (a b c : ‚Ñï) (n : NNReal) (h‚ÇÄ : n ‚â† 1) (h‚ÇÅ : 1 < a ‚àß 1 < b ‚àß 1 < c)
  (h‚ÇÇ : (n * (n * n ^ (1 / c)) ^ (1 / b)) ^ (1 / a) = (n ^ 25) ^ (1 / 36)) : b = 3 :=



Theorem: aime_1990_p15
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1990_p15
  (a b x y : ‚Ñù)
  (h‚ÇÄ : a * x + b * y = 3)
  (h‚ÇÅ : a * x^2 + b * y^2 = 7)
  (h‚ÇÇ : a * x^3 + b * y^3 = 16)
  (h‚ÇÉ : a * x^4 + b * y^4 = 42) :
  a * x^5 + b * y^5 = 20 :=



Theorem: imo_1969_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1969_p2
  (m n : ‚Ñù)
  (k : ‚Ñï)
  (a : ‚Ñï ‚Üí ‚Ñù)
  (y : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : 0 < k)
  (h‚ÇÅ : ‚àÄ x, y x = ‚àë i in Finset.range k, ((Real.cos (a i + x)) / (2^i)))
  (h‚ÇÇ : y m = 0)
  (h‚ÇÉ : y n = 0) :
  ‚àÉ t : ‚Ñ§, m - n = t * œÄ :=



Theorem: imo_1968_p5_1
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1968_p5_1
  (a : ‚Ñù)
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : 0 < a)
  (h‚ÇÅ : ‚àÄ x, f (x + a) = 1 / 2 + Real.sqrt (f x - (f x)^2)) :
  ‚àÉ b > 0, ‚àÄ x, f (x + b) = f x :=



Theorem: mathd_algebra_224
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_224 (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚àà S ‚Üî Real.sqrt n < 7 / 2 ‚àß 2 < Real.sqrt n) : S.card = 8 :=



Theorem: mathd_algebra_536
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_536 : ‚Üë3! * ((2 : ‚Ñù) ^ 3 + Real.sqrt 9) / 2 = (33 : ‚Ñù) :=



Theorem: mathd_numbertheory_435
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_435
  (k : ‚Ñï)
  (h‚ÇÄ : 0 < k)
  (h‚ÇÅ : ‚àÄ n, Nat.gcd (6 * n + k) (6 * n + 3) = 1)
  (h‚ÇÇ : ‚àÄ n, Nat.gcd (6 * n + k) (6 * n + 2) = 1)
  (h‚ÇÉ : ‚àÄ n, Nat.gcd (6 * n + k) (6 * n + 1) = 1) :
  5 ‚â§ k :=



Theorem: numbertheory_2pownm1prime_nprime
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_2pownm1prime_nprime
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n)
  (h‚ÇÅ : Nat.Prime (2^n - 1)) :
  Nat.Prime n :=



Theorem: algebra_others_exirrpowirrrat
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_others_exirrpowirrrat :
  ‚àÉ a b, Irrational a ‚àß Irrational b ‚àß ¬¨ Irrational (a^b) :=



Theorem: amc12a_2020_p10
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2020_p10
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n)
  (h‚ÇÅ : Real.logb 2 (Real.logb 16 n) = Real.logb 4 (Real.logb 4 n)) :
  (Nat.digits 10 n).sum = 13 :=



Theorem: mathd_numbertheory_711
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_711
  (m n : ‚Ñï)
  (h‚ÇÄ : 0 < m ‚àß 0 < n)
  (h‚ÇÅ : Nat.gcd m n = 8)
  (h‚ÇÇ : Nat.lcm m n = 112) :
  72 ‚â§ m + n :=



Theorem: amc12b_2003_p17
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2003_p17 (x y : ‚Ñù) (h‚ÇÄ : 0 < x ‚àß 0 < y) (h‚ÇÅ : Real.log (x * y ^ 3) = 1)
  (h‚ÇÇ : Real.log (x ^ 2 * y) = 1) : Real.log (x * y) = 3 / 5 :=



Theorem: imosl_2007_algebra_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem imosl_2007_algebra_p6
  (a : ‚Ñï ‚Üí NNReal)
  (h‚ÇÄ : ‚àë x in Finset.range 100, ((a (x + 1))^2) = 1) :
  ‚àë x in Finset.range 99, ((a (x + 1))^2 * a (x + 2)) + (a 100)^2 * a 1 < 12 / 25 :=



Theorem: mathd_numbertheory_543
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_543 : (‚àë k in Nat.divisors (30 ^ 4), 1) - 2 = 123 :=



Theorem: mathd_algebra_206
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_206 (a b : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x, f x = x ^ 2 + a * x + b) (h‚ÇÅ : 2 * a ‚â† b)
  (h‚ÇÇ : f (2 * a) = 0) (h‚ÇÉ : f b = 0) : a + b = -1 :=



Theorem: mathd_algebra_22
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_22 : Real.logb (5 ^ 2) (5 ^ 4) = 2 :=



Theorem: amc12a_2009_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2009_p6
  (m n p q : ‚Ñù)
  (h‚ÇÄ : p = 2 ^ m)
  (h‚ÇÅ : q = 3 ^ n) :
  p^(2 * n) * (q^m) = 12^(m * n) :=



Theorem: amc12a_2010_p11
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2010_p11 (x b : ‚Ñù) (h‚ÇÄ : 0 < b) (h‚ÇÅ : (7 : ‚Ñù) ^ (x + 7) = 8 ^ x)
  (h‚ÇÇ : x = Real.logb b (7 ^ 7)) : b = 8 / 7 :=



Theorem: numbertheory_3pow2pownm1mod2pownp3eq2pownp2
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_3pow2pownm1mod2pownp3eq2pownp2
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n) :
  (3^(2^n) - 1) % (2^(n + 3)) = 2^(n + 2) :=



Theorem: mathd_numbertheory_764
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_764
  (p : ‚Ñï)
  (h‚ÇÄ : Nat.Prime p)
  (h‚ÇÅ : 7 ‚â§ p) :
  ‚àë k in Finset.Icc 1 (p-2), ((k: ZMod p)‚Åª¬π * ((k: ZMod p) + 1)‚Åª¬π) = 2 :=



Theorem: algebra_amgm_sumasqdivbgeqsuma
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_amgm_sumasqdivbgeqsuma
  (a b c d : ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c ‚àß 0 < d) :
  a^2 / b + b^2 / c + c^2 / d + d^2 / a ‚â• a + b + c + d :=



Theorem: mathd_numbertheory_296
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_296
  (n : ‚Ñï)
  (h‚ÇÄ : 2 ‚â§ n)
  (h‚ÇÅ : ‚àÉ x, x^3 = n)
  (h‚ÇÇ : ‚àÉ t, t^4 = n) :
  4096 ‚â§ n :=



Theorem: mathd_algebra_13
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_13 (a b : ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, x - 3 ‚â† 0 ‚àß x - 5 ‚â† 0 ‚Üí 4 * x / (x ^ 2 - 8 * x + 15) = a / (x - 3) + b / (x - 5)) :
  a = -6 ‚àß b = 10 :=



Theorem: amc12a_2021_p18
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p18
  (f : ‚Ñö ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄx>0, ‚àÄy>0, f (x * y) = f x + f y)
  (h‚ÇÅ : ‚àÄp, Nat.Prime p ‚Üí f p = p) :
  f (25 / 11) < 0 :=



Theorem: amc12a_2008_p4
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2008_p4 : (‚àè k in Finset.Icc (1 : ‚Ñï) 501, ((4 : ‚Ñù) * k + 4) / (4 * k)) = 502 :=



Theorem: mathd_algebra_185
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_185 (s : Finset ‚Ñ§) (f : ‚Ñ§ ‚Üí ‚Ñ§) (h‚ÇÄ : ‚àÄ x, f x = abs (x + 4))
  (h‚ÇÅ : ‚àÄ x, x ‚àà s ‚Üî f x < 9) : s.card = 17 :=



Theorem: imo_1987_p4
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1987_p4 (f : ‚Ñï ‚Üí ‚Ñï) : ‚àÉ n, f (f n) ‚â† n + 1987 :=



Theorem: mathd_numbertheory_42
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_42 (S : Set ‚Ñï) (u v : ‚Ñï) (h‚ÇÄ : ‚àÄ a : ‚Ñï, a ‚àà S ‚Üî 0 < a ‚àß 27 * a % 40 = 17)
    (h‚ÇÅ : IsLeast S u) (h‚ÇÇ : IsLeast (S \ {u}) v) : u + v = 62 :=



Theorem: amc12a_2010_p22
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2010_p22 (x : ‚Ñù) : 49 ‚â§ ‚àë k:‚Ñ§ in Finset.Icc 1 119, abs (‚Üëk * x - 1) :=



Theorem: numbertheory_sqmod3in01d
File path: MiniF2F/Valid.lean
Theorem statement: theorem numbertheory_sqmod3in01d (a : ‚Ñ§) : a ^ 2 % 3 = 0 ‚à® a ^ 2 % 3 = 1 :=



Theorem: amc12b_2021_p3
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2021_p3
  (x : ‚Ñù)
  (h‚ÇÄ : 2 + 1 / (1 + 1 / (2 + 2 / (3 + x))) = 144 / 53) :
  x = 3 / 4 :=



Theorem: aime_1991_p9
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1991_p9
  (x : ‚Ñù)
  (m : ‚Ñö)
  (h‚ÇÄ : 1 / Real.cos x + Real.tan x = 22 / 7)
  (h‚ÇÅ : 1 / Real.sin x + 1 / Real.tan x = m) :
  ‚Üëm.den + m.num = 44 :=



Theorem: algebra_sqineq_2at2pclta2c2p41pc
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_sqineq_2at2pclta2c2p41pc (a c : ‚Ñù) :
  2 * a * (2 + c) ‚â§ a ^ 2 + c ^ 2 + 4 * (1 + c) :=



Theorem: mathd_numbertheory_427
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_427
  (a : ‚Ñï)
  (h‚ÇÄ : a = (‚àë k in (Nat.divisors 500), k)) :
  ‚àë k in Finset.filter (Œª x => Nat.Prime x) (Nat.divisors a), k = 25 :=



Theorem: imo_1959_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1959_p1
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n) :
  Nat.gcd (21*n + 4) (14*n + 3) = 1 :=



Theorem: mathd_numbertheory_5
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_5
  (n : ‚Ñï)
  (h‚ÇÄ : 10 ‚â§ n)
  (h‚ÇÅ : ‚àÉ x, x^2 = n)
  (h‚ÇÇ : ‚àÉ t, t^3 = n) :
  64 ‚â§ n :=



Theorem: amc12_2000_p12
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12_2000_p12
  (a m c : ‚Ñï)
  (h‚ÇÄ : a + m + c = 12) :
  a*m*c + a*m + m*c + a*c ‚â§ 112 :=



Theorem: aime_1995_p7
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1995_p7
  (k m n : ‚Ñï)
  (t : ‚Ñù)
  (h‚ÇÄ : 0 < k ‚àß 0 < m ‚àß 0 < n)
  (h‚ÇÅ : Nat.gcd m n = 1)
  (h‚ÇÇ : (1 + Real.sin t) * (1 + Real.cos t) = 5/4)
  (h‚ÇÉ : (1 - Real.sin t) * (1- Real.cos t) = m/n - Real.sqrt k):
  k + m + n = 27 :=



Theorem: algebra_sqineq_unitcircatbpamblt1
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_sqineq_unitcircatbpamblt1
  (a b: ‚Ñù)
  (h‚ÇÄ : a^2 + b^2 = 1) :
  a * b + (a - b) ‚â§ 1 :=



Theorem: amc12a_2020_p9
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2020_p9
  (S : Finset ‚Ñù)
  (h‚ÇÄ : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üî 0 ‚â§ x ‚àß x ‚â§ 2 * Real.pi ‚àß Real.tan (2 * x) = Real.cos (x / 2)) :
  S.card = 5 :=



Theorem: numbertheory_x5neqy2p4
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_x5neqy2p4
  (x y : ‚Ñ§) :
  x^5 ‚â† y^2 + 4 :=



Theorem: amc12a_2021_p14
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p14 :
  (‚àë k in (Finset.Icc 1 20), (Real.logb (5^k) (3^(k^2)))) * (‚àë k in (Finset.Icc 1 100), (Real.logb (9^k) (25^k))) = 21000 :=



Theorem: numbertheory_fxeq4powxp6powxp9powx_f2powmdvdf2pown
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_fxeq4powxp6powxp9powx_f2powmdvdf2pown
  (m n : ‚Ñï)
  (f : ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : ‚àÄ x, f x = 4^x + 6^x + 9^x)
  (h‚ÇÅ : 0 < m ‚àß 0 < n)
  (h‚ÇÇ : m ‚â§ n) :
  f (2^m)‚à£f (2^n) :=



Theorem: mathd_numbertheory_618
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_618
  (n : ‚Ñï)
  (p : ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : ‚àÄ x, p x = x^2 - x + 41)
  (h‚ÇÅ : 1 < Nat.gcd (p n) (p (n+1))) :
  41 ‚â§ n :=



Theorem: amc12b_2021_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2021_p1
  (S : Finset ‚Ñ§)
  (h‚ÇÄ : ‚àÄ (x : ‚Ñ§), x ‚àà S ‚Üî ‚Üë(abs x) < 3 * Real.pi):
  S.card = 19 :=



Theorem: mathd_algebra_153
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_153
  (n : ‚Ñù)
  (h‚ÇÄ : n = 1 / 3) :
  Int.floor (10 * n) + Int.floor (100 * n) + Int.floor (1000 * n) + Int.floor (10000 * n) = 3702 :=



Theorem: amc12b_2020_p21
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2020_p21
  (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ (n : ‚Ñï), n ‚àà S ‚Üî 0 < n ‚àß (‚Üën + (1000 : ‚Ñù)) / 70 = Int.floor (Real.sqrt n)) :
  S.card = 6 :=



Theorem: aimeII_2001_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem aimeII_2001_p3 (x : ‚Ñï ‚Üí ‚Ñ§) (h‚ÇÄ : x 1 = 211) (h‚ÇÇ : x 2 = 375) (h‚ÇÉ : x 3 = 420)
  (h‚ÇÑ : x 4 = 523) (h‚ÇÜ : ‚àÄ n ‚â• 5, x n = x (n - 1) - x (n - 2) + x (n - 3) - x (n - 4)) :
  x 531 + x 753 + x 975 = 898 :=



Theorem: mathd_numbertheory_709
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_709 (n : ‚Ñï) (h‚ÇÄ : 0 < n) (h‚ÇÅ : Finset.card (Nat.divisors (2 * n)) = 28)
  (h‚ÇÇ : Finset.card (Nat.divisors (3 * n)) = 30) : Finset.card (Nat.divisors (6 * n)) = 35 :=



Theorem: amc12b_2020_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2020_p6
  (n : ‚Ñï)
  (h‚ÇÄ : 9 ‚â§ n) :
  ‚àÉ (x : ‚Ñï), (x : ‚Ñù)^2 = (Nat.factorial (n + 2) - Nat.factorial (n + 1)) / n! :=



Theorem: algebra_abpbcpcageq3_sumaonsqrtapbgeq3onsqrt2
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_abpbcpcageq3_sumaonsqrtapbgeq3onsqrt2
  (a b c : ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c)
  (h‚ÇÅ : 3 ‚â§ a * b + b * c + c * a) :
  3 / Real.sqrt 2 ‚â§ a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) :=



Theorem: mathd_numbertheory_22
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_22 (b : ‚Ñï) (h‚ÇÄ : b < 10)
  (h‚ÇÅ : Nat.sqrt (10 * b + 6) * Nat.sqrt (10 * b + 6) = 10 * b + 6) : b = 3 ‚à® b = 1 :=



Theorem: numbertheory_sqmod4in01d
File path: MiniF2F/Valid.lean
Theorem statement: theorem numbertheory_sqmod4in01d (a : ‚Ñ§) : a ^ 2 % 4 = 0 ‚à® a ^ 2 % 4 = 1 :=



Theorem: amc12a_2020_p15
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2020_p15
  (a b : ‚ÑÇ)
  (h‚ÇÄ : a^3 - 8 = 0)
  (h‚ÇÅ : b^3 - 8 * b^2 - 8 * b + 64 = 0) :
  Complex.abs (a - b) ‚â§ 2 * Real.sqrt 21 :=



Theorem: imo_1964_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1964_p2
  (a b c : ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c)
  (h‚ÇÅ : c < a + b)
  (h‚ÇÇ : b < a + c)
  (h‚ÇÉ : a < b + c) :
  a^2 * (b + c - a) + b^2 * (c + a - b) + c^2 * (a + b - c) ‚â§ 3 * a * b * c :=



Theorem: amc12b_2002_p7
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2002_p7
  (a b c : ‚Ñï)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c)
  (h‚ÇÅ : b = a + 1)
  (h‚ÇÇ : c = b + 1)
  (h‚ÇÉ : a * b * c = 8 * (a + b + c)) :
  a^2 + (b^2 + c^2) = 77 :=



Theorem: mathd_algebra_149
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_149 (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x < -5, f x = x ^ 2 + 5)
  (h‚ÇÅ : ‚àÄ x ‚â• -5, f x = 3 * x - 8) (h‚ÇÇ : Fintype (f ‚Åª¬π' {10})) :
  (‚àë k in (f ‚Åª¬π' {10}).toFinset, k) = 6 :=



Theorem: mathd_algebra_510
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_510 (x y : ‚Ñù) (h‚ÇÄ : x + y = 13) (h‚ÇÅ : x * y = 24) :
  Real.sqrt (x ^ 2 + y ^ 2) = 11 :=



Theorem: aime_1987_p8
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1987_p8 :
  IsGreatest { n : ‚Ñï | 0 < n ‚àß ‚àÉ! k : ‚Ñï, (8 : ‚Ñù) / 15 < n / (n + k) ‚àß (n : ‚Ñù) / (n + k) < 7 / 13 } 112 :=



Theorem: mathd_algebra_192
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_192 (q e d : ‚ÑÇ) (h‚ÇÄ : q = 11 - 5 * Complex.I) (h‚ÇÅ : e = 11 + 5 * Complex.I)
    (h‚ÇÇ : d = 2 * Complex.I) : q * e * d = 292 * Complex.I :=



Theorem: aime_1988_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1988_p3 (x : ‚Ñù) (h‚ÇÄ : 0 < x)
  (h‚ÇÅ : Real.logb 2 (Real.logb 8 x) = Real.logb 8 (Real.logb 2 x)) : Real.logb 2 x ^ 2 = 27 :=



Theorem: mathd_algebra_459
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_459
  (a b c d : ‚Ñö)
  (h‚ÇÄ : 3 * a = b + c + d)
  (h‚ÇÅ : 4 * b = a + c + d)
  (h‚ÇÇ : 2 * c = a + b + d)
  (h‚ÇÉ : 8 * a + 10 * b + 6 * c = 24) :
  ‚Üëd.den + d.num = 28 :=



Theorem: amc12a_2003_p24
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2003_p24 :
  IsGreatest { y : ‚Ñù | ‚àÉ a b : ‚Ñù, 1 < b ‚àß b ‚â§ a ‚àß y = Real.logb a (a / b) + Real.logb b (b / a) }
    0 :=



Theorem: mathd_algebra_342
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_342
  (a d: ‚Ñù)
  (h‚ÇÄ : ‚àë k in (Finset.range 5), (a + k * d) = 70)
  (h‚ÇÅ : ‚àë k in (Finset.range 10), (a + k * d) = 210) :
  a = 42/5 :=



Theorem: algebra_apb4leq8ta4pb4
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_apb4leq8ta4pb4 (a b : ‚Ñù) (h‚ÇÄ : 0 < a ‚àß 0 < b) : (a + b) ^ 4 ‚â§ 8 * (a ^ 4 + b ^ 4) :=



Theorem: mathd_algebra_487
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_487
  (a b c d : ‚Ñù)
  (h‚ÇÄ : b = a^2)
  (h‚ÇÅ : a + b = 1)
  (h‚ÇÇ : d = c^2)
  (h‚ÇÉ : c + d = 1)
  (h‚ÇÑ : a ‚â† c) :
  Real.sqrt ((a - c)^2 + (b - d)^2)= Real.sqrt 10 :=



Theorem: mathd_algebra_156
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_156
  (x y : ‚Ñù)
  (f g : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄt, f t = t^4)
  (h‚ÇÅ : ‚àÄt, g t = 5 * t^2 - 6)
  (h‚ÇÇ : f x = g x)
  (h‚ÇÉ : f y = g y)
  (h‚ÇÑ : x^2 < y^2) :
  y^2 - x^2 = 1 :=



Theorem: mathd_algebra_482
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_482 (m n : ‚Ñï) (k : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : Nat.Prime m) (h‚ÇÅ : Nat.Prime n)
  (h‚ÇÇ : ‚àÄ x, f x = x ^ 2 - 12 * x + k) (h‚ÇÉ : f m = 0) (h‚ÇÑ : f n = 0) (h‚ÇÖ : m ‚â† n) : k = 35 :=



Theorem: imo_1987_p6
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1987_p6 (p : ‚Ñï) (f : ‚Ñï ‚Üí ‚Ñï) (h‚ÇÄ : ‚àÄ x, f x = x ^ 2 + x + p)
  (h‚ÇÄ : ‚àÄ k : ‚Ñï, k ‚â§ Nat.floor (Real.sqrt (p / 3)) ‚Üí Nat.Prime (f k)) :
   ‚àÄ i ‚â§ p - 2, Nat.Prime (f i) :=



Theorem: mathd_algebra_422
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_422 (x : ‚Ñù) (œÉ : Equiv ‚Ñù ‚Ñù) (h‚ÇÄ : ‚àÄ x, œÉ.1 x = 5 * x - 12)
  (h‚ÇÅ : œÉ.1 (x + 1) = œÉ.2 x) : x = 47 / 24 :=



Theorem: amc12b_2020_p13
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2020_p13 :
  Real.sqrt (Real.log 6 / Real.log 2 + Real.log 6 / Real.log 3) = Real.sqrt (Real.log 3 / Real.log 2) + Real.sqrt (Real.log 2 / Real.log 3) :=



Theorem: amc12b_2021_p4
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2021_p4
  (m a : ‚Ñï)
  (h‚ÇÄ : 0 < m ‚àß 0 < a)
  (h‚ÇÅ : ‚Üëm / ‚Üëa = (3:‚Ñù) / 4) :
  (84 * ‚Üëm + 70 * ‚Üëa) / (‚Üëm + ‚Üëa) = (76:‚Ñù) :=



Theorem: mathd_algebra_293
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_293
  (x : NNReal) :
  Real.sqrt (60 * x) * Real.sqrt (12 * x) * Real.sqrt (63 * x) = 36 * x * Real.sqrt (35 * x) :=



Theorem: imo_1977_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1977_p5 (a b q r : ‚Ñï) (h‚ÇÄ : r < a + b) (h‚ÇÅ : a ^ 2 + b ^ 2 = (a + b) * q + r)
  (h‚ÇÇ : q ^ 2 + r = 1977) :
  abs ((a : ‚Ñ§) - 22) = 15 ‚àß abs ((b : ‚Ñ§) - 22) = 28 ‚à®
    abs ((a : ‚Ñ§) - 22) = 28 ‚àß abs ((b : ‚Ñ§) - 22) = 15 :=



Theorem: mathd_algebra_208
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_208 :
  Real.sqrt 1000000 - 1000000^(1/3) = 900 :=



Theorem: amc12a_2002_p13
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2002_p13
  (a b : ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b)
  (h‚ÇÅ : a ‚â† b)
  (h‚ÇÇ : abs (a - 1/a) = 1)
  (h‚ÇÉ : abs (b - 1/b) = 1) :
  a + b = Real.sqrt 5 :=



Theorem: induction_sumkexp3eqsumksq
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_sumkexp3eqsumksq
  (n : ‚Ñï) :
  ‚àë k in Finset.range n, k^3 = (‚àë k in Finset.range n, k)^2 :=



Theorem: imo_1966_p4
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1966_p4 (n : ‚Ñï) (x : ‚Ñù) (h‚ÇÄ : ‚àÄ k : ‚Ñï, 0 < k ‚Üí ‚àÄ m : ‚Ñ§, x ‚â† m * œÄ / 2 ^ k)
  (h‚ÇÅ : 0 < n) :
  (‚àë k in Finset.Icc 1 n, 1 / Real.sin (2 ^ k * x)) = 1 / Real.tan x - 1 / Real.tan (2 ^ n * x) :=



Theorem: amc12a_2008_p15
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2008_p15 (k : ‚Ñï) (h‚ÇÄ : k = 2008 ^ 2 + 2 ^ 2008) : (k ^ 2 + 2 ^ k) % 10 = 6 :=



Theorem: imo_1964_p1_1
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1964_p1_1 (n : ‚Ñï) (h‚ÇÄ : 7 ‚à£ 2 ^ n - 1) : 3 ‚à£ n :=



Theorem: induction_seq_mul2pnp1
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_seq_mul2pnp1 (n : ‚Ñï) (u : ‚Ñï ‚Üí ‚Ñï) (h‚ÇÄ : u 0 = 0)
  (h‚ÇÅ : ‚àÄ n, u (n + 1) = 2 * u n + (n + 1)) : u n = 2 ^ (n + 1) - (n + 2) :=



Theorem: aime_1988_p4
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1988_p4 (n : ‚Ñï) (a : ‚Ñï ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ n, abs (a n) < 1)
  (h‚ÇÅ : (‚àë k in Finset.range n, abs (a k)) = 19 + abs (‚àë k in Finset.range n, a k)) : 20 ‚â§ n :=



Theorem: amc12a_2002_p1
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2002_p1 (f : ‚ÑÇ ‚Üí ‚ÑÇ) (h‚ÇÄ : ‚àÄ x, f x = (2 * x + 3) * (x - 4) + (2 * x + 3) * (x - 6))
  (h‚ÇÅ : Fintype (f ‚Åª¬π' {0})) : (‚àë y in (f ‚Åª¬π' {0}).toFinset, y) = 7 / 2 :=



Theorem: amc12a_2008_p8
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2008_p8 (x y : ‚Ñù) (h‚ÇÄ : 0 < x ‚àß 0 < y) (h‚ÇÅ : y ^ 3 = 1)
  (h‚ÇÇ : 6 * x ^ 2 = 2 * (6 * y ^ 2)) : x ^ 3 = 2 * Real.sqrt 2 :=



Theorem: amc12_2001_p21
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12_2001_p21
  (a b c d : ‚Ñï)
  (h‚ÇÄ : a * b * c * d = Nat.factorial 8)
  (h‚ÇÅ : a * b + a + b = 524)
  (h‚ÇÇ : b * c + b + c = 146)
  (h‚ÇÉ : c * d + c + d = 104) :
  ‚Üëa - ‚Üëd = (10 : ‚Ñ§) :=



Theorem: mathd_numbertheory_303
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_303 (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚àà S ‚Üî 2 ‚â§ n ‚àß 171 ‚â° 80 [MOD n] ‚àß 468 ‚â° 13 [MOD n]) : (‚àë k in S, k) = 111 :=



Theorem: mathd_numbertheory_690
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_690 :
    IsLeast { a : ‚Ñï | 0 < a ‚àß a ‚â° 2 [MOD 3] ‚àß a ‚â° 4 [MOD 5] ‚àß a ‚â° 6 [MOD 7] ‚àß a ‚â° 8 [MOD 9] } 314 :=



Theorem: mathd_numbertheory_457
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_457
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n)
  (h‚ÇÅ : 80325‚à£(n!)) :
  17 ‚â§ n :=



Theorem: imo_1983_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1983_p6
  (a b c : ‚Ñù)
  (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c)
  (h‚ÇÅ : c < a + b)
  (h‚ÇÇ : b < a + c)
  (h‚ÇÉ : a < b + c) :
  0 ‚â§ a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) :=



Theorem: numbertheory_sumkmulnckeqnmul2pownm1
File path: MiniF2F/Valid.lean
Theorem statement: theorem numbertheory_sumkmulnckeqnmul2pownm1 (n : ‚Ñï) (h‚ÇÄ : 0 < n) :
  (‚àë k in Finset.Icc 1 n, k * Nat.choose n k) = n * 2 ^ (n - 1) :=



Theorem: amc12b_2020_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2020_p5 (a b : ‚Ñï) (h‚ÇÄ : (5 : ‚Ñö) / 8 * b = 2 / 3 * a + 7)
  (h‚ÇÅ : (b : ‚Ñö) - 5 / 8 * b = a - 2 / 3 * a + 7) : a = 42 :=



Theorem: mathd_algebra_452
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_452
  (a : ‚Ñï ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ n, a (n + 2) - a (n + 1) = a (n + 1) - a n)
  (h‚ÇÅ : a 1 = 2 / 3)
  (h‚ÇÇ : a 9 = 4 / 5) :
  a 5 = 11 / 15 :=



Theorem: aime_1983_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1983_p1 (x y z w : ‚Ñï) (ht : 1 < x ‚àß 1 < y ‚àß 1 < z) (hw : 0 ‚â§ w)
    (h0 : Real.log w / Real.log x = 24) (h1 : Real.log w / Real.log y = 40)
    (h2 : Real.log w / Real.log (x * y * z) = 12) : Real.log w / Real.log z = 60 :=



Theorem: mathd_algebra_338
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_338
  (a b c : ‚Ñù)
  (h‚ÇÄ : 3 * a + b + c = -3)
  (h‚ÇÅ : a + 3 * b + c = 9)
  (h‚ÇÇ : a + b + 3 * c = 19) :
  a * b * c = -56 :=



Theorem: mathd_algebra_288
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_288
  (x y : ‚Ñù)
  (n : NNReal)
  (h‚ÇÄ : x < 0 ‚àß y < 0)
  (h‚ÇÅ : abs y = 6)
  (h‚ÇÇ : Real.sqrt ((x - 8)^2 + (y - 3)^2) = 15)
  (h‚ÇÉ : Real.sqrt (x^2 + y^2) = Real.sqrt n) :
  n = 52 :=



Theorem: induction_divisibility_3div2tooddnp1
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_divisibility_3div2tooddnp1 (n : ‚Ñï) : 3 ‚à£ 2 ^ (2 * n + 1) + 1 :=



Theorem: numbertheory_aoddbdiv4asqpbsqmod8eq1
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_aoddbdiv4asqpbsqmod8eq1
  (a : ‚Ñ§)
  (b : ‚Ñ§)
  (h‚ÇÄ : Odd a)
  (h‚ÇÅ : 4 ‚à£ b)
  (h‚ÇÇ : b >= 0) :
  (a^2 + b^2) % 8 = 1 :=



Theorem: imo_1977_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1977_p6
  (f : ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : ‚àÄ n, 0 < f n)
  (h‚ÇÅ : ‚àÄ n, 0 < n ‚Üí f (f n) < f (n + 1)) :
  ‚àÄ n, 0 < n ‚Üí f n = n :=



Theorem: aime_1999_p11
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1999_p11
  (m : ‚Ñö)
  (h‚ÇÄ : 0 < m)
  (h‚ÇÅ : ‚àë k in Finset.Icc (1 : ‚Ñï) 35, Real.sin (5 * k * œÄ / 180) = Real.tan (m * œÄ / 180))
  (h‚ÇÇ : (m.num:‚Ñù) / m.den < 90) :
  ‚Üëm.den + m.num = 177 :=



Theorem: mathd_numbertheory_156
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_156 (n : ‚Ñï) (h‚ÇÄ : 0 < n) : Nat.gcd (n + 7) (2 * n + 1) ‚â§ 13 :=



Theorem: mathd_algebra_131
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_131 (a b : ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x, f x = 2 * x ^ 2 - 7 * x + 2)
  (h‚ÇÅ : f a = 0) (h‚ÇÇ : f b = 0) (h‚ÇÉ : a ‚â† b) : 1 / (a - 1) + 1 / (b - 1) = -1 :=



Theorem: numbertheory_nckeqnm1ckpnm1ckm1
File path: MiniF2F/Valid.lean
Theorem statement: theorem numbertheory_nckeqnm1ckpnm1ckm1 (n k : ‚Ñï) (h‚ÇÄ : 0 < n ‚àß 0 < k) (h‚ÇÅ : k ‚â§ n) :
  Nat.choose n k = Nat.choose (n - 1) k + Nat.choose (n - 1) (k - 1) :=



Theorem: aime_1997_p9
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1997_p9
  (a : ‚Ñù)
  (h‚ÇÄ : 0 < a)
  (h‚ÇÅ : 1 / a - Int.floor (1 / a) = a^2 - Int.floor (a^2))
  (h‚ÇÇ : 2 < a^2)
  (h‚ÇÉ : a^2 < 3) :
  a^12 - 144 * (1 / a) = 233 :=



Theorem: algebra_sqineq_2unitcircatblt1
File path: MiniF2F/Valid.lean
Theorem statement: theorem algebra_sqineq_2unitcircatblt1 (a b : ‚Ñù) (h‚ÇÄ : a ^ 2 + b ^ 2 = 2) : a * b ‚â§ 1 :=



Theorem: induction_sum2kp1npqsqm1
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_sum2kp1npqsqm1 (n : ‚Ñï) :
  ‚àë k in Finset.range n, (2 * k + 3) = (n + 1) ^ 2 - 1 :=



Theorem: mathd_algebra_493
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_493 (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x, f x = x ^ 2 - 4 * Real.sqrt x + 1) :
    f (f 4) = 70 :=



Theorem: mathd_algebra_151
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_151 : Int.ceil (Real.sqrt 27) - Int.floor (Real.sqrt 26) = 1 :=



Theorem: aimeI_2000_p7
File path: MiniF2F/Valid.lean
Theorem statement: theorem aimeI_2000_p7 (x y z : ‚Ñù) (m : ‚Ñö) (h‚ÇÄ : 0 < x ‚àß 0 < y ‚àß 0 < z) (h‚ÇÅ : x * y * z = 1)
  (h‚ÇÇ : x + 1 / z = 5) (h‚ÇÉ : y + 1 / x = 29) (h‚ÇÑ : z + 1 / y = m) (h‚ÇÖ : 0 < m) :
  ‚Üëm.den + m.num = 5 :=



Theorem: aime_1991_p1
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1991_p1 (x y : ‚Ñï) (h‚ÇÄ : 0 < x ‚àß 0 < y) (h‚ÇÅ : x * y + (x + y) = 71)
  (h‚ÇÇ : x ^ 2 * y + x * y ^ 2 = 880) : x ^ 2 + y ^ 2 = 146 :=



Theorem: amc12a_2009_p7
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2009_p7
  (x : ‚Ñù)
  (n : ‚Ñï)
  (a : ‚Ñï ‚Üí ‚Ñù)
  (h‚ÇÅ : ‚àÄ m, a (m + 1) - a m = a (m + 2) - a (m + 1))
  (h‚ÇÇ : a 1 = 2 * x - 3)
  (h‚ÇÉ : a 2 = 5 * x - 11)
  (h‚ÇÑ : a 3 = 3 * x + 1)
  (h‚ÇÖ : a n = 2009) :
  n = 502 :=



Theorem: aime_1984_p7
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1984_p7
  (f : ‚Ñ§ ‚Üí ‚Ñ§)
  (h‚ÇÄ : ‚àÄ n, 1000 ‚â§ n ‚Üí f n = n - 3)
  (h‚ÇÅ : ‚àÄ n, n < 1000 ‚Üí f n = f (f (n + 5))) :
  f 84 = 997 :=



Theorem: algebra_absxm1pabsxpabsxp1eqxp2_0leqxleq1
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_absxm1pabsxpabsxp1eqxp2_0leqxleq1
  (x : ‚Ñù)
  (h‚ÇÄ : abs (x - 1) + abs x + abs (x + 1) = x + 2) :
  0 ‚â§ x ‚àß x ‚â§ 1 :=



Theorem: amc12a_2021_p25
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p25
  (N : ‚Ñï)
  (f : ‚Ñï ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ n, 0 < n ‚Üí f n = ((Nat.divisors n).card)/(n^((1:‚Ñù)/3)))
  (h‚ÇÅ : ‚àÄ n ‚â† N, 0 < n ‚Üí f n < f N) :
  (Nat.digits 10 N).sum = 9 :=



Theorem: aime_1988_p8
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1988_p8
  (f : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, 0 < x ‚Üí f x x = x)
  (h‚ÇÅ : ‚àÄ x y, (0 < x ‚àß 0 < y) ‚Üí f x y = f y x)
  (h‚ÇÇ : ‚àÄ x y, (0 < x ‚àß 0 < y) ‚Üí (‚Üëx + ‚Üëy) * f x y = y * (f x (x + y))) :
  f 14 52 = 364 :=



Theorem: amc12a_2021_p19
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p19
  (S : Finset ‚Ñù)
  (h‚ÇÄ : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üî 0 ‚â§ x ‚àß x ‚â§ Real.pi ‚àß Real.sin (Real.pi / 2 * Real.cos x) = Real.cos (Real.pi / 2 * Real.sin x)) :
  S.card = 2 :=



Theorem: imo_1997_p5
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1997_p5
  (x y : ‚Ñï)
  (h‚ÇÄ : 0 < x ‚àß 0 < y)
  (h‚ÇÅ : x^(y^2) = y^x) :
  (x, y) = (1, 1) ‚à® (x, y) = (16, 2) ‚à® (x, y) = (27, 3) :=



Theorem: algebra_sqineq_at2malt1
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_sqineq_at2malt1
  (a : ‚Ñù) :
  a * (2 - a) ‚â§ 1 :=



Theorem: amc12a_2020_p7
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2020_p7
  (a : ‚Ñï ‚Üí ‚Ñï)
  (h‚ÇÄ : (a 0)^3 = 1)
  (h‚ÇÅ : (a 1)^3 = 8)
  (h‚ÇÇ : (a 2)^3 = 27)
  (h‚ÇÉ : (a 3)^3 = 64)
  (h‚ÇÑ : (a 4)^3 = 125)
  (h‚ÇÖ : (a 5)^3 = 216)
  (h‚ÇÜ : (a 6)^3 = 343) :
  ‚àë k in Finset.range 7, (6 * (a k)^2) - ‚Üë(2 * ‚àë k in Finset.range 6, (a k)^2) = 658 :=



Theorem: imo_1961_p1
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1961_p1 (x y z a b : ‚Ñù) (h‚ÇÄ : 0 < x ‚àß 0 < y ‚àß 0 < z) (h‚ÇÅ : x ‚â† y) (h‚ÇÇ : y ‚â† z)
  (h‚ÇÉ : z ‚â† x) (h‚ÇÑ : x + y + z = a) (h‚ÇÖ : x ^ 2 + y ^ 2 + z ^ 2 = b ^ 2) (h‚ÇÜ : x * y = z ^ 2) :
  0 < a ‚àß b ^ 2 < a ^ 2 ‚àß a ^ 2 < 3 * b ^ 2 :=



Theorem: numbertheory_exk2powkeqapb2mulbpa2_aeq1
File path: MiniF2F/Test.lean
Theorem statement: theorem numbertheory_exk2powkeqapb2mulbpa2_aeq1
  (a b : ‚Ñï)
  (h‚ÇÄ : 0 < a ‚àß 0 < b)
  (h‚ÇÅ : ‚àÉ k > 0, 2^k = (a + b^2) * (b + a^2)) :
  a = 1 :=



Theorem: mathd_numbertheory_541
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_541
  (m n : ‚Ñï)
  (h‚ÇÄ : 1 < m)
  (h‚ÇÅ : 1 < n)
  (h‚ÇÇ : m * n = 2005) :
  m + n = 406 :=



Theorem: mathd_numbertheory_277
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_277
  (m n : ‚Ñï)
  (h‚ÇÄ : Nat.gcd m n = 6)
  (h‚ÇÅ : Nat.lcm m n = 126) :
  60 ‚â§ m + n :=



Theorem: algebra_apbmpcneq0_aeq0anbeq0anceq0
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_apbmpcneq0_aeq0anbeq0anceq0
  (a b c : ‚Ñö)
  (m n : ‚Ñù)
  (h‚ÇÄ : 0 < m ‚àß 0 < n)
  (h‚ÇÅ : m^3 = 2)
  (h‚ÇÇ : n^3 = 4)
  (h‚ÇÉ : (a:‚Ñù) + b * m + c * n = 0) :
  a = 0 ‚àß b = 0 ‚àß c = 0 :=



Theorem: amc12a_2009_p25
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2009_p25 (a : ‚Ñï ‚Üí ‚Ñù) (h‚ÇÄ : a 1 = 1) (h‚ÇÅ : a 2 = 1 / Real.sqrt 3)
  (h‚ÇÇ : ‚àÄ n, 1 ‚â§ n ‚Üí a (n + 2) = (a n + a (n + 1)) / (1 - a n * a (n + 1))) : abs (a 2009) = 0 :=



Theorem: amc12a_2010_p10
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2010_p10 (p q : ‚Ñù) (a : ‚Ñï ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ n, a (n + 2) - a (n + 1) = a (n + 1) - a n)
  (h‚ÇÅ : a 1 = p) (h‚ÇÇ : a 2 = 9) (h‚ÇÉ : a 3 = 3 * p - q) (h‚ÇÑ : a 4 = 3 * p + q) : a 2010 = 8041 :=



Theorem: imo_1988_p6
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1988_p6 (a b : ‚Ñï) (h‚ÇÄ : 0 < a ‚àß 0 < b) (h‚ÇÅ : a * b + 1 ‚à£ a ^ 2 + b ^ 2) :
  ‚àÉ x : ‚Ñï, (x ^ 2 : ‚Ñù) = (a ^ 2 + b ^ 2) / (a * b + 1) :=



Theorem: aime_1984_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem aime_1984_p5 (a b : ‚Ñù) (h‚ÇÄ : Real.logb 8 a + Real.logb 4 (b ^ 2) = 5)
  (h‚ÇÅ : Real.logb 8 b + Real.logb 4 (a ^ 2) = 7) : a * b = 512 :=



Theorem: amc12a_2011_p18
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2011_p18 (x y : ‚Ñù) (h‚ÇÄ : abs (x + y) + abs (x - y) = 2) :
  x ^ 2 - 6 * x + y ^ 2 ‚â§ 8 :=



Theorem: amc12a_2002_p21
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2002_p21 (u : ‚Ñï ‚Üí ‚Ñï) (h‚ÇÄ : u 0 = 4) (h‚ÇÅ : u 1 = 7)
    (h‚ÇÇ : ‚àÄ n ‚â• 2, u (n + 2) = (u n + u (n + 1)) % 10) :
    ‚àÄ n, (‚àë k in Finset.range n, u k) > 10000 ‚Üí 1999 ‚â§ n :=



Theorem: amc12a_2013_p8
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2013_p8 (x y : ‚Ñù) (h‚ÇÄ : x ‚â† 0) (h‚ÇÅ : y ‚â† 0) (h‚ÇÇ : x ‚â† y)
  (h‚ÇÉ : x + 2 / x = y + 2 / y) : x * y = 2 :=



Theorem: mathd_numbertheory_314
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_314
  (r n : ‚Ñï)
  (h‚ÇÄ : r = 1342 % 13)
  (h‚ÇÅ : 0 < n)
  (h‚ÇÇ : 1342‚à£n)
  (h‚ÇÉ : n % 13 < r) :
  6710 ‚â§ n :=



Theorem: mathd_algebra_332
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_algebra_332
  (x y : ‚Ñù)
  (h‚ÇÄ : (x + y) / 2 = 7)
  (h‚ÇÅ : Real.sqrt (x * y) = Real.sqrt 19) :
  x^2 + y^2 = 158 :=



Theorem: amc12a_2021_p12
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2021_p12
  (a b c d : ‚Ñù)
  (f : ‚ÑÇ ‚Üí ‚ÑÇ)
  (h‚ÇÄ : ‚àÄ z, f z = z^6 - 10 * z^5 + a * z^4 + b * z^3 + c * z^2 + d * z + 16)
  (h‚ÇÅ : ‚àÄ z, f z = 0 ‚Üí (z.im = 0 ‚àß 0 < z.re ‚àß ‚Üë(Int.floor z.re) = z.re)) :
  b = -88 :=



Theorem: amc12a_2008_p25
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2008_p25
  (a b : ‚Ñï ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ n, a (n + 1) = Real.sqrt 3 * a n - b n)
  (h‚ÇÅ : ‚àÄ n, b (n + 1) = Real.sqrt 3 * b n + a n)
  (h‚ÇÇ : a 100 = 2)
  (h‚ÇÉ : b 100 = 4) :
  a 1 + b 1 = 1 / (2^98) :=



Theorem: mathd_algebra_480
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_algebra_480 (f : ‚Ñù ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ x < 0, f x = -x ^ 2 - 1)
  (h‚ÇÅ : ‚àÄ x, 0 ‚â§ x ‚àß x < 4 ‚Üí f x = 2) (h‚ÇÇ : ‚àÄ x ‚â• 4, f x = Real.sqrt x) : f œÄ = 2 :=



Theorem: amc12b_2003_p6
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12b_2003_p6 (a r : ‚Ñù) (u : ‚Ñï ‚Üí ‚Ñù) (h‚ÇÄ : ‚àÄ k, u k = a * r ^ k) (h‚ÇÅ : u 1 = 2)
  (h‚ÇÇ : u 3 = 6) : u 0 = 2 / Real.sqrt 3 ‚à® u 0 = -(2 / Real.sqrt 3) :=



Theorem: induction_prod1p1onk3le3m1onn
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_prod1p1onk3le3m1onn
  (n : ‚Ñï)
  (h‚ÇÄ : 0 < n) :
  ‚àè k in Finset.Icc 1 n, (1 + (1:‚Ñù) / k^3) ‚â§ (3:‚Ñù) - 1 / ‚Üën :=



Theorem: induction_ineq_nsqlefactn
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_ineq_nsqlefactn (n : ‚Ñï) (h‚ÇÄ : 4 ‚â§ n) : n ^ 2 ‚â§ n ! :=



Theorem: aime_1987_p5
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1987_p5
  (x y : ‚Ñ§)
  (h‚ÇÄ : y^2 + 3 * (x^2 * y^2) = 30 * x^2 + 517):
  3 * (x^2 * y^2) = 588 :=



Theorem: aime_1994_p3
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1994_p3
  (x : ‚Ñ§)
  (f : ‚Ñ§ ‚Üí ‚Ñ§)
  (h0 : f x + f (x-1) = x^2)
  (h1 : f 19 = 94):
  f (94) % 1000 = 561 :=



Theorem: imo_1978_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1978_p5 (n : ‚Ñï) (a : ‚Ñï ‚Üí ‚Ñï) (h‚ÇÄ : Function.Injective a) (h‚ÇÅ : a 0 = 0) (h‚ÇÇ : 0 < n) :
  (‚àë k in Finset.Icc 1 n, (1 : ‚Ñù) / k) ‚â§ ‚àë k in Finset.Icc 1 n, (a k : ‚Ñù) / k ^ 2 :=



Theorem: amc12_2000_p1
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12_2000_p1
  (i m o : ‚Ñï)
  (h‚ÇÄ : i ‚â† m ‚àß m ‚â† o ‚àß o ‚â† i)
  (h‚ÇÅ : i*m*o = 2001) :
  i+m+o ‚â§ 671 :=



Theorem: mathd_numbertheory_13
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_13 (u v : ‚Ñï) (S : Set ‚Ñï)
  (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚àà S ‚Üî 0 < n ‚àß 14 * n % 100 = 46) (h‚ÇÅ : IsLeast S u)
  (h‚ÇÇ : IsLeast (S \ {u}) v) : (u + v : ‚Ñö) / 2 = 64 :=



Theorem: mathd_numbertheory_521
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_521
  (m n : ‚Ñï)
  (h‚ÇÄ : Even m)
  (h‚ÇÅ : Even n)
  (h‚ÇÇ : m - n = 2)
  (h‚ÇÉ : m * n = 288) :
  m = 18 :=



Theorem: numbertheory_xsqpysqintdenomeq
File path: MiniF2F/Valid.lean
Theorem statement: theorem numbertheory_xsqpysqintdenomeq (x y : ‚Ñö) (h‚ÇÄ : (x ^ 2 + y ^ 2).den = 1) : x.den = y.den :=



Theorem: imo_1974_p5
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1974_p5 (a b c d s : ‚Ñù) (h‚ÇÄ : 0 < a ‚àß 0 < b ‚àß 0 < c ‚àß 0 < d)
  (h‚ÇÅ : s = a / (a + b + d) + b / (a + b + c) + c / (b + c + d) + d / (a + c + d)) :
  1 < s ‚àß s < 2 :=



Theorem: amc12a_2002_p12
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2002_p12 (f : ‚Ñù ‚Üí ‚Ñù) (k : ‚Ñù) (a b : ‚Ñï) (h‚ÇÄ : ‚àÄ x, f x = x ^ 2 - 63 * x + k)
  (h‚ÇÅ : f a = 0 ‚àß f b = 0) (h‚ÇÇ : a ‚â† b) (h‚ÇÉ : Nat.Prime a ‚àß Nat.Prime b) : k = 122 :=



Theorem: imo_1973_p3
File path: MiniF2F/Valid.lean
Theorem statement: theorem imo_1973_p3 (a b : ‚Ñù) (h‚ÇÄ : ‚àÉ x, x ^ 4 + a * x ^ 3 + b * x ^ 2 + a * x + 1 = 0) :
  4 / 5 ‚â§ a ^ 2 + b ^ 2 :=



Theorem: imo_1985_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1985_p6
  (f : ‚Ñï ‚Üí NNReal ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f 1 x = x)
  (h‚ÇÅ : ‚àÄ x n, f (n + 1) x = f n x * (f n x + 1 / n)) :
  ‚àÉ! a, ‚àÄ n, 0 < n ‚Üí 0 < f n a ‚àß f n a < f (n + 1) a ‚àß f (n + 1) a < 1 :=



Theorem: aime_1983_p3
File path: MiniF2F/Test.lean
Theorem statement: theorem aime_1983_p3
  (f : ‚Ñù ‚Üí ‚Ñù)
  (h‚ÇÄ : ‚àÄ x, f x = (x^2 + (18 * x +  30) - 2 * Real.sqrt (x^2 + (18 * x + 45))))
  (h‚ÇÅ : Fintype (f‚Åª¬π' {0})) :
  ‚àè x in (f‚Åª¬π' {0}).toFinset, x = 20 :=



Theorem: amc12b_2021_p13
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12b_2021_p13
  (S : Finset ‚Ñù)
  (h‚ÇÄ : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üî 0 < x ‚àß x ‚â§ 2 * Real.pi ‚àß 1 - 3 * Real.sin x + 5 * Real.cos (3 * x) = 0) :
  S.card = 6 :=



Theorem: induction_11div10tonmn1ton
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_11div10tonmn1ton
  (n : ‚Ñï) :
  11 ‚à£ (10^n - (-1 : ‚Ñ§)^n) :=



Theorem: induction_sum_odd
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_sum_odd (n : ‚Ñï) : (‚àë k in Finset.range n, 2 * k) + 1 = n ^ 2 :=



Theorem: mathd_numbertheory_326
File path: MiniF2F/Valid.lean
Theorem statement: theorem mathd_numbertheory_326 (n : ‚Ñ§) (h‚ÇÄ : (n - 1) * n * (n + 1) = 720 ) : n + 1 = 10 :=



Theorem: amc12a_2019_p21
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2019_p21 (z : ‚ÑÇ) (h‚ÇÄ : z = (1 + Complex.I) / Real.sqrt 2) :
  ((‚àë k : ‚Ñ§ in Finset.Icc 1 12, z ^ k ^ 2) * (‚àë k : ‚Ñ§ in Finset.Icc 1 12, 1 / z ^ k ^ 2)) = 36 :=



Theorem: amc12a_2020_p21
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2020_p21 (S : Finset ‚Ñï)
  (h‚ÇÄ : ‚àÄ n : ‚Ñï, n ‚àà S ‚Üî 5 ‚à£ n ‚àß Nat.lcm 5! n = 5 * Nat.gcd 10! n) : S.card = 48 :=



Theorem: amc12a_2016_p2
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2016_p2 (x : ‚Ñù) (h‚ÇÄ : (10 : ‚Ñù) ^ x * 100 ^ (2 * x) = 1000 ^ 5) : x = 3 :=



Theorem: induction_pprime_pdvdapowpma
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_pprime_pdvdapowpma
  (p a : ‚Ñï)
  (h‚ÇÄ : 0 < a)
  (h‚ÇÅ : Nat.Prime p) :
  p ‚à£ (a^p - a) :=



Theorem: imo_1960_p2
File path: MiniF2F/Test.lean
Theorem statement: theorem imo_1960_p2
  (x : ‚Ñù)
  (h‚ÇÄ : 0 ‚â§ 1 + 2 * x)
  (h‚ÇÅ : (1 - Real.sqrt (1 + 2 * x))^2 ‚â† 0)
  (h‚ÇÇ : (4 * x^2) / (1 - Real.sqrt (1 + 2*x))^2 < 2*x + 9) :
  -(1 / 2) ‚â§ x ‚àß x < 45 / 8 :=



Theorem: algebra_9onxpypzleqsum2onxpy
File path: MiniF2F/Test.lean
Theorem statement: theorem algebra_9onxpypzleqsum2onxpy
  (x y z : ‚Ñù)
  (h‚ÇÄ : 0 < x ‚àß 0 < y ‚àß 0 < z) :
  9 / (x + y + z) ‚â§ 2 / (x + y) + 2 / (y + z) + 2 / (z + x) :=



Theorem: amc12a_2017_p7
File path: MiniF2F/Valid.lean
Theorem statement: theorem amc12a_2017_p7 (f : ‚Ñï ‚Üí ‚Ñù) (h‚ÇÄ : f 1 = 2) (h‚ÇÅ : ‚àÄ n, 1 < n ‚àß Even n ‚Üí f n = f (n - 1) + 1)
  (h‚ÇÇ : ‚àÄ n, 1 < n ‚àß Odd n ‚Üí f n = f (n - 2) + 2) : f 2017 = 2018 :=



Theorem: amc12_2000_p6
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12_2000_p6
  (p q : ‚Ñï)
  (h‚ÇÄ : Nat.Prime p ‚àß Nat.Prime q)
  (h‚ÇÅ : 4 ‚â§ p ‚àß p ‚â§ 18)
  (h‚ÇÇ : 4 ‚â§ q ‚àß q ‚â§ 18) :
  p * q - (p + q) ‚â† 194 :=



Theorem: induction_divisibility_3divnto3m2n
File path: MiniF2F/Valid.lean
Theorem statement: theorem induction_divisibility_3divnto3m2n (n : ‚Ñï) : 3 ‚à£ n ^ 3 + 2 * n :=



Theorem: aimeII_2020_p6
File path: MiniF2F/Valid.lean
Theorem statement: theorem aimeII_2020_p6 (t : ‚Ñï ‚Üí ‚Ñö) (h‚ÇÄ : t 1 = 20) (h‚ÇÅ : t 2 = 21)
  (h‚ÇÇ : ‚àÄ n ‚â• 3, t n = (5 * t (n - 1) + 1) / (25 * t (n - 2))) :
  ‚Üë(t 2020).den + (t 2020).num = 626 :=



Theorem: amc12a_2020_p25
File path: MiniF2F/Test.lean
Theorem statement: theorem amc12a_2020_p25
  (a : ‚Ñö)
  (S : Finset ‚Ñù)
  (h‚ÇÄ : ‚àÄ (x : ‚Ñù), x ‚àà S ‚Üî ‚Üë‚åäx‚åã * (x - ‚Üë‚åäx‚åã) = ‚Üëa * x ^ 2)
  (h‚ÇÅ : ‚àë k in S, k = 420) :
  ‚Üëa.den + a.num = 929 :=



Theorem: induction_nfactltnexpnm1ngt3
File path: MiniF2F/Test.lean
Theorem statement: theorem induction_nfactltnexpnm1ngt3
  (n : ‚Ñï)
  (h‚ÇÄ : 3 ‚â§ n) :
  n! < n^(n - 1) :=



Theorem: mathd_numbertheory_227
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_227
  (x y n : ‚Ñï+)
  (h‚ÇÄ : ‚Üëx / (4:‚Ñù) + y / 6 = (x + y) / n) :
  n = 5 :=



Theorem: mathd_numbertheory_234
File path: MiniF2F/Test.lean
Theorem statement: theorem mathd_numbertheory_234
  (a b : ‚Ñï)
  (h‚ÇÄ : 1 ‚â§ a ‚àß a ‚â§ 9 ‚àß b ‚â§ 9)
  (h‚ÇÅ : (10 * a + b)^3 = 912673) :
  a + b = 16 :=


